[
  {
    "timestamp": "2026-02-28T04:05:26.113Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Write",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\hooks\\session_hook.js",
        "content": "const fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n"
      },
      "tool_response": {
        "type": "update",
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\hooks\\session_hook.js",
        "content": "const fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n",
        "structuredPatch": [
          {
            "oldStart": 1,
            "oldLines": 26,
            "newStart": 1,
            "newLines": 23,
            "lines": [
              "-// Discover the payload shape for any hook ‚Äî log everything first",
              "+const fs = require(\"fs\");",
              "+",
              " async function main() {",
              "   const chunks = [];",
              "   for await (const chunk of process.stdin) chunks.push(chunk);",
              "   const payload = JSON.parse(Buffer.concat(chunks).toString());",
              " ",
              "-  // tool_input fields differ per tool:",
              "-  //   Read/Grep/Glob ‚Üí payload.tool_input.file_path or .pattern",
              "-  //   Edit/Write     ‚Üí payload.tool_input.file_path + payload.tool_input.new_string",
              "-  //   Bash           ‚Üí payload.tool_input.command",
              "-  //   Task           ‚Üí payload.tool_input.prompt",
              "-  //",
              "-  // Non-tool hooks (Stop, Notification, etc.) have no tool_input at all.",
              "-  // Use hook_event_name to branch your logic:",
              "+  // Read existing entries, append new one, write back",
              "+  const logPath = \"./hooks/payloads.json\";",
              "+  let entries = [];",
              "+  if (fs.existsSync(logPath)) {",
              "+    try {",
              "+      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));",
              "+    } catch {",
              "+      entries = [];",
              "+    }",
              "+  }",
              " ",
              "-  const event = payload.hook_event_name;",
              "-  const toolName = payload.tool_name;          // only present for PreToolUse/PostToolUse",
              "-  const toolInput = payload.tool_input || {};  // only present for PreToolUse/PostToolUse",
              "-",
              "-  require(\"fs\").appendFileSync(",
              "-    \"./hooks/debug.log\",",
              "-    JSON.stringify({ event, toolName, toolInput }, null, 2) + \"\\n---\\n\"",
              "-  );",
              "+  entries.push({ timestamp: new Date().toISOString(), payload });",
              "+  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));",
              " }",
              " ",
              "-main();",
              "\\ No newline at end of file",
              "+main();"
            ]
          }
        ],
        "originalFile": "// Discover the payload shape for any hook ‚Äî log everything first\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // tool_input fields differ per tool:\n  //   Read/Grep/Glob ‚Üí payload.tool_input.file_path or .pattern\n  //   Edit/Write     ‚Üí payload.tool_input.file_path + payload.tool_input.new_string\n  //   Bash           ‚Üí payload.tool_input.command\n  //   Task           ‚Üí payload.tool_input.prompt\n  //\n  // Non-tool hooks (Stop, Notification, etc.) have no tool_input at all.\n  // Use hook_event_name to branch your logic:\n\n  const event = payload.hook_event_name;\n  const toolName = payload.tool_name;          // only present for PreToolUse/PostToolUse\n  const toolInput = payload.tool_input || {};  // only present for PreToolUse/PostToolUse\n\n  require(\"fs\").appendFileSync(\n    \"./hooks/debug.log\",\n    JSON.stringify({ event, toolName, toolInput }, null, 2) + \"\\n---\\n\"\n  );\n}\n\nmain();"
      },
      "tool_use_id": "toolu_019c9VUhwPRTPfEMAnALwPRg"
    }
  },
  {
    "timestamp": "2026-02-28T04:05:32.570Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Now every hook that fires will append its full raw payload to `hooks/payloads.json` as an array of `{ timestamp, payload }` entries. After a few interactions you can read that file to see exactly what each hook type sends.\n\nBut first, all 7 lifecycle hooks need to be re-enabled in `settings.local.json` ‚Äî right now only `PreToolUse` is active. Want me to add them back?"
    }
  },
  {
    "timestamp": "2026-02-28T04:05:36.287Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a539b76f5713176e7",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b\\subagents\\agent-a539b76f5713176e7.jsonl",
      "agent_type": "",
      "last_assistant_message": "yes add them back"
    }
  },
  {
    "timestamp": "2026-02-28T04:05:59.358Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "yes add them back"
    }
  },
  {
    "timestamp": "2026-02-28T04:06:02.024Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\settings.local.json"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\settings.local.json",
          "content": "{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run:*)\",\n      \"WebFetch(domain:anthropic.skilljar.com)\",\n      \"Bash(npx prisma:*)\"\n    ],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/session_hook.js\"\n          }\n        ]\n      }\n    ],\n    \n    \"Notification\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/session_hook.js\"\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/session_hook.js\"\n          }\n        ]\n      }\n    ],\n    \"SubagentStop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/session_hook.js\"\n          }\n        ]\n      }\n    ],\n    \"PreCompact\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/session_hook.js\"\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/session_hook.js\"\n          }\n        ]\n      }\n    ],\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/session_hook.js\"\n          }\n        ]\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/session_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
          "numLines": 106,
          "startLine": 1,
          "totalLines": 106
        }
      },
      "tool_use_id": "toolu_01WfyZiHb9wSvg8e3FS4E7Hc"
    }
  },
  {
    "timestamp": "2026-02-28T04:06:07.505Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "All 7 are already there ‚Äî looks like the user re-added them. The file is complete with all hooks pointing to `session_hook.js`. Nothing to change.\n\nAfter your next few interactions, check `hooks/payloads.json` to see the full payloads from each hook type that fired."
    }
  },
  {
    "timestamp": "2026-02-28T04:06:09.547Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a03129ef496a14f61",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b\\subagents\\agent-a03129ef496a14f61.jsonl",
      "agent_type": "",
      "last_assistant_message": "read hooks/payloads.json"
    }
  },
  {
    "timestamp": "2026-02-28T04:08:37.778Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "add payload.png image to section 7 in hooks concept"
    }
  },
  {
    "timestamp": "2026-02-28T04:08:44.719Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Grep",
      "tool_input": {
        "pattern": "heading:",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "output_mode": "content",
        "-n": true
      },
      "tool_response": {
        "mode": "content",
        "numFiles": 0,
        "filenames": [],
        "content": "11:  heading: string;\r\n73:        heading: \"Overview\",\r\n78:        heading: \"Installation\",\r\n97:        heading: \"How It Works\",\r\n101:        heading: \"Your First Session\",\r\n120:        heading: \"Tips\",\r\n136:        heading: \"The /init Command\",\r\n158:        heading: \"CLAUDE.md File Locations\",\r\n186:        heading: \"Tips\",\r\n201:        heading: \"Overview\",\r\n205:        heading: \"Launch Flags\",\r\n238:        heading: \"Slash Commands (In-Session)\",\r\n262:        heading: \"Custom Commands\",\r\n294:        heading: \"Output & Scripting\",\r\n309:        heading: \"Tips\",\r\n337:        heading: \"Overview\",\r\n341:        heading: \"Essential Shortcuts\",\r\n354:        heading: \"Interruption & Control\",\r\n372:        heading: \"Multi-line Input\",\r\n383:        heading: \"Vim Mode\",\r\n399:        heading: \"Rewinding Conversations\",\r\n422:        heading: \"Interrupting Claude with Escape\",\r\n439:        heading: \"Tips\",\r\n455:        heading: \"Overview\",\r\n459:        heading: \"Default Mode\",\r\n475:        heading: \"Auto-Approve Mode\",\r\n495:        heading: \"Read-Only Mode\",\r\n513:        heading: \"Permission Rules\",\r\n535:        heading: \"Tips\",\r\n551:        heading: \"Overview\",\r\n555:        heading: \"settings.json ‚Äî Shared Project Config\",\r\n577:        heading: \"settings.local.json ‚Äî Personal Overrides\",\r\n606:        heading: \"Merge Order\",\r\n624:        heading: \"What Belongs Where\",\r\n637:        heading: \"Tips\",\r\n660:        heading: \"Overview\",\r\n664:        heading: \"Entering Plan Mode\",\r\n698:        heading: \"How It Works\",\r\n702:        heading: \"When to Use Plan Mode\",\r\n718:        heading: \"Enabling Planning Mode\",\r\n741:        heading: \"Thinking Modes\",\r\n767:        heading: \"Tips\",\r\n782:        heading: \"Overview\",\r\n786:        heading: \"File System Tools\",\r\n804:        heading: \"Execution Tools\",\r\n818:        heading: \"Intelligence Tools\",\r\n832:        heading: \"How Claude Selects Tools\",\r\n836:        heading: \"Tips\",\r\n852:        heading: \"Overview\",\r\n856:        heading: \"When It Activates\",\r\n876:        heading: \"How It Works\",\r\n880:        heading: \"Use Cases\",\r\n900:        heading: \"Tips\",\r\n916:        heading: \"Overview\",\r\n923:        heading: \"How Are Memories Stored?\",\r\n940:        heading: \"Memory Directory\",\r\n958:        heading: \"What Gets Saved\",\r\n987:        heading: \"Managing Memory\",\r\n1002:        heading: \"Disabling Auto Memory\",\r\n1014:        heading: \"Tips\",\r\n1031:        heading: \"Overview\",\r\n1035:        heading: \"Context Limits\",\r\n1052:        heading: \"The /compact Command\",\r\n1072:        heading: \"The /clear Command\",\r\n1091:        heading: \"Best Practices\",\r\n1105:        heading: \"Tips\",\r\n1121:        heading: \"Overview\",\r\n1125:        heading: \"How It Works\",\r\n1157:        heading: \"Cache Lifetime\",\r\n1185:        heading: \"When to Use\",\r\n1202:        heading: \"Tips\",\r\n1219:        heading: \"Overview\",\r\n1223:        heading: \"The Task Tool\",\r\n1254:        heading: \"Subagent Types in Claude Code\",\r\n1274:        heading: \"Parallel Execution\",\r\n1292:        heading: \"Worktree Isolation\",\r\n1307:        heading: \"Tips\",\r\n1323:        heading: \"Overview\",\r\n1327:        heading: \"Hooks Configuration\",\r\n1337:        heading: \"PreToolUse Hooks\",\r\n1370:        heading: \"PostToolUse Hooks\",\r\n1407:        heading: \"Available Tools\",\r\n1424:        heading: \"Other Hook Types\",\r\n1438:        heading: \"Hook Payload Structure\",\r\n1478:        heading: \"Tips\",\r\n1495:        heading: \"Overview\",\r\n1499:        heading: \"Creating a Skill\",\r\n1526:        heading: \"Using Skills\",\r\n1543:        heading: \"Skill File Structure\",\r\n1569:        heading: \"Tips\",\r\n1586:        heading: \"Overview\",\r\n1590:        heading: \"What Are Worktrees?\",\r\n1611:        heading: \"Using Worktrees in Claude Code\",\r\n1636:        heading: \"Worktree Isolation for Subagents\",\r\n1656:        heading: \"Tips\",\r\n1673:        heading: \"Overview\",\r\n1677:        heading: \"MCP Architecture\",\r\n1703:        heading: \"Configuring MCP Servers\",\r\n1730:        heading: \"Writing an MCP Server\",\r\n1759:        heading: \"Tips\",\r\n1776:        heading: \"Overview\",\r\n1780:        heading: \"Settings File Locations\",\r\n1804:        heading: \"Key Settings\",\r\n1853:        heading: \"Environment Variables\",\r\n1869:        heading: \"Tips\",",
        "numLines": 105
      },
      "tool_use_id": "toolu_0173K7PM7So2kmnoyn6NMmtK"
    }
  },
  {
    "timestamp": "2026-02-28T04:08:52.317Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1438,
        "limit": 45
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// Discover the payload shape for any hook ‚Äî log everything first\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },",
          "numLines": 45,
          "startLine": 1438,
          "totalLines": 1875
        }
      },
      "tool_use_id": "toolu_01T7jWmaTbgHsrDSe92fMCFG"
    }
  },
  {
    "timestamp": "2026-02-28T04:09:01.909Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "        code: {\n          language: \"js\",\n          content: `// Discover the payload shape for any hook ‚Äî log everything first\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n      },",
        "new_string": "        code: {\n          language: \"js\",\n          content: `// Discover the payload shape for any hook ‚Äî log everything first\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/payload.png\",\n            alt: \"Hook payload structure logged to payloads.json\",\n          },\n        ],\n      },",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "        code: {\n          language: \"js\",\n          content: `// Discover the payload shape for any hook ‚Äî log everything first\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n      },",
        "newString": "        code: {\n          language: \"js\",\n          content: `// Discover the payload shape for any hook ‚Äî log everything first\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/payload.png\",\n            alt: \"Hook payload structure logged to payloads.json\",\n          },\n        ],\n      },",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents & Task Tool\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"The Task tool lets Claude spawn subagents ‚Äî independent Claude instances that handle specific subtasks autonomously. Subagents have their own context, tools, and execution scope. They're perfect for parallel work, isolating expensive research from the main context, and delegating specialized tasks to optimized agent types.\",\n      },\n      {\n        heading: \"The Task Tool\",\n        body: \"Claude uses the Task tool internally to create subagents. When building Claude applications with the Agent SDK or API, you can build multi-agent systems where agents spawn and coordinate other agents.\",\n        code: {\n          language: \"python\",\n          content: `# Using Claude\\'s Agent SDK to create subagent workflows\nimport anthropic\n\nclient = anthropic.Anthropic()\n\n# Spawn a research subagent from your main agent\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=4096,\n    tools=[\n        {\n            \"name\": \"run_research_agent\",\n            \"description\": \"Spawn a specialized research agent\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"task\": {\"type\": \"string\"},\n                    \"context\": {\"type\": \"string\"}\n                }\n            }\n        }\n    ],\n    messages=[{\"role\": \"user\", \"content\": \"Research best auth patterns for Next.js\"}]\n)`,\n        },\n      },\n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// Discover the payload shape for any hook ‚Äî log everything first\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1473,
            "oldLines": 6,
            "newStart": 1473,
            "newLines": 12,
            "lines": [
              " main();",
              " `,",
              "         },",
              "+        screenshots: [",
              "+          {",
              "+            src: \"/screenshots/hooks/payload.png\",",
              "+            alt: \"Hook payload structure logged to payloads.json\",",
              "+          },",
              "+        ],",
              "       },",
              "       {",
              "         heading: \"Tips\","
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01NAxzEB1zh5Cwn68gCyH5J5"
    }
  },
  {
    "timestamp": "2026-02-28T04:09:05.631Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Added `payload.png` as a screenshot to section 7 (\"Hook Payload Structure\"). It expects the image at `public/screenshots/hooks/payload.png`."
    }
  },
  {
    "timestamp": "2026-02-28T04:09:07.547Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a01dc7f03efcbf8f0",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b\\subagents\\agent-a01dc7f03efcbf8f0.jsonl",
      "agent_type": "",
      "last_assistant_message": "now read the payloads.json file"
    }
  },
  {
    "timestamp": "2026-02-28T04:10:05.829Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude is waiting for your input",
      "notification_type": "idle_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T04:17:10.490Z",
    "payload": {
      "session_id": "7614f186-b2d1-4b6b-aaf0-eb6d3828f69b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\7614f186-b2d1-4b6b-aaf0-eb6d3828f69b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionEnd",
      "reason": "clear"
    }
  },
  {
    "timestamp": "2026-02-28T04:17:11.002Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionStart",
      "source": "clear"
    }
  },
  {
    "timestamp": "2026-02-28T04:31:46.453Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "now we will move on to subagent and task, i dont want to focus on tast so change the title only to subgent , and content related only related to that"
    }
  },
  {
    "timestamp": "2026-02-28T04:31:51.067Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1,
        "limit": 50
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',",
          "numLines": 50,
          "startLine": 1,
          "totalLines": 1883
        }
      },
      "tool_use_id": "toolu_01Hjhiq4cmwmkKdz1TeRWJLJ"
    }
  },
  {
    "timestamp": "2026-02-28T04:31:57.533Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Grep",
      "tool_input": {
        "pattern": "subagent|task.*tool|Task tool",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "output_mode": "content",
        "-i": true
      },
      "tool_response": {
        "mode": "content",
        "numFiles": 0,
        "filenames": [],
        "content": "783:        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\r\n819:        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\r\n822:          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\r\n833:        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\r\n1208:    slug: \"subagents\",\r\n1209:    title: \"Subagents & Task Tool\",\r\n1215:      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\r\n1219:        body: \"The Task tool lets Claude spawn subagents ‚Äî independent Claude instances that handle specific subtasks autonomously. Subagents have their own context, tools, and execution scope. They're perfect for parallel work, isolating expensive research from the main context, and delegating specialized tasks to optimized agent types.\",\r\n1222:        heading: \"The Task Tool\",\r\n1223:        body: \"Claude uses the Task tool internally to create subagents. When building Claude applications with the Agent SDK or API, you can build multi-agent systems where agents spawn and coordinate other agents.\",\r\n1226:          content: `# Using Claude\\'s Agent SDK to create subagent workflows\r\n1231:# Spawn a research subagent from your main agent\r\n1253:        heading: \"Subagent Types in Claude Code\",\r\n1254:        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\r\n1257:          content: `# Built-in subagent types:\r\n1265:Task(subagent_type=\"Explore\",\r\n1268:Task(subagent_type=\"Plan\",\r\n1274:        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\r\n1277:          content: `# Claude might run these subagents in parallel:\r\n1278:[Subagent 1] Explore: Find all components using useState\r\n1279:[Subagent 2] Explore: Find all API routes in the project\r\n1280:[Subagent 3] Explore: Find all TypeScript errors\r\n1286:# Main agent continues other work while subagent runs...\r\n1292:        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\r\n1295:          content: `# Subagent with git worktree isolation:\r\n1300:# Claude creates a temporary branch, subagent makes changes\r\n1307:        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\r\n1428:          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\r\n1442:          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\r\n1595:        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\r\n1644:        heading: \"Worktree Isolation for Subagents\",\r\n1645:        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\r\n1648:          content: `# In Claude Code, subagents with worktree isolation:\r\n1656:# 2. Subagent checks out a new branch there\r\n1657:# 3. Subagent makes all changes in isolation\r\n1665:        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",",
        "numLines": 36
      },
      "tool_use_id": "toolu_01UUcocNCV14Aotq598BpgHZ"
    }
  },
  {
    "timestamp": "2026-02-28T04:32:00.723Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1205,
        "limit": 120
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents & Task Tool\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"The Task tool lets Claude spawn subagents ‚Äî independent Claude instances that handle specific subtasks autonomously. Subagents have their own context, tools, and execution scope. They're perfect for parallel work, isolating expensive research from the main context, and delegating specialized tasks to optimized agent types.\",\n      },\n      {\n        heading: \"The Task Tool\",\n        body: \"Claude uses the Task tool internally to create subagents. When building Claude applications with the Agent SDK or API, you can build multi-agent systems where agents spawn and coordinate other agents.\",\n        code: {\n          language: \"python\",\n          content: `# Using Claude\\'s Agent SDK to create subagent workflows\nimport anthropic\n\nclient = anthropic.Anthropic()\n\n# Spawn a research subagent from your main agent\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=4096,\n    tools=[\n        {\n            \"name\": \"run_research_agent\",\n            \"description\": \"Spawn a specialized research agent\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"task\": {\"type\": \"string\"},\n                    \"context\": {\"type\": \"string\"}\n                }\n            }\n        }\n    ],\n    messages=[{\"role\": \"user\", \"content\": \"Research best auth patterns for Next.js\"}]\n)`,\n        },\n      },\n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },",
          "numLines": 120,
          "startLine": 1205,
          "totalLines": 1883
        }
      },
      "tool_use_id": "toolu_01EEz3CYCXhjNyMTBX9mG9Dx"
    }
  },
  {
    "timestamp": "2026-02-28T04:32:05.707Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "    title: \"Subagents & Task Tool\",",
        "new_string": "    title: \"Subagents\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "    title: \"Subagents & Task Tool\",",
        "newString": "    title: \"Subagents\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents & Task Tool\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"The Task tool lets Claude spawn subagents ‚Äî independent Claude instances that handle specific subtasks autonomously. Subagents have their own context, tools, and execution scope. They're perfect for parallel work, isolating expensive research from the main context, and delegating specialized tasks to optimized agent types.\",\n      },\n      {\n        heading: \"The Task Tool\",\n        body: \"Claude uses the Task tool internally to create subagents. When building Claude applications with the Agent SDK or API, you can build multi-agent systems where agents spawn and coordinate other agents.\",\n        code: {\n          language: \"python\",\n          content: `# Using Claude\\'s Agent SDK to create subagent workflows\nimport anthropic\n\nclient = anthropic.Anthropic()\n\n# Spawn a research subagent from your main agent\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=4096,\n    tools=[\n        {\n            \"name\": \"run_research_agent\",\n            \"description\": \"Spawn a specialized research agent\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"task\": {\"type\": \"string\"},\n                    \"context\": {\"type\": \"string\"}\n                }\n            }\n        }\n    ],\n    messages=[{\"role\": \"user\", \"content\": \"Research best auth patterns for Next.js\"}]\n)`,\n        },\n      },\n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1206,
            "oldLines": 7,
            "newStart": 1206,
            "newLines": 7,
            "lines": [
              "   },",
              "   {",
              "     slug: \"subagents\",",
              "-    title: \"Subagents & Task Tool\",",
              "+    title: \"Subagents\",",
              "     emoji: \"ü§ñ\",",
              "     category: \"Automation\",",
              "     difficulty: \"Advanced\","
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01Pr6RjVk1gGvdAr23X5ViZu"
    }
  },
  {
    "timestamp": "2026-02-28T04:32:09.661Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Title updated to \"Subagents\". The content already focuses on subagents ‚Äî parallel execution, worktree isolation, built-in types, and tips. The \"Task Tool\" section (`src/data/concepts.ts:1222`) shows the Task tool purely as the mechanism for spawning subagents, which is relevant context rather than a separate topic, so no content changes needed unless you want to rename that heading too.\n\nWant me to rename that section heading from \"The Task Tool\" to something like \"How Subagents Are Spawned\" or remove it?"
    }
  },
  {
    "timestamp": "2026-02-28T04:32:11.468Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a77352ecf77cc06cd",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-a77352ecf77cc06cd.jsonl",
      "agent_type": "",
      "last_assistant_message": "rename that heading too"
    }
  },
  {
    "timestamp": "2026-02-28T04:33:39.745Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "Subagents are specialized AI assistants that handle specific types of tasks. Each subagent runs in its own context window with a custom system prompt, specific tool access, and independent permissions. When Claude encounters a task that matches a subagent‚Äôs description, it delegates to that subagent, which works independently and returns results. \"add this has overview content\" tweak it little dont use as it"
    }
  },
  {
    "timestamp": "2026-02-28T04:33:46.059Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "        body: \"The Task tool lets Claude spawn subagents ‚Äî independent Claude instances that handle specific subtasks autonomously. Subagents have their own context, tools, and execution scope. They're perfect for parallel work, isolating expensive research from the main context, and delegating specialized tasks to optimized agent types.\",",
        "new_string": "        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "        body: \"The Task tool lets Claude spawn subagents ‚Äî independent Claude instances that handle specific subtasks autonomously. Subagents have their own context, tools, and execution scope. They're perfect for parallel work, isolating expensive research from the main context, and delegating specialized tasks to optimized agent types.\",",
        "newString": "        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"The Task tool lets Claude spawn subagents ‚Äî independent Claude instances that handle specific subtasks autonomously. Subagents have their own context, tools, and execution scope. They're perfect for parallel work, isolating expensive research from the main context, and delegating specialized tasks to optimized agent types.\",\n      },\n      {\n        heading: \"The Task Tool\",\n        body: \"Claude uses the Task tool internally to create subagents. When building Claude applications with the Agent SDK or API, you can build multi-agent systems where agents spawn and coordinate other agents.\",\n        code: {\n          language: \"python\",\n          content: `# Using Claude\\'s Agent SDK to create subagent workflows\nimport anthropic\n\nclient = anthropic.Anthropic()\n\n# Spawn a research subagent from your main agent\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=4096,\n    tools=[\n        {\n            \"name\": \"run_research_agent\",\n            \"description\": \"Spawn a specialized research agent\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"task\": {\"type\": \"string\"},\n                    \"context\": {\"type\": \"string\"}\n                }\n            }\n        }\n    ],\n    messages=[{\"role\": \"user\", \"content\": \"Research best auth patterns for Next.js\"}]\n)`,\n        },\n      },\n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1216,
            "oldLines": 7,
            "newStart": 1216,
            "newLines": 7,
            "lines": [
              "     sections: [",
              "       {",
              "         heading: \"Overview\",",
              "-        body: \"The Task tool lets Claude spawn subagents ‚Äî independent Claude instances that handle specific subtasks autonomously. Subagents have their own context, tools, and execution scope. They're perfect for parallel work, isolating expensive research from the main context, and delegating specialized tasks to optimized agent types.\",",
              "+        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",",
              "       },",
              "       {",
              "         heading: \"The Task Tool\","
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_012BRotTYcgjhyywxnFu3caE"
    }
  },
  {
    "timestamp": "2026-02-28T04:33:48.699Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Overview updated at `src/data/concepts.ts:1219`. Kept your core ideas but tightened the language and made it flow better."
    }
  },
  {
    "timestamp": "2026-02-28T04:33:50.374Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "af796ec2ff204fc5f",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-af796ec2ff204fc5f.jsonl",
      "agent_type": "",
      "last_assistant_message": "now update the sections content too"
    }
  },
  {
    "timestamp": "2026-02-28T04:35:08.029Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "remove section 3"
    }
  },
  {
    "timestamp": "2026-02-28T04:37:24.601Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "add new section has 3rd , creating own subagent and add the image i have pasted from subagent 1 to sugagebt10 in carousel format. Also add that steps has a bullet points"
    }
  },
  {
    "timestamp": "2026-02-28T04:37:41.271Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "public/screenshots/subagents/*",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app"
      },
      "tool_response": {
        "filenames": [
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent1.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent2.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent3.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent4.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent5.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent6.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent7.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent8.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent9.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent10.png"
        ],
        "durationMs": 1452,
        "numFiles": 10,
        "truncated": false
      },
      "tool_use_id": "toolu_01L4fuaqdV77L9oU8ow773ST"
    }
  },
  {
    "timestamp": "2026-02-28T04:37:45.148Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\\page.tsx"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\\page.tsx",
          "content": "import { notFound } from 'next/navigation';\nimport Link from 'next/link';\nimport { concepts, difficultyBadgeStyles } from '@/data/concepts';\nimport ConceptCard from '@/components/ConceptCard';\nimport CodeBlock from '@/components/CodeBlock';\nimport LikeButton from '@/components/LikeButton';\nimport CommentsSection from '@/components/CommentsSection';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Separator } from '@/components/ui/separator';\nimport { ChevronLeft, ExternalLink } from 'lucide-react';\nimport ScreenshotViewer from '@/components/ScreenshotViewer';\nimport { createClient } from '@/lib/supabase/server';\nimport { prisma } from '@/lib/prisma';\n\nexport const dynamic = 'force-dynamic';\n\ntype Params = Promise<{ slug: string }>;\n\nexport function generateStaticParams() {\n  return concepts.map((c) => ({ slug: c.slug }));\n}\n\nexport async function generateMetadata({ params }: { params: Params }) {\n  const { slug } = await params;\n  const concept = concepts.find((c) => c.slug === slug);\n  if (!concept) return {};\n  return {\n    title: `${concept.title} ‚Äî Claude Code Learning Hub`,\n    description: concept.shortDesc,\n  };\n}\n\nexport default async function ConceptPage({ params }: { params: Params }) {\n  const { slug } = await params;\n  const concept = concepts.find((c) => c.slug === slug);\n\n  if (!concept || !concept.released) notFound();\n\n  const related = concepts\n    .filter((c) => c.category === concept.category && c.slug !== concept.slug)\n    .slice(0, 3);\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  const [likesCount, userLike, rawComments] = await Promise.all([\n    prisma.conceptLike.count({ where: { conceptSlug: slug } }),\n    user\n      ? prisma.conceptLike.findUnique({\n          where: { userId_conceptSlug: { userId: user.id, conceptSlug: slug } },\n        })\n      : Promise.resolve(null),\n    prisma.conceptComment.findMany({\n      where: { conceptSlug: slug, parentId: null },\n      include: {\n        profile: { select: { name: true } },\n        likes: { select: { userId: true } },\n        replies: {\n          include: {\n            profile: { select: { name: true } },\n            likes: { select: { userId: true } },\n          },\n          orderBy: { createdAt: 'asc' },\n        },\n      },\n      orderBy: { createdAt: 'asc' },\n    }),\n  ] as const);\n\n  const comments = rawComments.map((c: any) => ({\n    id: c.id,\n    content: c.content,\n    createdAt: c.createdAt,\n    userId: c.userId,\n    profile: c.profile,\n    likeCount: c.likes.length,\n    userLiked: user ? c.likes.some((l:any) => l.userId === user.id) : false,\n    replies: c.replies.map((r:any) => ({\n      id: r.id,\n      content: r.content,\n      createdAt: r.createdAt,\n      userId: r.userId,\n      profile: r.profile,\n      likeCount: r.likes.length,\n      userLiked: user ? r.likes.some((l:any) => l.userId === user.id) : false,\n      replies: [] as never[],\n    })),\n  }));\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-[#0a0a0a] text-gray-900 dark:text-white transition-colors\">\n\n      <div className=\"mx-auto max-w-4xl px-6 py-12\">\n        {/* Concept header */}\n        <header className=\"mb-12\">\n          <div className=\"flex items-start gap-5 mb-6\">\n            <span className=\"text-6xl leading-none\" aria-hidden=\"true\">\n              {concept.emoji}\n            </span>\n            <div className=\"flex-1 min-w-0 pt-1\">\n              <div className=\"flex flex-wrap items-center gap-2 mb-3\">\n                <Badge\n                  variant=\"outline\"\n                  className=\"border-amber-500/30 dark:border-amber-400/30 text-amber-600 dark:text-amber-400 bg-amber-500/10 dark:bg-amber-400/10\"\n                >\n                  {concept.category}\n                </Badge>\n                <Badge\n                  variant=\"outline\"\n                  className={difficultyBadgeStyles[concept.difficulty]}\n                >\n                  {concept.difficulty}\n                </Badge>\n              </div>\n              <h1 className=\"text-3xl font-extrabold tracking-tight text-gray-900 dark:text-white mb-3\">\n                {concept.title}\n              </h1>\n              <p className=\"text-gray-500 dark:text-zinc-400 text-lg leading-relaxed\">\n                {concept.shortDesc}\n              </p>\n            </div>\n          </div>\n\n          {/* Section nav */}\n          <Separator className=\"mb-4 bg-gray-200 dark:bg-zinc-800\" />\n          <nav className=\"flex flex-wrap gap-1\" aria-label=\"Section navigation\">\n            {concept.sections.map((section, i) => (\n              <Button\n                key={i}\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"text-xs text-gray-400 dark:text-zinc-500 hover:text-amber-600 dark:hover:text-amber-400 hover:bg-amber-500/10 dark:hover:bg-amber-400/10 h-7 px-2\"\n                asChild\n              >\n                <a href={`#section-${i}`}>{section.heading}</a>\n              </Button>\n            ))}\n          </nav>\n        </header>\n\n        {/* Sections */}\n        <article className=\"space-y-12\">\n          {concept.sections.map((section, i) => (\n            <section key={i} id={`section-${i}`} className=\"scroll-mt-20\">\n              <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-4 flex items-center gap-3\">\n                <span className=\"flex h-7 w-7 items-center justify-center rounded-full bg-amber-500/10 dark:bg-amber-400/10 text-xs font-bold text-amber-600 dark:text-amber-400\">\n                  {i + 1}\n                </span>\n                {section.heading}\n              </h2>\n\n              <p className=\"text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                {section.body}\n              </p>\n\n              {section.bullets && (\n                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.bullets.map((bullet, j) => (\n                    <li key={j}>{bullet}</li>\n                  ))}\n                </ul>\n              )}\n\n              {section.code && (\n                <CodeBlock\n                  language={section.code.language}\n                  content={section.code.content}\n                />\n              )}\n\n              {section.screenshots && (\n                <ScreenshotViewer screenshots={section.screenshots} />\n              )}\n\n              {section.table && (\n                <div className=\"mt-4 overflow-x-auto\">\n                  <table className=\"w-full text-sm border border-zinc-700 rounded-lg overflow-hidden\">\n                    <thead>\n                      <tr className=\"bg-zinc-800 text-zinc-300\">\n                        {section.table.headers.map((h, j) => (\n                          <th key={j} className=\"text-left px-4 py-2 font-semibold border-b border-zinc-700\">\n                            {h}\n                          </th>\n                        ))}\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {section.table.rows.map((row, j) => (\n                        <tr key={j} className={j % 2 === 0 ? \"bg-zinc-900\" : \"bg-zinc-800/50\"}>\n                          {row.map((cell, k) => (\n                            <td key={k} className=\"px-4 py-2 text-zinc-300 border-b border-zinc-700/50 font-mono\">\n                              {cell}\n                            </td>\n                          ))}\n                        </tr>\n                      ))}\n                    </tbody>\n                  </table>\n                </div>\n              )}\n            </section>\n          ))}\n        </article>\n\n        {/* Likes */}\n        <div className=\"mt-10 pt-8 border-t border-gray-200 dark:border-zinc-800\">\n          <LikeButton\n            conceptSlug={slug}\n            initialCount={likesCount}\n            initialLiked={!!userLike}\n            userId={user?.id ?? null}\n          />\n        </div>\n\n        {/* Comments */}\n        <CommentsSection\n          conceptSlug={slug}\n          initialComments={comments}\n          userId={user?.id ?? null}\n        />\n\n        {/* References */}\n        {concept.references && concept.references.length > 0 && (\n          <div className=\"mt-12 pt-8 border-t border-gray-200 dark:border-zinc-800\">\n            <h2 className=\"text-base font-semibold text-gray-700 dark:text-zinc-300 mb-3 uppercase tracking-wider text-xs\">\n              Official References\n            </h2>\n            <div className=\"flex flex-col gap-2\">\n              {concept.references.map((ref, i) => (\n                <a\n                  key={i}\n                  href={ref.url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"group flex items-center justify-between rounded-lg border border-gray-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 px-4 py-3 hover:border-amber-400/60 hover:bg-amber-500/5 dark:hover:border-amber-400/60 dark:hover:bg-amber-400/5 transition-all\"\n                >\n                  <div>\n                    <span className=\"text-sm font-medium text-gray-900 dark:text-white group-hover:text-amber-600 dark:group-hover:text-amber-400 transition-colors\">\n                      {ref.label}\n                    </span>\n                    {ref.description && (\n                      <p className=\"text-xs text-gray-500 dark:text-zinc-500 mt-0.5\">{ref.description}</p>\n                    )}\n                  </div>\n                  <ExternalLink className=\"h-3.5 w-3.5 text-gray-400 dark:text-zinc-600 group-hover:text-amber-500 dark:group-hover:text-amber-400 transition-colors shrink-0 ml-4\" />\n                </a>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Related concepts */}\n        {related.length > 0 && (\n          <aside className=\"mt-16 pt-10 border-t border-gray-200 dark:border-zinc-800\">\n            <h2 className=\"text-lg font-bold text-gray-900 dark:text-white mb-5\">\n              More in{' '}\n              <span className=\"text-amber-500 dark:text-amber-400\">{concept.category}</span>\n            </h2>\n            <div className=\"grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-3\">\n              {related.map((c) => (\n                <ConceptCard key={c.slug} concept={c} compact />\n              ))}\n            </div>\n          </aside>\n        )}\n\n        {/* Back to home */}\n        <div className=\"mt-12 pt-8 border-t border-gray-200 dark:border-zinc-800 text-center\">\n          <Button\n            variant=\"outline\"\n            className=\"rounded-full border-gray-300 dark:border-zinc-700 text-gray-500 dark:text-zinc-400 hover:border-amber-500/50 dark:hover:border-amber-400/50 hover:text-amber-600 dark:hover:text-amber-400 bg-transparent\"\n            asChild\n          >\n            <Link href=\"/\">\n              <ChevronLeft className=\"h-4 w-4\" />\n              Back to all concepts\n            </Link>\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
          "numLines": 285,
          "startLine": 1,
          "totalLines": 285
        }
      },
      "tool_use_id": "toolu_01Jz8A3DKSvDLs8wF7yoAQRk"
    }
  },
  {
    "timestamp": "2026-02-28T04:37:50.560Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "src/components/ScreenshotViewer*",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app"
      },
      "tool_response": {
        "filenames": [
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\components\\ScreenshotViewer.tsx"
        ],
        "durationMs": 959,
        "numFiles": 1,
        "truncated": false
      },
      "tool_use_id": "toolu_011X36qZiXqTdJQ6DLrj69bF"
    }
  },
  {
    "timestamp": "2026-02-28T04:37:52.550Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\components\\ScreenshotViewer.tsx"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\components\\ScreenshotViewer.tsx",
          "content": "'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { X } from 'lucide-react';\n\ninterface Screenshot {\n  src: string;\n  alt: string;\n}\n\ninterface Props {\n  screenshots: Screenshot[];\n}\n\nexport default function ScreenshotViewer({ screenshots }: Props) {\n  const [lightbox, setLightbox] = useState<Screenshot | null>(null);\n\n  const close = useCallback(() => setLightbox(null), []);\n\n  useEffect(() => {\n    if (!lightbox) return;\n    const onKey = (e: KeyboardEvent) => { if (e.key === 'Escape') close(); };\n    document.addEventListener('keydown', onKey);\n    return () => document.removeEventListener('keydown', onKey);\n  }, [lightbox, close]);\n\n  return (\n    <>\n      {screenshots.map((shot, i) => (\n        <div key={i} className=\"mt-6\">\n          <div\n            className=\"overflow-hidden rounded-xl border border-zinc-200 dark:border-zinc-700 shadow-sm cursor-zoom-in\"\n            onClick={() => setLightbox(shot)}\n          >\n            {/* eslint-disable-next-line @next/next/no-img-element */}\n            <img src={shot.src} alt={shot.alt} className=\"w-full object-cover\" />\n          </div>\n        </div>\n      ))}\n\n      {lightbox && (\n        <div\n          className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4\"\n          onClick={close}\n        >\n          <button\n            onClick={close}\n            className=\"absolute top-4 right-4 rounded-full bg-white/10 hover:bg-white/20 p-2 text-white transition-colors\"\n            aria-label=\"Close\"\n          >\n            <X className=\"h-5 w-5\" />\n          </button>\n          {/* eslint-disable-next-line @next/next/no-img-element */}\n          <img\n            src={lightbox.src}\n            alt={lightbox.alt}\n            className=\"max-h-[90vh] max-w-[90vw] rounded-xl shadow-2xl object-contain\"\n            onClick={(e) => e.stopPropagation()}\n          />\n        </div>\n      )}\n    </>\n  );\n}\n",
          "numLines": 65,
          "startLine": 1,
          "totalLines": 65
        }
      },
      "tool_use_id": "toolu_01G6WtQ9x96jZ45NsFdVYi2H"
    }
  },
  {
    "timestamp": "2026-02-28T04:38:41.530Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1250,
        "limit": 70
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",",
          "numLines": 70,
          "startLine": 1250,
          "totalLines": 1853
        }
      },
      "tool_use_id": "toolu_0115z42DvCcJohNFUQ32dV2s"
    }
  },
  {
    "timestamp": "2026-02-28T04:38:44.458Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1220,
        "limit": 30
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project",
          "numLines": 30,
          "startLine": 1220,
          "totalLines": 1853
        }
      },
      "tool_use_id": "toolu_01JNzRaR9127dZS6wf292bJx"
    }
  },
  {
    "timestamp": "2026-02-28T04:38:48.244Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "  screenshots?: {\n    src: string;\n    alt: string;\n  }[];",
        "new_string": "  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "  screenshots?: {\n    src: string;\n    alt: string;\n  }[];",
        "newString": "  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 19,
            "oldLines": 6,
            "newStart": 19,
            "newLines": 7,
            "lines": [
              "     src: string;",
              "     alt: string;",
              "   }[];",
              "+  carousel?: boolean;",
              "   table?: {",
              "     headers: string[];",
              "     rows: string[][];"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_019X3NchWWRMYDrELzkGi6XX"
    }
  },
  {
    "timestamp": "2026-02-28T04:39:00.077Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",",
        "new_string": "      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Custom subagents live in your project's `.claude/agents/` directory as markdown files. Claude reads the `description` frontmatter to decide when to invoke them, and the file body becomes the agent's system prompt.\",\n        bullets: [\n          \"Create a `.claude/agents/` directory at your project root if it doesn't exist\",\n          \"Add a new `.md` file ‚Äî the filename becomes the agent's identifier (e.g., `code-reviewer.md`)\",\n          \"Set a `description` in the frontmatter ‚Äî Claude uses this to match tasks to the right agent\",\n          \"Write the system prompt in the file body ‚Äî define the agent's role, constraints, and behavior\",\n          \"Optionally restrict tool access with a `tools` frontmatter field (comma-separated)\",\n          \"Save the file ‚Äî Claude Code picks up new agents automatically, no restart needed\",\n        ],\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",",
        "newString": "      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Custom subagents live in your project's `.claude/agents/` directory as markdown files. Claude reads the `description` frontmatter to decide when to invoke them, and the file body becomes the agent's system prompt.\",\n        bullets: [\n          \"Create a `.claude/agents/` directory at your project root if it doesn't exist\",\n          \"Add a new `.md` file ‚Äî the filename becomes the agent's identifier (e.g., `code-reviewer.md`)\",\n          \"Set a `description` in the frontmatter ‚Äî Claude uses this to match tasks to the right agent\",\n          \"Write the system prompt in the file body ‚Äî define the agent's role, constraints, and behavior\",\n          \"Optionally restrict tool access with a `tools` frontmatter field (comma-separated)\",\n          \"Save the file ‚Äî Claude Code picks up new agents automatically, no restart needed\",\n        ],\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1241,
            "oldLines": 6,
            "newStart": 1241,
            "newLines": 31,
            "lines": [
              "         },",
              "       },",
              "       {",
              "+        heading: \"Creating Your Own Subagent\",",
              "+        body: \"Custom subagents live in your project's `.claude/agents/` directory as markdown files. Claude reads the `description` frontmatter to decide when to invoke them, and the file body becomes the agent's system prompt.\",",
              "+        bullets: [",
              "+          \"Create a `.claude/agents/` directory at your project root if it doesn't exist\",",
              "+          \"Add a new `.md` file ‚Äî the filename becomes the agent's identifier (e.g., `code-reviewer.md`)\",",
              "+          \"Set a `description` in the frontmatter ‚Äî Claude uses this to match tasks to the right agent\",",
              "+          \"Write the system prompt in the file body ‚Äî define the agent's role, constraints, and behavior\",",
              "+          \"Optionally restrict tool access with a `tools` frontmatter field (comma-separated)\",",
              "+          \"Save the file ‚Äî Claude Code picks up new agents automatically, no restart needed\",",
              "+        ],",
              "+        carousel: true,",
              "+        screenshots: [",
              "+          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },",
              "+          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },",
              "+          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },",
              "+          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },",
              "+          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },",
              "+          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },",
              "+          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },",
              "+          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },",
              "+          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },",
              "+          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },",
              "+        ],",
              "+      },",
              "+      {",
              "         heading: \"Parallel Execution\",",
              "         body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",",
              "         code: {"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01Vp4ZYy1MPJbozxnfd3yz5S"
    }
  },
  {
    "timestamp": "2026-02-28T04:39:04.167Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\\page.tsx",
        "old_string": "              {section.screenshots && (\n                <ScreenshotViewer screenshots={section.screenshots} />\n              )}",
        "new_string": "              {section.screenshots && (\n                <ScreenshotViewer screenshots={section.screenshots} carousel={section.carousel} />\n              )}",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\\page.tsx",
        "oldString": "              {section.screenshots && (\n                <ScreenshotViewer screenshots={section.screenshots} />\n              )}",
        "newString": "              {section.screenshots && (\n                <ScreenshotViewer screenshots={section.screenshots} carousel={section.carousel} />\n              )}",
        "originalFile": "import { notFound } from 'next/navigation';\nimport Link from 'next/link';\nimport { concepts, difficultyBadgeStyles } from '@/data/concepts';\nimport ConceptCard from '@/components/ConceptCard';\nimport CodeBlock from '@/components/CodeBlock';\nimport LikeButton from '@/components/LikeButton';\nimport CommentsSection from '@/components/CommentsSection';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Separator } from '@/components/ui/separator';\nimport { ChevronLeft, ExternalLink } from 'lucide-react';\nimport ScreenshotViewer from '@/components/ScreenshotViewer';\nimport { createClient } from '@/lib/supabase/server';\nimport { prisma } from '@/lib/prisma';\n\nexport const dynamic = 'force-dynamic';\n\ntype Params = Promise<{ slug: string }>;\n\nexport function generateStaticParams() {\n  return concepts.map((c) => ({ slug: c.slug }));\n}\n\nexport async function generateMetadata({ params }: { params: Params }) {\n  const { slug } = await params;\n  const concept = concepts.find((c) => c.slug === slug);\n  if (!concept) return {};\n  return {\n    title: `${concept.title} ‚Äî Claude Code Learning Hub`,\n    description: concept.shortDesc,\n  };\n}\n\nexport default async function ConceptPage({ params }: { params: Params }) {\n  const { slug } = await params;\n  const concept = concepts.find((c) => c.slug === slug);\n\n  if (!concept || !concept.released) notFound();\n\n  const related = concepts\n    .filter((c) => c.category === concept.category && c.slug !== concept.slug)\n    .slice(0, 3);\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  const [likesCount, userLike, rawComments] = await Promise.all([\n    prisma.conceptLike.count({ where: { conceptSlug: slug } }),\n    user\n      ? prisma.conceptLike.findUnique({\n          where: { userId_conceptSlug: { userId: user.id, conceptSlug: slug } },\n        })\n      : Promise.resolve(null),\n    prisma.conceptComment.findMany({\n      where: { conceptSlug: slug, parentId: null },\n      include: {\n        profile: { select: { name: true } },\n        likes: { select: { userId: true } },\n        replies: {\n          include: {\n            profile: { select: { name: true } },\n            likes: { select: { userId: true } },\n          },\n          orderBy: { createdAt: 'asc' },\n        },\n      },\n      orderBy: { createdAt: 'asc' },\n    }),\n  ] as const);\n\n  const comments = rawComments.map((c: any) => ({\n    id: c.id,\n    content: c.content,\n    createdAt: c.createdAt,\n    userId: c.userId,\n    profile: c.profile,\n    likeCount: c.likes.length,\n    userLiked: user ? c.likes.some((l:any) => l.userId === user.id) : false,\n    replies: c.replies.map((r:any) => ({\n      id: r.id,\n      content: r.content,\n      createdAt: r.createdAt,\n      userId: r.userId,\n      profile: r.profile,\n      likeCount: r.likes.length,\n      userLiked: user ? r.likes.some((l:any) => l.userId === user.id) : false,\n      replies: [] as never[],\n    })),\n  }));\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-[#0a0a0a] text-gray-900 dark:text-white transition-colors\">\n\n      <div className=\"mx-auto max-w-4xl px-6 py-12\">\n        {/* Concept header */}\n        <header className=\"mb-12\">\n          <div className=\"flex items-start gap-5 mb-6\">\n            <span className=\"text-6xl leading-none\" aria-hidden=\"true\">\n              {concept.emoji}\n            </span>\n            <div className=\"flex-1 min-w-0 pt-1\">\n              <div className=\"flex flex-wrap items-center gap-2 mb-3\">\n                <Badge\n                  variant=\"outline\"\n                  className=\"border-amber-500/30 dark:border-amber-400/30 text-amber-600 dark:text-amber-400 bg-amber-500/10 dark:bg-amber-400/10\"\n                >\n                  {concept.category}\n                </Badge>\n                <Badge\n                  variant=\"outline\"\n                  className={difficultyBadgeStyles[concept.difficulty]}\n                >\n                  {concept.difficulty}\n                </Badge>\n              </div>\n              <h1 className=\"text-3xl font-extrabold tracking-tight text-gray-900 dark:text-white mb-3\">\n                {concept.title}\n              </h1>\n              <p className=\"text-gray-500 dark:text-zinc-400 text-lg leading-relaxed\">\n                {concept.shortDesc}\n              </p>\n            </div>\n          </div>\n\n          {/* Section nav */}\n          <Separator className=\"mb-4 bg-gray-200 dark:bg-zinc-800\" />\n          <nav className=\"flex flex-wrap gap-1\" aria-label=\"Section navigation\">\n            {concept.sections.map((section, i) => (\n              <Button\n                key={i}\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"text-xs text-gray-400 dark:text-zinc-500 hover:text-amber-600 dark:hover:text-amber-400 hover:bg-amber-500/10 dark:hover:bg-amber-400/10 h-7 px-2\"\n                asChild\n              >\n                <a href={`#section-${i}`}>{section.heading}</a>\n              </Button>\n            ))}\n          </nav>\n        </header>\n\n        {/* Sections */}\n        <article className=\"space-y-12\">\n          {concept.sections.map((section, i) => (\n            <section key={i} id={`section-${i}`} className=\"scroll-mt-20\">\n              <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-4 flex items-center gap-3\">\n                <span className=\"flex h-7 w-7 items-center justify-center rounded-full bg-amber-500/10 dark:bg-amber-400/10 text-xs font-bold text-amber-600 dark:text-amber-400\">\n                  {i + 1}\n                </span>\n                {section.heading}\n              </h2>\n\n              <p className=\"text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                {section.body}\n              </p>\n\n              {section.bullets && (\n                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.bullets.map((bullet, j) => (\n                    <li key={j}>{bullet}</li>\n                  ))}\n                </ul>\n              )}\n\n              {section.code && (\n                <CodeBlock\n                  language={section.code.language}\n                  content={section.code.content}\n                />\n              )}\n\n              {section.screenshots && (\n                <ScreenshotViewer screenshots={section.screenshots} />\n              )}\n\n              {section.table && (\n                <div className=\"mt-4 overflow-x-auto\">\n                  <table className=\"w-full text-sm border border-zinc-700 rounded-lg overflow-hidden\">\n                    <thead>\n                      <tr className=\"bg-zinc-800 text-zinc-300\">\n                        {section.table.headers.map((h, j) => (\n                          <th key={j} className=\"text-left px-4 py-2 font-semibold border-b border-zinc-700\">\n                            {h}\n                          </th>\n                        ))}\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {section.table.rows.map((row, j) => (\n                        <tr key={j} className={j % 2 === 0 ? \"bg-zinc-900\" : \"bg-zinc-800/50\"}>\n                          {row.map((cell, k) => (\n                            <td key={k} className=\"px-4 py-2 text-zinc-300 border-b border-zinc-700/50 font-mono\">\n                              {cell}\n                            </td>\n                          ))}\n                        </tr>\n                      ))}\n                    </tbody>\n                  </table>\n                </div>\n              )}\n            </section>\n          ))}\n        </article>\n\n        {/* Likes */}\n        <div className=\"mt-10 pt-8 border-t border-gray-200 dark:border-zinc-800\">\n          <LikeButton\n            conceptSlug={slug}\n            initialCount={likesCount}\n            initialLiked={!!userLike}\n            userId={user?.id ?? null}\n          />\n        </div>\n\n        {/* Comments */}\n        <CommentsSection\n          conceptSlug={slug}\n          initialComments={comments}\n          userId={user?.id ?? null}\n        />\n\n        {/* References */}\n        {concept.references && concept.references.length > 0 && (\n          <div className=\"mt-12 pt-8 border-t border-gray-200 dark:border-zinc-800\">\n            <h2 className=\"text-base font-semibold text-gray-700 dark:text-zinc-300 mb-3 uppercase tracking-wider text-xs\">\n              Official References\n            </h2>\n            <div className=\"flex flex-col gap-2\">\n              {concept.references.map((ref, i) => (\n                <a\n                  key={i}\n                  href={ref.url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"group flex items-center justify-between rounded-lg border border-gray-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 px-4 py-3 hover:border-amber-400/60 hover:bg-amber-500/5 dark:hover:border-amber-400/60 dark:hover:bg-amber-400/5 transition-all\"\n                >\n                  <div>\n                    <span className=\"text-sm font-medium text-gray-900 dark:text-white group-hover:text-amber-600 dark:group-hover:text-amber-400 transition-colors\">\n                      {ref.label}\n                    </span>\n                    {ref.description && (\n                      <p className=\"text-xs text-gray-500 dark:text-zinc-500 mt-0.5\">{ref.description}</p>\n                    )}\n                  </div>\n                  <ExternalLink className=\"h-3.5 w-3.5 text-gray-400 dark:text-zinc-600 group-hover:text-amber-500 dark:group-hover:text-amber-400 transition-colors shrink-0 ml-4\" />\n                </a>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Related concepts */}\n        {related.length > 0 && (\n          <aside className=\"mt-16 pt-10 border-t border-gray-200 dark:border-zinc-800\">\n            <h2 className=\"text-lg font-bold text-gray-900 dark:text-white mb-5\">\n              More in{' '}\n              <span className=\"text-amber-500 dark:text-amber-400\">{concept.category}</span>\n            </h2>\n            <div className=\"grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-3\">\n              {related.map((c) => (\n                <ConceptCard key={c.slug} concept={c} compact />\n              ))}\n            </div>\n          </aside>\n        )}\n\n        {/* Back to home */}\n        <div className=\"mt-12 pt-8 border-t border-gray-200 dark:border-zinc-800 text-center\">\n          <Button\n            variant=\"outline\"\n            className=\"rounded-full border-gray-300 dark:border-zinc-700 text-gray-500 dark:text-zinc-400 hover:border-amber-500/50 dark:hover:border-amber-400/50 hover:text-amber-600 dark:hover:text-amber-400 bg-transparent\"\n            asChild\n          >\n            <Link href=\"/\">\n              <ChevronLeft className=\"h-4 w-4\" />\n              Back to all concepts\n            </Link>\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
        "structuredPatch": [
          {
            "oldStart": 170,
            "oldLines": 7,
            "newStart": 170,
            "newLines": 7,
            "lines": [
              "               )}",
              " ",
              "               {section.screenshots && (",
              "-                <ScreenshotViewer screenshots={section.screenshots} />",
              "+                <ScreenshotViewer screenshots={section.screenshots} carousel={section.carousel} />",
              "               )}",
              " ",
              "               {section.table && ("
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_016euufrMW2N8A7TRt4zpWAo"
    }
  },
  {
    "timestamp": "2026-02-28T04:39:26.501Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Write",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\components\\ScreenshotViewer.tsx",
        "content": "'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { X, ChevronLeft, ChevronRight } from 'lucide-react';\n\ninterface Screenshot {\n  src: string;\n  alt: string;\n}\n\ninterface Props {\n  screenshots: Screenshot[];\n  carousel?: boolean;\n}\n\nexport default function ScreenshotViewer({ screenshots, carousel }: Props) {\n  const [lightboxIndex, setLightboxIndex] = useState<number | null>(null);\n  const [activeIndex, setActiveIndex] = useState(0);\n\n  const closeLightbox = useCallback(() => setLightboxIndex(null), []);\n\n  const prevLightbox = useCallback(() => {\n    setLightboxIndex(i => i !== null ? (i - 1 + screenshots.length) % screenshots.length : null);\n  }, [screenshots.length]);\n\n  const nextLightbox = useCallback(() => {\n    setLightboxIndex(i => i !== null ? (i + 1) % screenshots.length : null);\n  }, [screenshots.length]);\n\n  useEffect(() => {\n    if (lightboxIndex === null) return;\n    const onKey = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') closeLightbox();\n      if (e.key === 'ArrowLeft') prevLightbox();\n      if (e.key === 'ArrowRight') nextLightbox();\n    };\n    document.addEventListener('keydown', onKey);\n    return () => document.removeEventListener('keydown', onKey);\n  }, [lightboxIndex, closeLightbox, prevLightbox, nextLightbox]);\n\n  if (carousel) {\n    return (\n      <>\n        <div className=\"mt-6\">\n          <div className=\"relative overflow-hidden rounded-xl border border-zinc-200 dark:border-zinc-700 shadow-sm\">\n            {/* eslint-disable-next-line @next/next/no-img-element */}\n            <img\n              src={screenshots[activeIndex].src}\n              alt={screenshots[activeIndex].alt}\n              className=\"w-full object-cover cursor-zoom-in\"\n              onClick={() => setLightboxIndex(activeIndex)}\n            />\n\n            {screenshots.length > 1 && (\n              <>\n                <button\n                  onClick={() => setActiveIndex(i => (i - 1 + screenshots.length) % screenshots.length)}\n                  className=\"absolute left-2 top-1/2 -translate-y-1/2 rounded-full bg-black/50 hover:bg-black/70 p-2 text-white transition-colors\"\n                  aria-label=\"Previous\"\n                >\n                  <ChevronLeft className=\"h-5 w-5\" />\n                </button>\n                <button\n                  onClick={() => setActiveIndex(i => (i + 1) % screenshots.length)}\n                  className=\"absolute right-2 top-1/2 -translate-y-1/2 rounded-full bg-black/50 hover:bg-black/70 p-2 text-white transition-colors\"\n                  aria-label=\"Next\"\n                >\n                  <ChevronRight className=\"h-5 w-5\" />\n                </button>\n              </>\n            )}\n          </div>\n\n          <div className=\"mt-2 flex items-center justify-center gap-3\">\n            <span className=\"text-xs text-zinc-500 dark:text-zinc-400\">\n              {activeIndex + 1} / {screenshots.length}\n            </span>\n            <div className=\"flex gap-1\">\n              {screenshots.map((_, i) => (\n                <button\n                  key={i}\n                  onClick={() => setActiveIndex(i)}\n                  className={`h-1.5 rounded-full transition-all ${\n                    i === activeIndex\n                      ? 'w-4 bg-amber-500'\n                      : 'w-1.5 bg-zinc-300 dark:bg-zinc-600 hover:bg-zinc-400 dark:hover:bg-zinc-500'\n                  }`}\n                  aria-label={`Go to slide ${i + 1}`}\n                />\n              ))}\n            </div>\n          </div>\n        </div>\n\n        {lightboxIndex !== null && (\n          <div\n            className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4\"\n            onClick={closeLightbox}\n          >\n            <button\n              onClick={closeLightbox}\n              className=\"absolute top-4 right-4 rounded-full bg-white/10 hover:bg-white/20 p-2 text-white transition-colors\"\n              aria-label=\"Close\"\n            >\n              <X className=\"h-5 w-5\" />\n            </button>\n\n            {screenshots.length > 1 && (\n              <>\n                <button\n                  onClick={(e) => { e.stopPropagation(); prevLightbox(); }}\n                  className=\"absolute left-4 top-1/2 -translate-y-1/2 rounded-full bg-white/10 hover:bg-white/20 p-3 text-white transition-colors\"\n                  aria-label=\"Previous\"\n                >\n                  <ChevronLeft className=\"h-6 w-6\" />\n                </button>\n                <button\n                  onClick={(e) => { e.stopPropagation(); nextLightbox(); }}\n                  className=\"absolute right-4 top-1/2 -translate-y-1/2 rounded-full bg-white/10 hover:bg-white/20 p-3 text-white transition-colors\"\n                  aria-label=\"Next\"\n                >\n                  <ChevronRight className=\"h-6 w-6\" />\n                </button>\n              </>\n            )}\n\n            <div className=\"flex flex-col items-center gap-3\" onClick={(e) => e.stopPropagation()}>\n              {/* eslint-disable-next-line @next/next/no-img-element */}\n              <img\n                src={screenshots[lightboxIndex].src}\n                alt={screenshots[lightboxIndex].alt}\n                className=\"max-h-[85vh] max-w-[85vw] rounded-xl shadow-2xl object-contain\"\n              />\n              <span className=\"text-sm text-white/60\">{lightboxIndex + 1} / {screenshots.length}</span>\n            </div>\n          </div>\n        )}\n      </>\n    );\n  }\n\n  // Default: stacked\n  return (\n    <>\n      {screenshots.map((shot, i) => (\n        <div key={i} className=\"mt-6\">\n          <div\n            className=\"overflow-hidden rounded-xl border border-zinc-200 dark:border-zinc-700 shadow-sm cursor-zoom-in\"\n            onClick={() => setLightboxIndex(i)}\n          >\n            {/* eslint-disable-next-line @next/next/no-img-element */}\n            <img src={shot.src} alt={shot.alt} className=\"w-full object-cover\" />\n          </div>\n        </div>\n      ))}\n\n      {lightboxIndex !== null && (\n        <div\n          className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4\"\n          onClick={closeLightbox}\n        >\n          <button\n            onClick={closeLightbox}\n            className=\"absolute top-4 right-4 rounded-full bg-white/10 hover:bg-white/20 p-2 text-white transition-colors\"\n            aria-label=\"Close\"\n          >\n            <X className=\"h-5 w-5\" />\n          </button>\n          {/* eslint-disable-next-line @next/next/no-img-element */}\n          <img\n            src={screenshots[lightboxIndex].src}\n            alt={screenshots[lightboxIndex].alt}\n            className=\"max-h-[90vh] max-w-[90vw] rounded-xl shadow-2xl object-contain\"\n            onClick={(e) => e.stopPropagation()}\n          />\n        </div>\n      )}\n    </>\n  );\n}\n"
      },
      "tool_response": {
        "type": "update",
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\components\\ScreenshotViewer.tsx",
        "content": "'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { X, ChevronLeft, ChevronRight } from 'lucide-react';\n\ninterface Screenshot {\n  src: string;\n  alt: string;\n}\n\ninterface Props {\n  screenshots: Screenshot[];\n  carousel?: boolean;\n}\n\nexport default function ScreenshotViewer({ screenshots, carousel }: Props) {\n  const [lightboxIndex, setLightboxIndex] = useState<number | null>(null);\n  const [activeIndex, setActiveIndex] = useState(0);\n\n  const closeLightbox = useCallback(() => setLightboxIndex(null), []);\n\n  const prevLightbox = useCallback(() => {\n    setLightboxIndex(i => i !== null ? (i - 1 + screenshots.length) % screenshots.length : null);\n  }, [screenshots.length]);\n\n  const nextLightbox = useCallback(() => {\n    setLightboxIndex(i => i !== null ? (i + 1) % screenshots.length : null);\n  }, [screenshots.length]);\n\n  useEffect(() => {\n    if (lightboxIndex === null) return;\n    const onKey = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') closeLightbox();\n      if (e.key === 'ArrowLeft') prevLightbox();\n      if (e.key === 'ArrowRight') nextLightbox();\n    };\n    document.addEventListener('keydown', onKey);\n    return () => document.removeEventListener('keydown', onKey);\n  }, [lightboxIndex, closeLightbox, prevLightbox, nextLightbox]);\n\n  if (carousel) {\n    return (\n      <>\n        <div className=\"mt-6\">\n          <div className=\"relative overflow-hidden rounded-xl border border-zinc-200 dark:border-zinc-700 shadow-sm\">\n            {/* eslint-disable-next-line @next/next/no-img-element */}\n            <img\n              src={screenshots[activeIndex].src}\n              alt={screenshots[activeIndex].alt}\n              className=\"w-full object-cover cursor-zoom-in\"\n              onClick={() => setLightboxIndex(activeIndex)}\n            />\n\n            {screenshots.length > 1 && (\n              <>\n                <button\n                  onClick={() => setActiveIndex(i => (i - 1 + screenshots.length) % screenshots.length)}\n                  className=\"absolute left-2 top-1/2 -translate-y-1/2 rounded-full bg-black/50 hover:bg-black/70 p-2 text-white transition-colors\"\n                  aria-label=\"Previous\"\n                >\n                  <ChevronLeft className=\"h-5 w-5\" />\n                </button>\n                <button\n                  onClick={() => setActiveIndex(i => (i + 1) % screenshots.length)}\n                  className=\"absolute right-2 top-1/2 -translate-y-1/2 rounded-full bg-black/50 hover:bg-black/70 p-2 text-white transition-colors\"\n                  aria-label=\"Next\"\n                >\n                  <ChevronRight className=\"h-5 w-5\" />\n                </button>\n              </>\n            )}\n          </div>\n\n          <div className=\"mt-2 flex items-center justify-center gap-3\">\n            <span className=\"text-xs text-zinc-500 dark:text-zinc-400\">\n              {activeIndex + 1} / {screenshots.length}\n            </span>\n            <div className=\"flex gap-1\">\n              {screenshots.map((_, i) => (\n                <button\n                  key={i}\n                  onClick={() => setActiveIndex(i)}\n                  className={`h-1.5 rounded-full transition-all ${\n                    i === activeIndex\n                      ? 'w-4 bg-amber-500'\n                      : 'w-1.5 bg-zinc-300 dark:bg-zinc-600 hover:bg-zinc-400 dark:hover:bg-zinc-500'\n                  }`}\n                  aria-label={`Go to slide ${i + 1}`}\n                />\n              ))}\n            </div>\n          </div>\n        </div>\n\n        {lightboxIndex !== null && (\n          <div\n            className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4\"\n            onClick={closeLightbox}\n          >\n            <button\n              onClick={closeLightbox}\n              className=\"absolute top-4 right-4 rounded-full bg-white/10 hover:bg-white/20 p-2 text-white transition-colors\"\n              aria-label=\"Close\"\n            >\n              <X className=\"h-5 w-5\" />\n            </button>\n\n            {screenshots.length > 1 && (\n              <>\n                <button\n                  onClick={(e) => { e.stopPropagation(); prevLightbox(); }}\n                  className=\"absolute left-4 top-1/2 -translate-y-1/2 rounded-full bg-white/10 hover:bg-white/20 p-3 text-white transition-colors\"\n                  aria-label=\"Previous\"\n                >\n                  <ChevronLeft className=\"h-6 w-6\" />\n                </button>\n                <button\n                  onClick={(e) => { e.stopPropagation(); nextLightbox(); }}\n                  className=\"absolute right-4 top-1/2 -translate-y-1/2 rounded-full bg-white/10 hover:bg-white/20 p-3 text-white transition-colors\"\n                  aria-label=\"Next\"\n                >\n                  <ChevronRight className=\"h-6 w-6\" />\n                </button>\n              </>\n            )}\n\n            <div className=\"flex flex-col items-center gap-3\" onClick={(e) => e.stopPropagation()}>\n              {/* eslint-disable-next-line @next/next/no-img-element */}\n              <img\n                src={screenshots[lightboxIndex].src}\n                alt={screenshots[lightboxIndex].alt}\n                className=\"max-h-[85vh] max-w-[85vw] rounded-xl shadow-2xl object-contain\"\n              />\n              <span className=\"text-sm text-white/60\">{lightboxIndex + 1} / {screenshots.length}</span>\n            </div>\n          </div>\n        )}\n      </>\n    );\n  }\n\n  // Default: stacked\n  return (\n    <>\n      {screenshots.map((shot, i) => (\n        <div key={i} className=\"mt-6\">\n          <div\n            className=\"overflow-hidden rounded-xl border border-zinc-200 dark:border-zinc-700 shadow-sm cursor-zoom-in\"\n            onClick={() => setLightboxIndex(i)}\n          >\n            {/* eslint-disable-next-line @next/next/no-img-element */}\n            <img src={shot.src} alt={shot.alt} className=\"w-full object-cover\" />\n          </div>\n        </div>\n      ))}\n\n      {lightboxIndex !== null && (\n        <div\n          className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4\"\n          onClick={closeLightbox}\n        >\n          <button\n            onClick={closeLightbox}\n            className=\"absolute top-4 right-4 rounded-full bg-white/10 hover:bg-white/20 p-2 text-white transition-colors\"\n            aria-label=\"Close\"\n          >\n            <X className=\"h-5 w-5\" />\n          </button>\n          {/* eslint-disable-next-line @next/next/no-img-element */}\n          <img\n            src={screenshots[lightboxIndex].src}\n            alt={screenshots[lightboxIndex].alt}\n            className=\"max-h-[90vh] max-w-[90vw] rounded-xl shadow-2xl object-contain\"\n            onClick={(e) => e.stopPropagation()}\n          />\n        </div>\n      )}\n    </>\n  );\n}\n",
        "structuredPatch": [
          {
            "oldStart": 1,
            "oldLines": 7,
            "newStart": 1,
            "newLines": 7,
            "lines": [
              " 'use client';",
              " ",
              " import { useState, useEffect, useCallback } from 'react';",
              "-import { X } from 'lucide-react';",
              "+import { X, ChevronLeft, ChevronRight } from 'lucide-react';",
              " ",
              " interface Screenshot {",
              "   src: string;"
            ]
          },
          {
            "oldStart": 10,
            "oldLines": 27,
            "newStart": 10,
            "newLines": 143,
            "lines": [
              " ",
              " interface Props {",
              "   screenshots: Screenshot[];",
              "+  carousel?: boolean;",
              " }",
              " ",
              "-export default function ScreenshotViewer({ screenshots }: Props) {",
              "-  const [lightbox, setLightbox] = useState<Screenshot | null>(null);",
              "+export default function ScreenshotViewer({ screenshots, carousel }: Props) {",
              "+  const [lightboxIndex, setLightboxIndex] = useState<number | null>(null);",
              "+  const [activeIndex, setActiveIndex] = useState(0);",
              " ",
              "-  const close = useCallback(() => setLightbox(null), []);",
              "+  const closeLightbox = useCallback(() => setLightboxIndex(null), []);",
              " ",
              "+  const prevLightbox = useCallback(() => {",
              "+    setLightboxIndex(i => i !== null ? (i - 1 + screenshots.length) % screenshots.length : null);",
              "+  }, [screenshots.length]);",
              "+",
              "+  const nextLightbox = useCallback(() => {",
              "+    setLightboxIndex(i => i !== null ? (i + 1) % screenshots.length : null);",
              "+  }, [screenshots.length]);",
              "+",
              "   useEffect(() => {",
              "-    if (!lightbox) return;",
              "-    const onKey = (e: KeyboardEvent) => { if (e.key === 'Escape') close(); };",
              "+    if (lightboxIndex === null) return;",
              "+    const onKey = (e: KeyboardEvent) => {",
              "+      if (e.key === 'Escape') closeLightbox();",
              "+      if (e.key === 'ArrowLeft') prevLightbox();",
              "+      if (e.key === 'ArrowRight') nextLightbox();",
              "+    };",
              "     document.addEventListener('keydown', onKey);",
              "     return () => document.removeEventListener('keydown', onKey);",
              "-  }, [lightbox, close]);",
              "+  }, [lightboxIndex, closeLightbox, prevLightbox, nextLightbox]);",
              " ",
              "+  if (carousel) {",
              "+    return (",
              "+      <>",
              "+        <div className=\"mt-6\">",
              "+          <div className=\"relative overflow-hidden rounded-xl border border-zinc-200 dark:border-zinc-700 shadow-sm\">",
              "+            {/* eslint-disable-next-line @next/next/no-img-element */}",
              "+            <img",
              "+              src={screenshots[activeIndex].src}",
              "+              alt={screenshots[activeIndex].alt}",
              "+              className=\"w-full object-cover cursor-zoom-in\"",
              "+              onClick={() => setLightboxIndex(activeIndex)}",
              "+            />",
              "+",
              "+            {screenshots.length > 1 && (",
              "+              <>",
              "+                <button",
              "+                  onClick={() => setActiveIndex(i => (i - 1 + screenshots.length) % screenshots.length)}",
              "+                  className=\"absolute left-2 top-1/2 -translate-y-1/2 rounded-full bg-black/50 hover:bg-black/70 p-2 text-white transition-colors\"",
              "+                  aria-label=\"Previous\"",
              "+                >",
              "+                  <ChevronLeft className=\"h-5 w-5\" />",
              "+                </button>",
              "+                <button",
              "+                  onClick={() => setActiveIndex(i => (i + 1) % screenshots.length)}",
              "+                  className=\"absolute right-2 top-1/2 -translate-y-1/2 rounded-full bg-black/50 hover:bg-black/70 p-2 text-white transition-colors\"",
              "+                  aria-label=\"Next\"",
              "+                >",
              "+                  <ChevronRight className=\"h-5 w-5\" />",
              "+                </button>",
              "+              </>",
              "+            )}",
              "+          </div>",
              "+",
              "+          <div className=\"mt-2 flex items-center justify-center gap-3\">",
              "+            <span className=\"text-xs text-zinc-500 dark:text-zinc-400\">",
              "+              {activeIndex + 1} / {screenshots.length}",
              "+            </span>",
              "+            <div className=\"flex gap-1\">",
              "+              {screenshots.map((_, i) => (",
              "+                <button",
              "+                  key={i}",
              "+                  onClick={() => setActiveIndex(i)}",
              "+                  className={`h-1.5 rounded-full transition-all ${",
              "+                    i === activeIndex",
              "+                      ? 'w-4 bg-amber-500'",
              "+                      : 'w-1.5 bg-zinc-300 dark:bg-zinc-600 hover:bg-zinc-400 dark:hover:bg-zinc-500'",
              "+                  }`}",
              "+                  aria-label={`Go to slide ${i + 1}`}",
              "+                />",
              "+              ))}",
              "+            </div>",
              "+          </div>",
              "+        </div>",
              "+",
              "+        {lightboxIndex !== null && (",
              "+          <div",
              "+            className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4\"",
              "+            onClick={closeLightbox}",
              "+          >",
              "+            <button",
              "+              onClick={closeLightbox}",
              "+              className=\"absolute top-4 right-4 rounded-full bg-white/10 hover:bg-white/20 p-2 text-white transition-colors\"",
              "+              aria-label=\"Close\"",
              "+            >",
              "+              <X className=\"h-5 w-5\" />",
              "+            </button>",
              "+",
              "+            {screenshots.length > 1 && (",
              "+              <>",
              "+                <button",
              "+                  onClick={(e) => { e.stopPropagation(); prevLightbox(); }}",
              "+                  className=\"absolute left-4 top-1/2 -translate-y-1/2 rounded-full bg-white/10 hover:bg-white/20 p-3 text-white transition-colors\"",
              "+                  aria-label=\"Previous\"",
              "+                >",
              "+                  <ChevronLeft className=\"h-6 w-6\" />",
              "+                </button>",
              "+                <button",
              "+                  onClick={(e) => { e.stopPropagation(); nextLightbox(); }}",
              "+                  className=\"absolute right-4 top-1/2 -translate-y-1/2 rounded-full bg-white/10 hover:bg-white/20 p-3 text-white transition-colors\"",
              "+                  aria-label=\"Next\"",
              "+                >",
              "+                  <ChevronRight className=\"h-6 w-6\" />",
              "+                </button>",
              "+              </>",
              "+            )}",
              "+",
              "+            <div className=\"flex flex-col items-center gap-3\" onClick={(e) => e.stopPropagation()}>",
              "+              {/* eslint-disable-next-line @next/next/no-img-element */}",
              "+              <img",
              "+                src={screenshots[lightboxIndex].src}",
              "+                alt={screenshots[lightboxIndex].alt}",
              "+                className=\"max-h-[85vh] max-w-[85vw] rounded-xl shadow-2xl object-contain\"",
              "+              />",
              "+              <span className=\"text-sm text-white/60\">{lightboxIndex + 1} / {screenshots.length}</span>",
              "+            </div>",
              "+          </div>",
              "+        )}",
              "+      </>",
              "+    );",
              "+  }",
              "+",
              "+  // Default: stacked",
              "   return (",
              "     <>",
              "       {screenshots.map((shot, i) => (",
              "         <div key={i} className=\"mt-6\">",
              "           <div",
              "             className=\"overflow-hidden rounded-xl border border-zinc-200 dark:border-zinc-700 shadow-sm cursor-zoom-in\"",
              "-            onClick={() => setLightbox(shot)}",
              "+            onClick={() => setLightboxIndex(i)}",
              "           >",
              "             {/* eslint-disable-next-line @next/next/no-img-element */}",
              "             <img src={shot.src} alt={shot.alt} className=\"w-full object-cover\" />"
            ]
          },
          {
            "oldStart": 38,
            "oldLines": 13,
            "newStart": 154,
            "newLines": 13,
            "lines": [
              "         </div>",
              "       ))}",
              " ",
              "-      {lightbox && (",
              "+      {lightboxIndex !== null && (",
              "         <div",
              "           className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4\"",
              "-          onClick={close}",
              "+          onClick={closeLightbox}",
              "         >",
              "           <button",
              "-            onClick={close}",
              "+            onClick={closeLightbox}",
              "             className=\"absolute top-4 right-4 rounded-full bg-white/10 hover:bg-white/20 p-2 text-white transition-colors\"",
              "             aria-label=\"Close\"",
              "           >"
            ]
          },
          {
            "oldStart": 52,
            "oldLines": 8,
            "newStart": 168,
            "newLines": 8,
            "lines": [
              "           </button>",
              "           {/* eslint-disable-next-line @next/next/no-img-element */}",
              "           <img",
              "-            src={lightbox.src}",
              "-            alt={lightbox.alt}",
              "+            src={screenshots[lightboxIndex].src}",
              "+            alt={screenshots[lightboxIndex].alt}",
              "             className=\"max-h-[90vh] max-w-[90vw] rounded-xl shadow-2xl object-contain\"",
              "             onClick={(e) => e.stopPropagation()}",
              "           />"
            ]
          }
        ],
        "originalFile": "'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { X } from 'lucide-react';\n\ninterface Screenshot {\n  src: string;\n  alt: string;\n}\n\ninterface Props {\n  screenshots: Screenshot[];\n}\n\nexport default function ScreenshotViewer({ screenshots }: Props) {\n  const [lightbox, setLightbox] = useState<Screenshot | null>(null);\n\n  const close = useCallback(() => setLightbox(null), []);\n\n  useEffect(() => {\n    if (!lightbox) return;\n    const onKey = (e: KeyboardEvent) => { if (e.key === 'Escape') close(); };\n    document.addEventListener('keydown', onKey);\n    return () => document.removeEventListener('keydown', onKey);\n  }, [lightbox, close]);\n\n  return (\n    <>\n      {screenshots.map((shot, i) => (\n        <div key={i} className=\"mt-6\">\n          <div\n            className=\"overflow-hidden rounded-xl border border-zinc-200 dark:border-zinc-700 shadow-sm cursor-zoom-in\"\n            onClick={() => setLightbox(shot)}\n          >\n            {/* eslint-disable-next-line @next/next/no-img-element */}\n            <img src={shot.src} alt={shot.alt} className=\"w-full object-cover\" />\n          </div>\n        </div>\n      ))}\n\n      {lightbox && (\n        <div\n          className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4\"\n          onClick={close}\n        >\n          <button\n            onClick={close}\n            className=\"absolute top-4 right-4 rounded-full bg-white/10 hover:bg-white/20 p-2 text-white transition-colors\"\n            aria-label=\"Close\"\n          >\n            <X className=\"h-5 w-5\" />\n          </button>\n          {/* eslint-disable-next-line @next/next/no-img-element */}\n          <img\n            src={lightbox.src}\n            alt={lightbox.alt}\n            className=\"max-h-[90vh] max-w-[90vw] rounded-xl shadow-2xl object-contain\"\n            onClick={(e) => e.stopPropagation()}\n          />\n        </div>\n      )}\n    </>\n  );\n}\n"
      },
      "tool_use_id": "toolu_01MmMMuNVKVhy7B6ZQKs1uUN"
    }
  },
  {
    "timestamp": "2026-02-28T04:39:32.405Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Here's what changed:\n\n**`src/data/concepts.ts`**\n- Added `carousel?: boolean` to `ConceptSection` interface\n- Inserted new section 3 \"Creating Your Own Subagent\" with 6 bullet point steps and all 10 screenshots wired in carousel mode\n\n**`src/components/ScreenshotViewer.tsx`**\n- Added `carousel` prop ‚Äî when true, shows one image at a time with prev/next arrow buttons, dot indicators, and `X / 10` counter\n- Lightbox in carousel mode also has prev/next navigation and keyboard arrows\n- Existing stacked behavior unchanged for non-carousel sections\n\n**`src/app/(main)/concepts/[slug]/page.tsx:172`**\n- Passes `carousel={section.carousel}` through to `ScreenshotViewer`"
    }
  },
  {
    "timestamp": "2026-02-28T04:39:34.273Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "acb79e1797b0160bf",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-acb79e1797b0160bf.jsonl",
      "agent_type": "",
      "last_assistant_message": "run the dev server and check it"
    }
  },
  {
    "timestamp": "2026-02-28T04:50:45.121Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "write unit tests for this file @src/data/concepts.ts "
    }
  },
  {
    "timestamp": "2026-02-28T04:51:04.748Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\package.json"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\package.json",
          "content": "{\n  \"name\": \"claude-learning-app\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"prisma generate && next build\",\n    \"start\": \"next start\",\n    \"lint\": \"eslint\"\n  },\n  \"dependencies\": {\n    \"@prisma/adapter-pg\": \"^7.4.1\",\n    \"@prisma/client\": \"^7.4.1\",\n    \"@supabase/ssr\": \"^0.8.0\",\n    \"@supabase/supabase-js\": \"^2.97.0\",\n    \"@types/pg\": \"^8.16.0\",\n    \"class-variance-authority\": \"^0.7.1\",\n    \"clsx\": \"^2.1.1\",\n    \"lucide-react\": \"^0.575.0\",\n    \"next\": \"16.1.6\",\n    \"next-themes\": \"^0.4.6\",\n    \"pg\": \"^8.19.0\",\n    \"prisma\": \"^7.4.1\",\n    \"radix-ui\": \"^1.4.3\",\n    \"react\": \"19.2.3\",\n    \"react-dom\": \"19.2.3\",\n    \"sonner\": \"^2.0.7\",\n    \"tailwind-merge\": \"^3.5.0\"\n  },\n  \"devDependencies\": {\n    \"@tailwindcss/postcss\": \"^4\",\n    \"@types/node\": \"^20\",\n    \"@types/react\": \"^19\",\n    \"@types/react-dom\": \"^19\",\n    \"eslint\": \"^9\",\n    \"eslint-config-next\": \"16.1.6\",\n    \"shadcn\": \"^3.8.5\",\n    \"tailwindcss\": \"^4\",\n    \"tw-animate-css\": \"^1.4.0\",\n    \"typescript\": \"^5\"\n  }\n}\n",
          "numLines": 43,
          "startLine": 1,
          "totalLines": 43
        }
      },
      "tool_use_id": "toolu_011m91F8Np5XXjF79eRur7qH"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:05.107Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\tsconfig.json"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\tsconfig.json",
          "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2017\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"react-jsx\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n  \"include\": [\n    \"next-env.d.ts\",\n    \"**/*.ts\",\n    \"**/*.tsx\",\n    \".next/types/**/*.ts\",\n    \".next/dev/types/**/*.ts\",\n    \"**/*.mts\"\n  ],\n  \"exclude\": [\"node_modules\", \"prisma.config.ts\"]\n}\n",
          "numLines": 35,
          "startLine": 1,
          "totalLines": 35
        }
      },
      "tool_use_id": "toolu_01MhYK6niiWCeJsqY3nRkP83"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:10.029Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n       \n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
          "numLines": 1873,
          "startLine": 1,
          "totalLines": 1873
        }
      },
      "tool_use_id": "toolu_01TyEREifuoL2P1HTTLjypNP"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:10.272Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "**/*.config.{ts,js,mjs}",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app"
      },
      "tool_response": {
        "filenames": [
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\eslint.config.mjs",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\postcss.config.mjs",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\next.config.ts",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\fastq\\eslint.config.js",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\reusify\\eslint.config.js",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\node-exports-info\\eslint.config.mjs",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\eslint-plugin-react\\node_modules\\resolve\\eslint.config.mjs",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\es-iterator-helpers\\eslint.config.mjs",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\es-abstract\\eslint.config.mjs",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\diff\\eslint.config.mjs",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\fast-uri\\eslint.config.js",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\deepmerge\\rollup.config.js",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\qs\\eslint.config.mjs",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\@electric-sql\\pglite-socket\\eslint.config.js",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\@electric-sql\\pglite-tools\\eslint.config.js",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\@electric-sql\\pglite-socket\\tsup.config.ts",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\@electric-sql\\pglite-socket\\vitest.config.ts",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\@electric-sql\\pglite-tools\\tsup.config.ts",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\node_modules\\@electric-sql\\pglite-tools\\vitest.config.ts",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\prisma.config.ts"
        ],
        "durationMs": 1135,
        "numFiles": 20,
        "truncated": false
      },
      "tool_use_id": "toolu_014QZQA1twnL85r6NRZpamap"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:17.387Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
        "offset": 1,
        "limit": 400
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
          "content": "     1‚Üíexport type ConceptCategory =\n     2‚Üí  | \"Core CLI\"\n     3‚Üí  | \"Intelligence\"\n     4‚Üí  | \"Memory\"\n     5‚Üí  | \"Automation\"\n     6‚Üí  | \"Integration\";\n     7‚Üí\n     8‚Üíexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n     9‚Üí\n    10‚Üíexport interface ConceptSection {\n    11‚Üí  heading: string;\n    12‚Üí  body: string;\n    13‚Üí  bullets?: string[];\n    14‚Üí  code?: {\n    15‚Üí    language: string;\n    16‚Üí    content: string;\n    17‚Üí  };\n    18‚Üí  screenshots?: {\n    19‚Üí    src: string;\n    20‚Üí    alt: string;\n    21‚Üí  }[];\n    22‚Üí  carousel?: boolean;\n    23‚Üí  table?: {\n    24‚Üí    headers: string[];\n    25‚Üí    rows: string[][];\n    26‚Üí  };\n    27‚Üí}\n    28‚Üí\n    29‚Üíexport interface ConceptReference {\n    30‚Üí  label: string;\n    31‚Üí  url: string;\n    32‚Üí  description?: string;\n    33‚Üí}\n    34‚Üí\n    35‚Üíexport interface Concept {\n    36‚Üí  slug: string;\n    37‚Üí  title: string;\n    38‚Üí  emoji: string;\n    39‚Üí  category: ConceptCategory;\n    40‚Üí  difficulty: Difficulty;\n    41‚Üí  shortDesc: string;\n    42‚Üí  sections: ConceptSection[];\n    43‚Üí  released?: boolean;\n    44‚Üí  releaseDate?: string;\n    45‚Üí  references?: ConceptReference[];\n    46‚Üí}\n    47‚Üí\n    48‚Üíexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n    49‚Üí  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n    50‚Üí  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n    51‚Üí  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n    52‚Üí};\n    53‚Üí\n    54‚Üíexport const ALL_CATEGORIES: ConceptCategory[] = [\n    55‚Üí  \"Core CLI\",\n    56‚Üí  \"Intelligence\",\n    57‚Üí  \"Memory\",\n    58‚Üí  \"Automation\",\n    59‚Üí  \"Integration\",\n    60‚Üí];\n    61‚Üí\n    62‚Üíexport const concepts: Concept[] = [\n    63‚Üí  {\n    64‚Üí    slug: \"getting-started\",\n    65‚Üí    title: \"Getting Started\",\n    66‚Üí    emoji: \"üöÄ\",\n    67‚Üí    category: \"Core CLI\",\n    68‚Üí    difficulty: \"Beginner\",\n    69‚Üí    released: true,\n    70‚Üí    shortDesc:\n    71‚Üí      \"Install Claude Code and run your first AI-powered coding session.\",\n    72‚Üí    sections: [\n    73‚Üí      {\n    74‚Üí        heading: \"Overview\",\n    75‚Üí        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n    76‚Üí        \n    77‚Üí      },\n    78‚Üí      {\n    79‚Üí        heading: \"Installation\",\n    80‚Üí        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n    81‚Üí        code: {\n    82‚Üí          language: \"bash\",\n    83‚Üí          content: `# Install globally\n    84‚Üínpm install -g @anthropic-ai/claude-code\n    85‚Üí\n    86‚Üí# Verify installation\n    87‚Üíclaude --version\n    88‚Üí\n    89‚Üí# Start your first session in a project directory\n    90‚Üícd my-project\n    91‚Üíclaude`,\n    92‚Üí        },\n    93‚Üí        screenshots: [\n    94‚Üí          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n    95‚Üí        ],\n    96‚Üí      },\n    97‚Üí      {\n    98‚Üí        heading: \"How It Works\",\n    99‚Üí        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n   100‚Üí      },\n   101‚Üí      {\n   102‚Üí        heading: \"Your First Session\",\n   103‚Üí        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n   104‚Üí        code: {\n   105‚Üí          language: \"bash\",\n   106‚Üí          content: `# Open your project\n   107‚Üícd my-app\n   108‚Üíclaude\n   109‚Üí\n   110‚Üí# Then type in the interactive session:\n   111‚Üí> Explain what this project does\n   112‚Üí> Fix the TypeScript error in src/auth.ts\n   113‚Üí> Add a dark mode toggle to the header component\n   114‚Üí> Run the tests and fix any failures`,\n   115‚Üí        },\n   116‚Üí        screenshots: [\n   117‚Üí          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n   118‚Üí        ],\n   119‚Üí      },\n   120‚Üí      {\n   121‚Üí        heading: \"Tips\",\n   122‚Üí        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n   123‚Üí      },\n   124‚Üí    ],\n   125‚Üí  },\n   126‚Üí  {\n   127‚Üí    slug: \"claude-md\",\n   128‚Üí    title: \"CLAUDE.md\",\n   129‚Üí    emoji: \"üìÑ\",\n   130‚Üí    category: \"Memory\",\n   131‚Üí    difficulty: \"Intermediate\",\n   132‚Üí    released: true,\n   133‚Üí    shortDesc:\n   134‚Üí      \"Give Claude persistent project-level instructions via a markdown file.\",\n   135‚Üí    sections: [\n   136‚Üí      {\n   137‚Üí        heading: \"The /init Command\",\n   138‚Üí        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n   139‚Üí        code: {\n   140‚Üí          language: \"bash\",\n   141‚Üí          content: `# In a new project terminal:\n   142‚Üí> /init\n   143‚Üí\n   144‚ÜíClaude: I'll analyze your codebase to understand its structure\n   145‚Üí        and create a comprehensive CLAUDE.md file.\n   146‚Üí        Let me start by exploring the repository...\n   147‚Üí\n   148‚Üí# Claude then:\n   149‚Üí# 1. Scans your codebase\n   150‚Üí# 2. Creates a summary\n   151‚Üí# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n   152‚Üí\n   153‚Üí# When prompted to write the file:\n   154‚Üí# Press Enter        ‚Üí approve this write\n   155‚Üí# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n   156‚Üí        },\n   157‚Üí      },\n   158‚Üí      {\n   159‚Üí        heading: \"CLAUDE.md File Locations\",\n   160‚Üí        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n   161‚Üí        code: {\n   162‚Üí          language: \"text\",\n   163‚Üí          content: `CLAUDE.md\n   164‚Üí  ‚Ä¢ Generated by /init\n   165‚Üí  ‚Ä¢ Committed to source control\n   166‚Üí  ‚Ä¢ Shared with all engineers on the team\n   167‚Üí\n   168‚ÜíCLAUDE.local.md (manually created)\n   169‚Üí  ‚Ä¢ NOT committed to source control\n   170‚Üí  ‚Ä¢ Contains personal instructions and customizations\n   171‚Üí  ‚Ä¢ Invisible to other engineers\n   172‚Üí\n   173‚Üí~/.claude/CLAUDE.md\n   174‚Üí  ‚Ä¢ Applies to ALL projects on your machine\n   175‚Üí  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n   176‚Üí  ‚Ä¢ Your personal global defaults`,\n   177‚Üí        },\n   178‚Üí\n   179‚Üí        \n   180‚Üí        screenshots: [\n   181‚Üí          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n   182‚Üí          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n   183‚Üí        ],\n   184‚Üí      },\n   185‚Üí    \n   186‚Üí      {\n   187‚Üí        heading: \"Tips\",\n   188‚Üí        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n   189‚Üí      },\n   190‚Üí    ],\n   191‚Üí  },\n   192‚Üí  {\n   193‚Üí    slug: \"cli-commands\",\n   194‚Üí    title: \"CLI Commands\",\n   195‚Üí    emoji: \"‚å®Ô∏è\",\n   196‚Üí    released: true,\n   197‚Üí    category: \"Core CLI\",\n   198‚Üí    difficulty: \"Beginner\",\n   199‚Üí    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n   200‚Üí    sections: [\n   201‚Üí      {\n   202‚Üí        heading: \"Overview\",\n   203‚Üí        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n   204‚Üí      },\n   205‚Üí      {\n   206‚Üí        heading: \"Launch Flags\",\n   207‚Üí        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n   208‚Üí        code: {\n   209‚Üí          language: \"bash\",\n   210‚Üí          content: `# Start interactive session\n   211‚Üíclaude\n   212‚Üí\n   213‚Üí# One-shot: print a question, get an answer, exit\n   214‚Üíclaude -p \"What does this codebase do?\"\n   215‚Üí\n   216‚Üí# Pipe input to Claude\n   217‚Üícat error.log | claude -p \"Explain this error\"\n   218‚Üí\n   219‚Üí# Select a specific model\n   220‚Üíclaude --model claude-opus-4-6\n   221‚Üí\n   222‚Üí# Resume the most recent session\n   223‚Üíclaude --resume\n   224‚Üí\n   225‚Üí# Continue with a specific session ID\n   226‚Üíclaude --resume <session-id>\n   227‚Üí\n   228‚Üí# Read-only mode (no file writes or bash execution)\n   229‚Üíclaude --read-only`,\n   230‚Üí        },\n   231‚Üí        screenshots: [\n   232‚Üí          {\n   233‚Üí            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n   234‚Üí            alt: \"CLI launch flags in action\",\n   235‚Üí          },\n   236‚Üí        ],\n   237‚Üí      },\n   238‚Üí      {\n   239‚Üí        heading: \"Slash Commands (In-Session)\",\n   240‚Üí        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n   241‚Üí        code: {\n   242‚Üí          language: \"text\",\n   243‚Üí          content: `/help          ‚Äî Show all available slash commands\n   244‚Üí/plan          ‚Äî Enter plan mode for structured task planning\n   245‚Üí/compact       ‚Äî Compress conversation context to free up space\n   246‚Üí/clear         ‚Äî Clear conversation history and start fresh\n   247‚Üí/model         ‚Äî Switch to a different Claude model mid-session\n   248‚Üí/memory        ‚Äî View and manage persistent memory files\n   249‚Üí/review        ‚Äî Review recent changes made by Claude\n   250‚Üí/undo          ‚Äî Undo the last file change\n   251‚Üí/tasks         ‚Äî Show the current task list\n   252‚Üí/fast          ‚Äî Toggle fast mode (optimized for speed)\n   253‚Üí/vim           ‚Äî Toggle vim keybindings`,\n   254‚Üí        },\n   255‚Üí        screenshots: [\n   256‚Üí          {\n   257‚Üí            src: \"/screenshots/cli-commands/Slash.png\",\n   258‚Üí            alt: \"Slash commands in action\",\n   259‚Üí          },\n   260‚Üí        ],\n   261‚Üí      },\n   262‚Üí      {\n   263‚Üí        heading: \"Custom Commands\",\n   264‚Üí        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n   265‚Üí        code: {\n   266‚Üí          language: \"text\",\n   267‚Üí          content: `# Folder structure\n   268‚Üí.claude/\n   269‚Üí  commands/\n   270‚Üí    audit.md        ‚Üí /audit\n   271‚Üí    write_tests.md  ‚Üí /write_tests\n   272‚Üí\n   273‚Üí# Example: audit.md\n   274‚ÜíRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n   275‚Üí\n   276‚Üí# Example: write_tests.md (with arguments)\n   277‚ÜíWrite comprehensive tests for: $ARGUMENTS\n   278‚Üí\n   279‚ÜíTesting conventions:\n   280‚Üí* Use Vitest with React Testing Library\n   281‚Üí* Place test files in a __tests__ directory\n   282‚Üí* Name test files as [filename].test.ts(x)\n   283‚Üí\n   284‚Üí# Invoke with arguments\n   285‚Üí/write_tests the use-auth.ts file in the hooks directory`,\n   286‚Üí        },\n   287‚Üí        screenshots: [\n   288‚Üí          {\n   289‚Üí            src: \"/screenshots/cli-commands/CustomCommand.png\",\n   290‚Üí            alt: \"Custom commands in action\",\n   291‚Üí          },\n   292‚Üí        ],\n   293‚Üí      },\n   294‚Üí      {\n   295‚Üí        heading: \"Output & Scripting\",\n   296‚Üí        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n   297‚Üí        code: {\n   298‚Üí          language: \"bash\",\n   299‚Üí          content: `# Output as JSON for scripting\n   300‚Üíclaude -p \"List all API endpoints\" --output-format json\n   301‚Üí\n   302‚Üí# Stream output as it arrives\n   303‚Üíclaude -p \"Explain this function\" --output-format stream-json\n   304‚Üí\n   305‚Üí# Use in a git hook\n   306‚Üíecho \"Review this diff for security issues:\" | git diff | claude -p`,\n   307‚Üí        },\n   308‚Üí      },\n   309‚Üí      {\n   310‚Üí        heading: \"Tips\",\n   311‚Üí        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n   312‚Üí      },\n   313‚Üí    ],\n   314‚Üí    references: [\n   315‚Üí      {\n   316‚Üí        label: \"CLI Reference\",\n   317‚Üí        url: \"https://code.claude.com/docs/en/cli-reference\",\n   318‚Üí        description: \"Complete reference for all CLI commands and flags.\",\n   319‚Üí      },\n   320‚Üí      {\n   321‚Üí        label: \"Slash Reference\",\n   322‚Üí        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n   323‚Üí        description: \"Complete reference for all Slash commands.\",\n   324‚Üí      },\n   325‚Üí    ],\n   326‚Üí  },\n   327‚Üí  {\n   328‚Üí    slug: \"keyboard-shortcuts\",\n   329‚Üí    title: \"Keyboard Shortcuts\",\n   330‚Üí    emoji: \"‚ö°\",\n   331‚Üí    category: \"Core CLI\",\n   332‚Üí    difficulty: \"Beginner\",\n   333‚Üí    released: true,\n   334‚Üí    shortDesc:\n   335‚Üí      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n   336‚Üí    sections: [\n   337‚Üí      {\n   338‚Üí        heading: \"Overview\",\n   339‚Üí        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n   340‚Üí      },\n   341‚Üí      {\n   342‚Üí        heading: \"Essential Shortcuts\",\n   343‚Üí        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n   344‚Üí        code: {\n   345‚Üí          language: \"text\",\n   346‚Üí          content: `Enter          ‚Äî Submit your message to Claude\n   347‚ÜíShift+Enter    ‚Äî Insert a newline (multi-line input)\n   348‚ÜíCtrl+C         ‚Äî Interrupt Claude while it is running a tool\n   349‚ÜíCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\n   350‚ÜíCtrl+L         ‚Äî Clear the terminal screen (keeps context)\n   351‚ÜíUp/Down Arrow  ‚Äî Navigate through your message history`,\n   352‚Üí        },\n   353‚Üí      },\n   354‚Üí      {\n   355‚Üí        heading: \"Interruption & Control\",\n   356‚Üí        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n   357‚Üí        code: {\n   358‚Üí          language: \"text\",\n   359‚Üí          content: `# Scenario: Claude is running a long build\n   360‚Üí> Build the project and run all tests\n   361‚Üí[Claude starts running: npm run build...]\n   362‚Üí\n   363‚Üí# Press Ctrl+C to interrupt\n   364‚Üí^C\n   365‚ÜíClaude: Interrupted. I was running: npm run build\n   366‚Üí        The build had started but not completed.\n   367‚Üí        What would you like to do?\n   368‚Üí\n   369‚Üí> Just run the unit tests, skip the build`,\n   370‚Üí        },\n   371‚Üí      },\n   372‚Üí      {\n   373‚Üí        heading: \"Multi-line Input\",\n   374‚Üí        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n   375‚Üí        code: {\n   376‚Üí          language: \"text\",\n   377‚Üí          content: `> Please make the following changes:    [Shift+Enter]\n   378‚Üí  1. Add input validation to the login form  [Shift+Enter]\n   379‚Üí  2. Show error messages below each field    [Shift+Enter]\n   380‚Üí  3. Disable the submit button while loading [Enter to submit]`,\n   381‚Üí        },\n   382‚Üí      },\n   383‚Üí      {\n   384‚Üí        heading: \"Vim Mode\",\n   385‚Üí        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n   386‚Üí        code: {\n   387‚Üí          language: \"text\",\n   388‚Üí          content: `# Enable vim mode inside a session\n   389‚Üí/vim\n   390‚Üí\n   391‚Üí# Now the input supports:\n   392‚Üí# Esc      ‚Äî switch to normal mode\n   393‚Üí# i        ‚Äî enter insert mode\n   394‚Üí# v        ‚Äî visual mode for selection\n   395‚Üí# :q       ‚Äî quit (closes session)\n   396‚Üí# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n   397‚Üí        },\n   398‚Üí      },\n   399‚Üí      {\n   400‚Üí        heading: \"Rewinding Conversations\",",
          "numLines": 400,
          "startLine": 1,
          "totalLines": 1878
        }
      },
      "tool_use_id": "toolu_01Kga1CNjNfcY8xTzRjSq4E3"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:24.793Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
        "offset": 400,
        "limit": 400
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
          "content": "   400‚Üí        heading: \"Rewinding Conversations\",\n   401‚Üí        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n   402‚Üí        bullets: [\n   403‚Üí          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n   404‚Üí          \"Remove distracting or irrelevant conversation history\",\n   405‚Üí          \"Keep Claude focused on the current task\",\n   406‚Üí        ],\n   407‚Üí        code: {\n   408‚Üí          language: \"text\",\n   409‚Üí          content: `# Press Escape twice to enter rewind mode\n   410‚ÜíEsc Esc\n   411‚Üí\n   412‚Üí# Claude shows your message history:\n   413‚Üí[1] > /init\n   414‚Üí[2] > Add authentication to the app\n   415‚Üí[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n   416‚Üí[4] > Now add the login form\n   417‚Üí\n   418‚Üí# Select an earlier message to continue from that point\n   419‚Üí# Claude picks up as if the noisy messages never happened`,\n   420‚Üí        },\n   421‚Üí      },\n   422‚Üí      {\n   423‚Üí        heading: \"Interrupting Claude with Escape\",\n   424‚Üí        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n   425‚Üí        code: {\n   426‚Üí          language: \"text\",\n   427‚Üí          content: `# Claude starts going too broad:\n   428‚Üí> Write tests for all the utility functions\n   429‚Üí[Claude: I'll create a comprehensive test suite covering...]\n   430‚Üí\n   431‚Üí# Press Escape to interrupt\n   432‚ÜíEsc\n   433‚ÜíClaude: Interrupted.\n   434‚Üí\n   435‚Üí# Redirect to something narrower:\n   436‚Üí> Just write tests for the formatDate function first`,\n   437‚Üí        },\n   438‚Üí      },\n   439‚Üí      {\n   440‚Üí        heading: \"Tips\",\n   441‚Üí        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n   442‚Üí      },\n   443‚Üí    ],\n   444‚Üí  },\n   445‚Üí  {\n   446‚Üí    slug: \"permission-modes\",\n   447‚Üí    title: \"Permission Modes\",\n   448‚Üí    emoji: \"üîê\",\n   449‚Üí    category: \"Core CLI\",\n   450‚Üí    difficulty: \"Intermediate\",\n   451‚Üí    released: true,\n   452‚Üí    shortDesc:\n   453‚Üí      \"Control what Claude can do automatically vs. what requires your approval.\",\n   454‚Üí    sections: [\n   455‚Üí      {\n   456‚Üí        heading: \"Overview\",\n   457‚Üí        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n   458‚Üí      },\n   459‚Üí      {\n   460‚Üí        heading: \"Default Mode\",\n   461‚Üí        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n   462‚Üí        code: {\n   463‚Üí          language: \"text\",\n   464‚Üí          content: `# Default behavior: Claude asks before writing\n   465‚Üí> Add a README to this project\n   466‚Üí\n   467‚ÜíClaude: I will create README.md with project documentation.\n   468‚Üí        Allow: Write README.md? [y/n/always/never]\n   469‚Üí        > y   ‚Üê you approve this one action\n   470‚Üí\n   471‚Üí# Read operations happen automatically\n   472‚ÜíClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n   473‚Üí        },\n   474‚Üí      },\n   475‚Üí      {\n   476‚Üí        heading: \"Auto-Approve Mode\",\n   477‚Üí        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n   478‚Üí        code: {\n   479‚Üí          language: \"text\",\n   480‚Üí          content: `# When prompted, choose \"always\" to auto-approve a tool type\n   481‚ÜíAllow: Write src/utils.ts? [y/n/always/never]\n   482‚Üí> always    ‚Üê all future Write tool calls auto-approved this session\n   483‚Üí\n   484‚Üí# Or start with auto-permissions flag (for trusted automation)\n   485‚Üíclaude --dangerously-skip-permissions\n   486‚Üí\n   487‚Üí# Or configure in settings.json\n   488‚Üí{\n   489‚Üí  \"permissions\": {\n   490‚Üí    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n   491‚Üí  }\n   492‚Üí}`,\n   493‚Üí        },\n   494‚Üí      },\n   495‚Üí      {\n   496‚Üí        heading: \"Read-Only Mode\",\n   497‚Üí        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n   498‚Üí        code: {\n   499‚Üí          language: \"bash\",\n   500‚Üí          content: `# Start in read-only mode\n   501‚Üíclaude --read-only\n   502‚Üí\n   503‚Üí# Now Claude can only:\n   504‚Üí# - Read files\n   505‚Üí# - Search with Grep/Glob\n   506‚Üí# - Fetch web content\n   507‚Üí# But CANNOT:\n   508‚Üí# - Write or edit files\n   509‚Üí# - Run bash commands\n   510‚Üí# - Execute any destructive action`,\n   511‚Üí        },\n   512‚Üí      },\n   513‚Üí      {\n   514‚Üí        heading: \"Permission Rules\",\n   515‚Üí        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n   516‚Üí        code: {\n   517‚Üí          language: \"json\",\n   518‚Üí          content: `// settings.json ‚Äî fine-grained permission rules\n   519‚Üí{\n   520‚Üí  \"permissions\": {\n   521‚Üí    \"allow\": [\n   522‚Üí      \"Bash(npm run *)\",        // allow all npm run scripts\n   523‚Üí      \"Bash(git status)\",        // allow git status only\n   524‚Üí      \"Write(src/**)\",           // allow writes inside src/\n   525‚Üí      \"Read\"                     // allow all reads\n   526‚Üí    ],\n   527‚Üí    \"deny\": [\n   528‚Üí      \"Bash(rm *)\",              // deny all rm commands\n   529‚Üí      \"Bash(git push *)\"         // deny git push\n   530‚Üí    ]\n   531‚Üí  }\n   532‚Üí}`,\n   533‚Üí        },\n   534‚Üí      },\n   535‚Üí      {\n   536‚Üí        heading: \"Tips\",\n   537‚Üí        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n   538‚Üí      },\n   539‚Üí    ],\n   540‚Üí  },\n   541‚Üí  {\n   542‚Üí    slug: \"settings-json\",\n   543‚Üí    title: \"settings.json vs settings.local.json\",\n   544‚Üí    emoji: \"‚öôÔ∏è\",\n   545‚Üí    category: \"Core CLI\",\n   546‚Üí    difficulty: \"Beginner\",\n   547‚Üí    released: true,\n   548‚Üí    shortDesc:\n   549‚Üí      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n   550‚Üí    sections: [\n   551‚Üí      {\n   552‚Üí        heading: \"Overview\",\n   553‚Üí        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n   554‚Üí      },\n   555‚Üí      {\n   556‚Üí        heading: \"settings.json ‚Äî Shared Project Config\",\n   557‚Üí        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n   558‚Üí        code: {\n   559‚Üí          language: \"json\",\n   560‚Üí          content: `// .claude/settings.json  (committed to git)\n   561‚Üí{\n   562‚Üí  \"permissions\": {\n   563‚Üí    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n   564‚Üí    \"deny\": []\n   565‚Üí  },\n   566‚Üí  \"hooks\": {\n   567‚Üí    \"PostToolUse\": [\n   568‚Üí      {\n   569‚Üí        \"matcher\": \"Write|Edit\",\n   570‚Üí        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n   571‚Üí      }\n   572‚Üí    ]\n   573‚Üí  }\n   574‚Üí}`,\n   575‚Üí        },\n   576‚Üí      },\n   577‚Üí      {\n   578‚Üí        heading: \"settings.local.json ‚Äî Personal Overrides\",\n   579‚Üí        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n   580‚Üí        screenshots: [\n   581‚Üí          {\n   582‚Üí            src: \"/screenshots/Setting.png\",\n   583‚Üí            alt: \"Claude Code settings.local.json personal overrides\",\n   584‚Üí          },\n   585‚Üí        ],\n   586‚Üí        code: {\n   587‚Üí          language: \"json\",\n   588‚Üí          content: `// .claude/settings.local.json  (git-ignored)\n   589‚Üí{\n   590‚Üí  \"permissions\": {\n   591‚Üí    \"allow\": [\n   592‚Üí      \"Bash(npm run *)\",\n   593‚Üí      \"Bash(git *)\",\n   594‚Üí      \"Read\",\n   595‚Üí      \"Write\",\n   596‚Üí      \"Edit\",\n   597‚Üí      \"Bash(npx prisma *)\"\n   598‚Üí    ]\n   599‚Üí  },\n   600‚Üí  \"env\": {\n   601‚Üí    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n   602‚Üí  }\n   603‚Üí}`,\n   604‚Üí        },\n   605‚Üí      },\n   606‚Üí      {\n   607‚Üí        heading: \"Merge Order\",\n   608‚Üí        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n   609‚Üí        code: {\n   610‚Üí          language: \"text\",\n   611‚Üí          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n   612‚Üí  ~/.claude/settings.json\n   613‚Üí\n   614‚Üí    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n   615‚Üí      .claude/settings.json\n   616‚Üí\n   617‚Üí        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n   618‚Üí          .claude/settings.local.json   ‚Üê wins on conflict\n   619‚Üí\n   620‚ÜíExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\n   621‚Üíthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n   622‚Üí        },\n   623‚Üí      },\n   624‚Üí      {\n   625‚Üí        heading: \"What Belongs Where\",\n   626‚Üí        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n   627‚Üí        code: {\n   628‚Üí          language: \"text\",\n   629‚Üí          content: `settings.json (commit)         settings.local.json (don't commit)\n   630‚Üí‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   631‚ÜíShared auto-approve rules      Personal wider permissions\n   632‚ÜíProject lint/format hooks      Personal API keys or tokens\n   633‚ÜíModel preferences for CI       Machine-specific binary paths\n   634‚ÜíCustom slash-command hooks     Dev-only env var overrides`,\n   635‚Üí        },\n   636‚Üí      },\n   637‚Üí      {\n   638‚Üí        heading: \"Tips\",\n   639‚Üí        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n   640‚Üí      },\n   641‚Üí    ],\n   642‚Üí    references: [\n   643‚Üí      {\n   644‚Üí        label: \"Claude Code Settings Docs\",\n   645‚Üí        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n   646‚Üí        description: \"Official reference for all available settings fields.\",\n   647‚Üí      },\n   648‚Üí    ],\n   649‚Üí  },\n   650‚Üí  {\n   651‚Üí    slug: \"plan-vs-think-mode\",\n   652‚Üí    title: \"Plan Mode vs Think Mode\",\n   653‚Üí    emoji: \"üìã\",\n   654‚Üí    category: \"Intelligence\",\n   655‚Üí    difficulty: \"Intermediate\",\n   656‚Üí    released: true,\n   657‚Üí    shortDesc:\n   658‚Üí      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n   659‚Üí    sections: [\n   660‚Üí      {\n   661‚Üí        heading: \"Overview\",\n   662‚Üí        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n   663‚Üí      },\n   664‚Üí      {\n   665‚Üí        heading: \"Entering Plan Mode\",\n   666‚Üí        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n   667‚Üí        code: {\n   668‚Üí          language: \"text\",\n   669‚Üí          content: `# Enter plan mode with slash command\n   670‚Üí> /plan\n   671‚Üí\n   672‚Üí# Or ask explicitly\n   673‚Üí> Before writing any code, plan how you would add authentication to this app.\n   674‚Üí  Think through the architecture, list the files you would change, and identify\n   675‚Üí  any dependencies we might need.\n   676‚Üí\n   677‚Üí# Claude responds with a structured plan:\n   678‚ÜíClaude: Here is my plan for adding authentication:\n   679‚Üí\n   680‚Üí## Approach\n   681‚ÜíUse NextAuth.js with JWT sessions...\n   682‚Üí\n   683‚Üí## Files to Create\n   684‚Üí- src/lib/auth.ts         (auth configuration)\n   685‚Üí- src/app/api/auth/[...nextauth]/route.ts\n   686‚Üí\n   687‚Üí## Files to Modify\n   688‚Üí- src/app/layout.tsx      (wrap with SessionProvider)\n   689‚Üí- src/middleware.ts       (protect routes)\n   690‚Üí\n   691‚Üí## Steps\n   692‚Üí1. Install next-auth\n   693‚Üí2. Configure providers...\n   694‚Üí\n   695‚ÜíShall I proceed with this plan?`,\n   696‚Üí        },\n   697‚Üí      },\n   698‚Üí      {\n   699‚Üí        heading: \"How It Works\",\n   700‚Üí        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n   701‚Üí      },\n   702‚Üí      {\n   703‚Üí        heading: \"When to Use Plan Mode\",\n   704‚Üí        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n   705‚Üí        code: {\n   706‚Üí          language: \"text\",\n   707‚Üí          content: `# Use plan mode for:\n   708‚Üí> Plan how to add dark mode support across the entire app\n   709‚Üí> Plan a database schema refactor for the user table\n   710‚Üí> Plan the migration from REST to GraphQL\n   711‚Üí\n   712‚Üí# Skip plan mode for:\n   713‚Üí> Fix the typo in README.md\n   714‚Üí> Add a console.log to debug this function\n   715‚Üí> Change the button color to blue`,\n   716‚Üí        },\n   717‚Üí      },\n   718‚Üí      {\n   719‚Üí        heading: \"Enabling Planning Mode\",\n   720‚Üí        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n   721‚Üí        code: {\n   722‚Üí          language: \"text\",\n   723‚Üí          content: `# Activate planning mode:\n   724‚ÜíShift + Tab  (press twice from default mode)\n   725‚ÜíShift + Tab  (press once if auto-accepting edits)\n   726‚Üí\n   727‚Üí# Claude enters plan mode and will:\n   728‚Üí# 1. Explore your codebase thoroughly\n   729‚Üí# 2. Write a structured plan to tasks/todo.md\n   730‚Üí# 3. Present the plan for your review\n   731‚Üí# 4. Wait for approval before writing any code\n   732‚Üí\n   733‚Üí> Refactor the authentication system to use JWT\n   734‚Üí[Claude reads 12 files, identifies 4 affected components...]\n   735‚Üí[Claude writes plan ‚Äî awaiting your approval]`,\n   736‚Üí        },\n   737‚Üí        screenshots: [\n   738‚Üí          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n   739‚Üí        ],\n   740‚Üí      },\n   741‚Üí      {\n   742‚Üí        heading: \"Thinking Modes\",\n   743‚Üí        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n   744‚Üí        bullets: [\n   745‚Üí          \"\\\"Think\\\" - Basic reasoning\",\n   746‚Üí          \"\\\"Think more\\\" - Extended reasoning\",\n   747‚Üí          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n   748‚Üí          \"\\\"Think longer\\\" - Extended time reasoning\",\n   749‚Üí          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n   750‚Üí        ],\n   751‚Üí        code: {\n   752‚Üí          language: \"text\",\n   753‚Üí          content: `# Use thinking modes by including them in your prompt:\n   754‚Üí\n   755‚Üí> Think about the best architecture for this feature\n   756‚Üí> Think more about potential edge cases in this logic\n   757‚Üí> Think a lot about how to refactor this without breaking tests\n   758‚Üí> Ultrathink about the security implications of this approach\n   759‚Üí\n   760‚Üí# When to use each:\n   761‚Üí# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n   762‚Üí# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n   763‚Üí# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n   764‚Üí# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n   765‚Üí        },\n   766‚Üí      },\n   767‚Üí      {\n   768‚Üí        heading: \"Tips\",\n   769‚Üí        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n   770‚Üí      },\n   771‚Üí    ],\n   772‚Üí  },\n   773‚Üí  {\n   774‚Üí    slug: \"tool-use\",\n   775‚Üí    title: \"Tool Use\",\n   776‚Üí    emoji: \"üõ†Ô∏è\",\n   777‚Üí    category: \"Intelligence\",\n   778‚Üí    difficulty: \"Intermediate\",\n   779‚Üí    released: true,\n   780‚Üí    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n   781‚Üí    sections: [\n   782‚Üí      {\n   783‚Üí        heading: \"Overview\",\n   784‚Üí        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n   785‚Üí      },\n   786‚Üí      {\n   787‚Üí        heading: \"File System Tools\",\n   788‚Üí        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n   789‚Üí        code: {\n   790‚Üí          language: \"text\",\n   791‚Üí          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\n   792‚ÜíWrite         ‚Äî Create or overwrite a file entirely\n   793‚ÜíEdit          ‚Äî Make exact string replacements in a file\n   794‚ÜíGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\n   795‚ÜíGrep          ‚Äî Search file contents with regex\n   796‚Üí\n   797‚Üí# Example tool calls Claude makes internally:\n   798‚ÜíRead: src/components/Button.tsx\n   799‚ÜíGlob: src/**/*.test.ts",
          "numLines": 400,
          "startLine": 400,
          "totalLines": 1878
        }
      },
      "tool_use_id": "toolu_01GcffC3agZnF7HNMFX8wzyS"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:33.425Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
        "offset": 800,
        "limit": 500
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
          "content": "   800‚ÜíGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\n   801‚ÜíEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n   802‚Üí        },\n   803‚Üí      },\n   804‚Üí      {\n   805‚Üí        heading: \"Execution Tools\",\n   806‚Üí        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n   807‚Üí        code: {\n   808‚Üí          language: \"bash\",\n   809‚Üí          content: `# Claude uses Bash tool for:\n   810‚Üínpm install         # Install dependencies\n   811‚Üínpm run test        # Run tests\n   812‚Üígit status          # Check git state\n   813‚Üígit add . && git commit -m \"...\"  # Commit changes\n   814‚Üíls src/components/  # List files\n   815‚Üícurl https://...    # Fetch URLs`,\n   816‚Üí        },\n   817‚Üí      },\n   818‚Üí      {\n   819‚Üí        heading: \"Intelligence Tools\",\n   820‚Üí        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n   821‚Üí        code: {\n   822‚Üí          language: \"text\",\n   823‚Üí          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\n   824‚ÜíWebSearch     ‚Äî Search the web for current information\n   825‚ÜíWebFetch      ‚Äî Fetch and read a specific URL\n   826‚ÜíTodoWrite     ‚Äî Write structured task checklists\n   827‚ÜíTodoRead      ‚Äî Read the current task list\n   828‚ÜíNotebookEdit  ‚Äî Edit Jupyter notebook cells\n   829‚Üímcp__*        ‚Äî Tools from connected MCP servers`,\n   830‚Üí        },\n   831‚Üí      },\n   832‚Üí      {\n   833‚Üí        heading: \"How Claude Selects Tools\",\n   834‚Üí        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n   835‚Üí      },\n   836‚Üí      {\n   837‚Üí        heading: \"Tips\",\n   838‚Üí        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n   839‚Üí      },\n   840‚Üí    ],\n   841‚Üí  },\n   842‚Üí  {\n   843‚Üí    slug: \"extended-thinking\",\n   844‚Üí    title: \"Extended Thinking\",\n   845‚Üí    emoji: \"üß†\",\n   846‚Üí    category: \"Intelligence\",\n   847‚Üí    difficulty: \"Advanced\",\n   848‚Üí    released: true,\n   849‚Üí    shortDesc:\n   850‚Üí      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n   851‚Üí    sections: [\n   852‚Üí      {\n   853‚Üí        heading: \"Overview\",\n   854‚Üí        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n   855‚Üí      },\n   856‚Üí      {\n   857‚Üí        heading: \"When It Activates\",\n   858‚Üí        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n   859‚Üí        code: {\n   860‚Üí          language: \"text\",\n   861‚Üí          content: `# These prompts tend to trigger extended thinking:\n   862‚Üí> Think carefully about the best architecture for this feature\n   863‚Üí> I need you to deeply analyze the security implications here\n   864‚Üí> What is the most efficient algorithm for this problem?\n   865‚Üí> Think step by step through all the edge cases\n   866‚Üí\n   867‚Üí# Or explicitly enable via API:\n   868‚Üí{\n   869‚Üí  \"thinking\": {\n   870‚Üí    \"type\": \"enabled\",\n   871‚Üí    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n   872‚Üí  }\n   873‚Üí}`,\n   874‚Üí        },\n   875‚Üí      },\n   876‚Üí      {\n   877‚Üí        heading: \"How It Works\",\n   878‚Üí        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n   879‚Üí      },\n   880‚Üí      {\n   881‚Üí        heading: \"Use Cases\",\n   882‚Üí        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n   883‚Üí        code: {\n   884‚Üí          language: \"text\",\n   885‚Üí          content: `# Good use cases:\n   886‚Üí> Think through how to refactor this 500-line function\n   887‚Üí  into maintainable pieces without breaking behavior\n   888‚Üí\n   889‚Üí> Analyze why this async function has a race condition\n   890‚Üí  and design the fix carefully\n   891‚Üí\n   892‚Üí> I need a regex that matches ISO dates but not invalid\n   893‚Üí  dates like Feb 30. Think through all the cases.\n   894‚Üí\n   895‚Üí# Not worth extended thinking:\n   896‚Üí> Add a semicolon to line 42\n   897‚Üí> Rename this variable to camelCase`,\n   898‚Üí        },\n   899‚Üí      },\n   900‚Üí      {\n   901‚Üí        heading: \"Tips\",\n   902‚Üí        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n   903‚Üí      },\n   904‚Üí    ],\n   905‚Üí  },\n   906‚Üí  {\n   907‚Üí    slug: \"auto-memory\",\n   908‚Üí    title: \"Auto Memory\",\n   909‚Üí    emoji: \"üóÇÔ∏è\",\n   910‚Üí    category: \"Memory\",\n   911‚Üí    difficulty: \"Intermediate\",\n   912‚Üí    released: true,\n   913‚Üí    shortDesc:\n   914‚Üí      \"Persist knowledge across sessions with Claude's auto memory system.\",\n   915‚Üí    sections: [\n   916‚Üí      {\n   917‚Üí        heading: \"Overview\",\n   918‚Üí        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n   919‚Üí        screenshots: [\n   920‚Üí          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n   921‚Üí        ],\n   922‚Üí      },\n   923‚Üí      {\n   924‚Üí        heading: \"How Are Memories Stored?\",\n   925‚Üí        body: \"There are three ways memories get written:\",\n   926‚Üí        bullets: [\n   927‚Üí          \"Automatically during the session by Claude\",\n   928‚Üí          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n   929‚Üí          'When triggered by the user ‚Äî \"remember that ___\"',\n   930‚Üí        ],\n   931‚Üí        code: {\n   932‚Üí          language: \"text\",\n   933‚Üí          content: `> Remember that we like files in this project named this way.\n   934‚Üí‚óè Recalled 1 memory, wrote 1 memory`,\n   935‚Üí        },\n   936‚Üí        screenshots: [\n   937‚Üí          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n   938‚Üí        ],\n   939‚Üí      },\n   940‚Üí      {\n   941‚Üí        heading: \"Memory Directory\",\n   942‚Üí        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n   943‚Üí        code: {\n   944‚Üí          language: \"text\",\n   945‚Üí          content: `# Memory directory location:\n   946‚Üí~/.claude/projects/<project-path>/memory/\n   947‚Üí\n   948‚Üí# Files in memory:\n   949‚ÜíMEMORY.md           ‚Üê always loaded (keep under 200 lines)\n   950‚Üídebugging.md        ‚Üê linked from MEMORY.md for details\n   951‚Üípatterns.md         ‚Üê code patterns and conventions\n   952‚Üíarchitecture.md     ‚Üê key architectural decisions`,\n   953‚Üí        },\n   954‚Üí        screenshots: [\n   955‚Üí          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n   956‚Üí        ],\n   957‚Üí      },\n   958‚Üí      {\n   959‚Üí        heading: \"What Gets Saved\",\n   960‚Üí        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n   961‚Üí        code: {\n   962‚Üí          language: \"markdown\",\n   963‚Üí          content: `# Example MEMORY.md content\n   964‚Üí\n   965‚Üí## Project: claude-learning-app\n   966‚ÜíNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\n   967‚ÜísearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n   968‚Üí\n   969‚Üí## User Preferences\n   970‚Üí- User prefers concise responses, no emojis\n   971‚Üí- Always run lint before declaring done\n   972‚Üí- User uses bun, not npm for package management\n   973‚Üí\n   974‚Üí## Key File Paths\n   975‚Üí- Data: src/data/concepts.ts\n   976‚Üí- Components: src/components/\n   977‚Üí- API routes: src/app/api/\n   978‚Üí\n   979‚Üí## Recurring Patterns\n   980‚Üí- Use \"use client\" directive for interactive components\n   981‚Üí- CategoryFilter uses URL search params, not useState`,\n   982‚Üí        },\n   983‚Üí        screenshots: [\n   984‚Üí          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n   985‚Üí        ],\n   986‚Üí      },\n   987‚Üí      {\n   988‚Üí        heading: \"Managing Memory\",\n   989‚Üí        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n   990‚Üí        code: {\n   991‚Üí          language: \"text\",\n   992‚Üí          content: `# Inside a Claude Code session:\n   993‚Üí> /memory                     ‚Üê view current memory\n   994‚Üí> Remember to always use bun instead of npm\n   995‚Üí> Forget the note about the old database schema\n   996‚Üí> Update the architecture memory with the new API structure`,\n   997‚Üí        },\n   998‚Üí        screenshots: [\n   999‚Üí          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n  1000‚Üí        ],\n  1001‚Üí      },\n  1002‚Üí      {\n  1003‚Üí        heading: \"Disabling Auto Memory\",\n  1004‚Üí        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n  1005‚Üí        code: {\n  1006‚Üí          language: \"json\",\n  1007‚Üí          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n  1008‚Üí{ \"autoMemoryEnabled\": false }\n  1009‚Üí\n  1010‚Üí// Disable for a single project ‚Äî .claude/settings.json\n  1011‚Üí{ \"autoMemoryEnabled\": false }`,\n  1012‚Üí        },\n  1013‚Üí      },\n  1014‚Üí      {\n  1015‚Üí        heading: \"Tips\",\n  1016‚Üí        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n  1017‚Üí      }\n  1018‚Üí      \n  1019‚Üí    ],\n  1020‚Üí  },\n  1021‚Üí  {\n  1022‚Üí    slug: \"context-management\",\n  1023‚Üí    title: \"Context Management\",\n  1024‚Üí    emoji: \"üîÑ\",\n  1025‚Üí    category: \"Memory\",\n  1026‚Üí    difficulty: \"Intermediate\",\n  1027‚Üí    released: true,\n  1028‚Üí    shortDesc:\n  1029‚Üí      \"Manage Claude's context window to maintain performance on long sessions.\",\n  1030‚Üí    sections: [\n  1031‚Üí      {\n  1032‚Üí        heading: \"Overview\",\n  1033‚Üí        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n  1034‚Üí      },\n  1035‚Üí      {\n  1036‚Üí        heading: \"Context Limits\",\n  1037‚Üí        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n  1038‚Üí        code: {\n  1039‚Üí          language: \"text\",\n  1040‚Üí          content: `# Claude models and approximate context sizes:\n  1041‚Üíclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\n  1042‚Üíclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\n  1043‚Üíclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n  1044‚Üí\n  1045‚Üí# Context is consumed by:\n  1046‚Üí- Conversation history (every message both ways)\n  1047‚Üí- File contents read by Claude\n  1048‚Üí- Tool call results (bash output, search results)\n  1049‚Üí- System prompts (CLAUDE.md, memory files)`,\n  1050‚Üí        },\n  1051‚Üí      },\n  1052‚Üí      {\n  1053‚Üí        heading: \"The /compact Command\",\n  1054‚Üí        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n  1055‚Üí        code: {\n  1056‚Üí          language: \"text\",\n  1057‚Üí          content: `# Inside a session, when context is getting full:\n  1058‚Üí> /compact\n  1059‚Üí\n  1060‚ÜíClaude: Compacting conversation history...\n  1061‚Üí[Summarizes 50 messages into a brief summary]\n  1062‚ÜíContext freed: ~45,000 tokens\n  1063‚Üí\n  1064‚Üí# You can also compact with a specific focus:\n  1065‚Üí> /compact Focus on the authentication work we did,\n  1066‚Üí  keep the file structure summary`,\n  1067‚Üí        },\n  1068‚Üí        screenshots: [\n  1069‚Üí          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n  1070‚Üí        ],\n  1071‚Üí      },\n  1072‚Üí      {\n  1073‚Üí        heading: \"The /clear Command\",\n  1074‚Üí        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n  1075‚Üí        code: {\n  1076‚Üí          language: \"text\",\n  1077‚Üí          content: `# Wipe the context and start fresh:\n  1078‚Üí> /clear\n  1079‚Üí\n  1080‚Üí# When to use /clear vs /compact:\n  1081‚Üí# /compact ‚Äî keep working on the same task, just compress history\n  1082‚Üí# /clear   ‚Äî done with this task entirely, starting something new\n  1083‚Üí\n  1084‚Üí> /clear\n  1085‚Üí[Conversation context cleared ‚Äî memory files still intact]`,\n  1086‚Üí        },\n  1087‚Üí        screenshots: [\n  1088‚Üí          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n  1089‚Üí        ],\n  1090‚Üí      },\n  1091‚Üí      {\n  1092‚Üí        heading: \"Best Practices\",\n  1093‚Üí        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n  1094‚Üí        code: {\n  1095‚Üí          language: \"text\",\n  1096‚Üí          content: `# Instead of reading a huge file:\n  1097‚Üí> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n  1098‚Üí\n  1099‚Üí# Read only what you need:\n  1100‚Üí> Read lines 100-150 of src/legacy-monolith.ts\n  1101‚Üí> Search for the UserAuthService class definition\n  1102‚Üí> What does the validateToken function do in auth.ts?`,\n  1103‚Üí        },\n  1104‚Üí      },\n  1105‚Üí      {\n  1106‚Üí        heading: \"Tips\",\n  1107‚Üí        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n  1108‚Üí      },\n  1109‚Üí    ],\n  1110‚Üí  },\n  1111‚Üí  {\n  1112‚Üí    slug: \"prompt-caching\",\n  1113‚Üí    title: \"Prompt Caching\",\n  1114‚Üí    emoji: \"‚ö°\",\n  1115‚Üí    category: \"Memory\",\n  1116‚Üí    difficulty: \"Advanced\",\n  1117‚Üí    released: true,\n  1118‚Üí    shortDesc:\n  1119‚Üí      \"Reduce API costs and latency by caching repeated context prefixes.\",\n  1120‚Üí    sections: [\n  1121‚Üí      {\n  1122‚Üí        heading: \"Overview\",\n  1123‚Üí        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n  1124‚Üí      },\n  1125‚Üí      {\n  1126‚Üí        heading: \"How It Works\",\n  1127‚Üí        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n  1128‚Üí        code: {\n  1129‚Üí          language: \"python\",\n  1130‚Üí          content: `import anthropic\n  1131‚Üí\n  1132‚Üíclient = anthropic.Anthropic()\n  1133‚Üí\n  1134‚Üí# Large system prompt that stays constant across many requests\n  1135‚ÜíLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n  1136‚Üí\n  1137‚Üíresponse = client.messages.create(\n  1138‚Üí    model=\"claude-opus-4-6\",\n  1139‚Üí    max_tokens=1024,\n  1140‚Üí    system=[\n  1141‚Üí        {\n  1142‚Üí            \"type\": \"text\",\n  1143‚Üí            \"text\": LARGE_CODEBASE_CONTEXT,\n  1144‚Üí            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n  1145‚Üí        }\n  1146‚Üí    ],\n  1147‚Üí    messages=[\n  1148‚Üí        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n  1149‚Üí    ]\n  1150‚Üí)\n  1151‚Üí\n  1152‚Üí# Usage shows cache performance:\n  1153‚Üíprint(response.usage.cache_creation_input_tokens)  # first request\n  1154‚Üíprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n  1155‚Üí        },\n  1156‚Üí      },\n  1157‚Üí      {\n  1158‚Üí        heading: \"Cache Lifetime\",\n  1159‚Üí        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n  1160‚Üí        code: {\n  1161‚Üí          language: \"python\",\n  1162‚Üí          content: `# Good: stable prefix, variable content comes after cache point\n  1163‚Üímessages = [\n  1164‚Üí    {\n  1165‚Üí        \"type\": \"text\",\n  1166‚Üí        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n  1167‚Üí        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n  1168‚Üí    },\n  1169‚Üí    {\n  1170‚Üí        \"type\": \"text\",\n  1171‚Üí        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n  1172‚Üí    }\n  1173‚Üí]\n  1174‚Üí\n  1175‚Üí# Bad: variable content before the cache point (kills cache hits)\n  1176‚Üímessages = [\n  1177‚Üí    {\n  1178‚Üí        \"type\": \"text\",\n  1179‚Üí        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n  1180‚Üí        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n  1181‚Üí    }\n  1182‚Üí]`,\n  1183‚Üí        },\n  1184‚Üí      },\n  1185‚Üí      {\n  1186‚Üí        heading: \"When to Use\",\n  1187‚Üí        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n  1188‚Üí        code: {\n  1189‚Üí          language: \"text\",\n  1190‚Üí          content: `# Great use cases for prompt caching:\n  1191‚Üí- Chat over a large PDF document (cache the document)\n  1192‚Üí- Codebase-aware coding assistant (cache the full codebase)\n  1193‚Üí- Repeated analysis with same rules (cache the rule set)\n  1194‚Üí- Multi-turn conversations with stable system prompts\n  1195‚Üí\n  1196‚Üí# Cost comparison (approximate):\n  1197‚Üí# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n  1198‚Üí# Cache creation: $0.019 per 1K tokens (25% premium)\n  1199‚Üí# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n  1200‚Üí        },\n  1201‚Üí      },\n  1202‚Üí      {\n  1203‚Üí        heading: \"Tips\",\n  1204‚Üí        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n  1205‚Üí      },\n  1206‚Üí    ],\n  1207‚Üí  },\n  1208‚Üí  {\n  1209‚Üí    slug: \"subagents\",\n  1210‚Üí    title: \"Subagents\",\n  1211‚Üí    emoji: \"ü§ñ\",\n  1212‚Üí    category: \"Automation\",\n  1213‚Üí    difficulty: \"Advanced\",\n  1214‚Üí    released: true,\n  1215‚Üí    shortDesc:\n  1216‚Üí      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n  1217‚Üí    sections: [\n  1218‚Üí      {\n  1219‚Üí        heading: \"Overview\",\n  1220‚Üí        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n  1221‚Üí      },\n  1222‚Üí     \n  1223‚Üí      {\n  1224‚Üí        heading: \"Subagent Types in Claude Code\",\n  1225‚Üí        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n  1226‚Üí        code: {\n  1227‚Üí          language: \"text\",\n  1228‚Üí          content: `# Built-in subagent types:\n  1229‚Üígeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\n  1230‚ÜíExplore          ‚Äî Fast codebase search and analysis\n  1231‚ÜíPlan             ‚Äî Software architecture and implementation planning\n  1232‚Üíclaude-code-guide ‚Äî Claude Code feature documentation Q&A\n  1233‚Üístatusline-setup  ‚Äî Configure Claude Code status line\n  1234‚Üí\n  1235‚Üí# Example: Claude might internally spawn:\n  1236‚ÜíTask(subagent_type=\"Explore\",\n  1237‚Üí     prompt=\"Find all API route handlers in src/app/api/\")\n  1238‚Üí\n  1239‚ÜíTask(subagent_type=\"Plan\",\n  1240‚Üí     prompt=\"Design the authentication system architecture\")`,\n  1241‚Üí        },\n  1242‚Üí      },\n  1243‚Üí      {\n  1244‚Üí        heading: \"Creating Your Own Subagent\",\n  1245‚Üí        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n  1246‚Üí       \n  1247‚Üí        carousel: true,\n  1248‚Üí        screenshots: [\n  1249‚Üí          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n  1250‚Üí          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n  1251‚Üí          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n  1252‚Üí          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n  1253‚Üí          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n  1254‚Üí          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n  1255‚Üí          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n  1256‚Üí          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n  1257‚Üí          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n  1258‚Üí          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n  1259‚Üí           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n  1260‚Üí        ],\n  1261‚Üí      },\n  1262‚Üí      {\n  1263‚Üí        heading: \"Parallel Execution\",\n  1264‚Üí        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n  1265‚Üí        code: {\n  1266‚Üí          language: \"text\",\n  1267‚Üí          content: `# Claude might run these subagents in parallel:\n  1268‚Üí[Subagent 1] Explore: Find all components using useState\n  1269‚Üí[Subagent 2] Explore: Find all API routes in the project\n  1270‚Üí[Subagent 3] Explore: Find all TypeScript errors\n  1271‚Üí\n  1272‚Üí# Background agent (non-blocking):\n  1273‚ÜíTask(run_in_background=True,\n  1274‚Üí     prompt=\"Run all tests and report failures\")\n  1275‚Üí\n  1276‚Üí# Main agent continues other work while subagent runs...\n  1277‚Üí# Gets notified when background agent completes`,\n  1278‚Üí        },\n  1279‚Üí      },\n  1280‚Üí      {\n  1281‚Üí        heading: \"Worktree Isolation\",\n  1282‚Üí        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n  1283‚Üí        code: {\n  1284‚Üí          language: \"text\",\n  1285‚Üí          content: `# Subagent with git worktree isolation:\n  1286‚ÜíTask(\n  1287‚Üí    isolation=\"worktree\",\n  1288‚Üí    prompt=\"Try refactoring the auth module and see if tests pass\"\n  1289‚Üí)\n  1290‚Üí# Claude creates a temporary branch, subagent makes changes\n  1291‚Üí# If changes are good ‚Üí merge; if not ‚Üí discard\n  1292‚Üí# Main working directory stays clean throughout`,\n  1293‚Üí        },\n  1294‚Üí      },\n  1295‚Üí      {\n  1296‚Üí        heading: \"Tips\",\n  1297‚Üí        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n  1298‚Üí      },\n  1299‚Üí    ],",
          "numLines": 500,
          "startLine": 800,
          "totalLines": 1878
        }
      },
      "tool_use_id": "toolu_01C5eFBStvvgKqP4WYhwnFAy"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:41.416Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
        "offset": 1300,
        "limit": 400
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
          "content": "  1300‚Üí  },\n  1301‚Üí  {\n  1302‚Üí    slug: \"hooks\",\n  1303‚Üí    title: \"Hooks System\",\n  1304‚Üí    emoji: \"ü™ù\",\n  1305‚Üí    category: \"Automation\",\n  1306‚Üí    difficulty: \"Advanced\",\n  1307‚Üí    released: true,\n  1308‚Üí    shortDesc:\n  1309‚Üí      \"Run shell commands automatically before or after Claude's tool calls.\",\n  1310‚Üí    sections: [\n  1311‚Üí      {\n  1312‚Üí        heading: \"Overview\",\n  1313‚Üí        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n  1314‚Üí      },\n  1315‚Üí      {\n  1316‚Üí        heading: \"Hooks Configuration\",\n  1317‚Üí        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n  1318‚Üí        bullets: [\n  1319‚Üí          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n  1320‚Üí          \"Project ‚Äî .claude/settings.json (shared with team)\",\n  1321‚Üí          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n  1322‚Üí          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n  1323‚Üí        ],\n  1324‚Üí      },\n  1325‚Üí      {\n  1326‚Üí        heading: \"PreToolUse Hooks\",\n  1327‚Üí        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n  1328‚Üí        bullets: [\n  1329‚Üí          \"Allow the operation to proceed normally\",\n  1330‚Üí          \"Block the tool call and send an error message back to Claude.\",\n  1331‚Üí        ],\n  1332‚Üí        code: {\n  1333‚Üí          language: \"json\",\n  1334‚Üí          content: `// settings.local.json ‚Äî configuring hooks\n  1335‚Üí{\n  1336‚Üí  \"hooks\": {\n  1337‚Üí    PreToolUse\": [\n  1338‚Üí      {\n  1339‚Üí        \"matcher\": \"Read|Grep\",\n  1340‚Üí        \"hooks\": [\n  1341‚Üí          {\n  1342‚Üí            \"type\": \"command\",\n  1343‚Üí            \"command\": \"node ./hooks/read_hook.js\"\n  1344‚Üí          }\n  1345‚Üí        ]\n  1346‚Üí      }\n  1347‚Üí    ],\n  1348‚Üí  }\n  1349‚Üí}`,\n  1350‚Üí        },\n  1351‚Üí        screenshots: [\n  1352‚Üí          {\n  1353‚Üí            src: \"/screenshots/hooks/Prehook.png\",\n  1354‚Üí            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n  1355‚Üí          },\n  1356‚Üí        ],\n  1357‚Üí      },\n  1358‚Üí      {\n  1359‚Üí        heading: \"PostToolUse Hooks\",\n  1360‚Üí        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n  1361‚Üí        bullets: [\n  1362‚Üí          \"Run follow-up operations (like formatting a file that was just edited)\",\n  1363‚Üí          \"Provide additional feedback to Claude about the tool use\",\n  1364‚Üí        ],\n  1365‚Üí        code: {\n  1366‚Üí          language: \"json\",\n  1367‚Üí          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n  1368‚Üí{\n  1369‚Üí  \"hooks\": {\n  1370‚Üí    \"PostToolUse\": [\n  1371‚Üí      {\n  1372‚Üí        \"matcher\": \"Write|Edit|MultiEdit\",\n  1373‚Üí        \"hooks\": [\n  1374‚Üí          {\n  1375‚Üí            \"type\": \"command\",\n  1376‚Üí            \"command\": \"node ./hooks/edit_hook.js\"\n  1377‚Üí          }\n  1378‚Üí        ]\n  1379‚Üí      }\n  1380‚Üí    ]\n  1381‚Üí  }\n  1382‚Üí}`,\n  1383‚Üí        },\n  1384‚Üí        screenshots: [\n  1385‚Üí          {\n  1386‚Üí            src: \"/screenshots/hooks/Posthook.png\",\n  1387‚Üí            alt: \"PostToolUse hook logging an edit operation\",\n  1388‚Üí          },\n  1389‚Üí          {\n  1390‚Üí            src: \"/screenshots/hooks/Posthook Result.png\",\n  1391‚Üí            alt: \"PostToolUse hook logging an edit operation result\",\n  1392‚Üí          },\n  1393‚Üí        ],\n  1394‚Üí      },\n  1395‚Üí      {\n  1396‚Üí        heading: \"Available Tools\",\n  1397‚Üí        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n  1398‚Üí        table: {\n  1399‚Üí          headers: [\"Tool Name\", \"Purpose\"],\n  1400‚Üí          rows: [\n  1401‚Üí            [\"Read\", \"Read a file\"],\n  1402‚Üí            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n  1403‚Üí            [\"Write\", \"Create a file and write to it\"],\n  1404‚Üí            [\"Bash\", \"Execute a command\"],\n  1405‚Üí            [\"Glob\", \"Find files/folders based upon a pattern\"],\n  1406‚Üí            [\"Grep\", \"Search for content\"],\n  1407‚Üí            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n  1408‚Üí            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n  1409‚Üí          ],\n  1410‚Üí        },\n  1411‚Üí      },\n  1412‚Üí      {\n  1413‚Üí        heading: \"Other Hook Types\",\n  1414‚Üí        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n  1415‚Üí        bullets: [\n  1416‚Üí          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n  1417‚Üí          \"Stop - Runs when Claude Code has finished responding\",\n  1418‚Üí          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n  1419‚Üí          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n  1420‚Üí          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n  1421‚Üí          \"SessionStart - Runs when starting or resuming a session\",\n  1422‚Üí          \"SessionEnd - Runs when a session ends\",\n  1423‚Üí        ],\n  1424‚Üí      \n  1425‚Üí      },\n  1426‚Üí      {\n  1427‚Üí        heading: \"Hook Payload Structure\",\n  1428‚Üí        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n  1429‚Üí        bullets: [\n  1430‚Üí          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n  1431‚Üí          \"Notification payloads include a message field describing what triggered the notification\",\n  1432‚Üí          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n  1433‚Üí          \"UserPromptSubmit includes the prompt text the user just submitted\",\n  1434‚Üí          \"PreCompact includes context about the compaction being triggered\",\n  1435‚Üí          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n  1436‚Üí        ],\n  1437‚Üí        code: {\n  1438‚Üí          language: \"js\",\n  1439‚Üí          content: `// session_hook.js\n  1440‚Üí// Discover the payload shape for any hook ‚Äî log everything first\n  1441‚Üí\n  1442‚Üíconst fs = require(\"fs\");\n  1443‚Üí\n  1444‚Üíasync function main() {\n  1445‚Üí  const chunks = [];\n  1446‚Üí  for await (const chunk of process.stdin) chunks.push(chunk);\n  1447‚Üí  const payload = JSON.parse(Buffer.concat(chunks).toString());\n  1448‚Üí\n  1449‚Üí  // Read existing entries, append new one, write back\n  1450‚Üí  const logPath = \"./hooks/payloads.json\";\n  1451‚Üí  let entries = [];\n  1452‚Üí  if (fs.existsSync(logPath)) {\n  1453‚Üí    try {\n  1454‚Üí      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n  1455‚Üí    } catch {\n  1456‚Üí      entries = [];\n  1457‚Üí    }\n  1458‚Üí  }\n  1459‚Üí\n  1460‚Üí  entries.push({ timestamp: new Date().toISOString(), payload });\n  1461‚Üí  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n  1462‚Üí}\n  1463‚Üí\n  1464‚Üímain();\n  1465‚Üí`,\n  1466‚Üí        },\n  1467‚Üí        screenshots: [\n  1468‚Üí          {\n  1469‚Üí            src: \"/screenshots/hooks/Payload.png\",\n  1470‚Üí            alt: \"Sampe payload logged by a hook\",\n  1471‚Üí          },\n  1472‚Üí        \n  1473‚Üí        ],\n  1474‚Üí      },\n  1475‚Üí      {\n  1476‚Üí        heading: \"Tips\",\n  1477‚Üí        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n  1478‚Üí      },\n  1479‚Üí    ],\n  1480‚Üí  },\n  1481‚Üí  {\n  1482‚Üí    slug: \"skills\",\n  1483‚Üí    title: \"Skills System\",\n  1484‚Üí    emoji: \"üéØ\",\n  1485‚Üí    category: \"Automation\",\n  1486‚Üí    difficulty: \"Intermediate\",\n  1487‚Üí    released: false,\n  1488‚Üí    releaseDate: \"2026-03-01\",\n  1489‚Üí    shortDesc:\n  1490‚Üí      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n  1491‚Üí    sections: [\n  1492‚Üí      {\n  1493‚Üí        heading: \"Overview\",\n  1494‚Üí        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n  1495‚Üí      },\n  1496‚Üí      {\n  1497‚Üí        heading: \"Creating a Skill\",\n  1498‚Üí        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n  1499‚Üí        code: {\n  1500‚Üí          language: \"bash\",\n  1501‚Üí          content: `# Create a project-specific skill:\n  1502‚Üímkdir -p .claude/skills\n  1503‚Üí\n  1504‚Üí# Create a skill file:\n  1505‚Üícat > .claude/skills/commit.md << 'EOF'\n  1506‚ÜíCreate a git commit following these steps:\n  1507‚Üí\n  1508‚Üí1. Run \\`git status\\` to see all changes\n  1509‚Üí2. Run \\`git diff\\` to review what changed\n  1510‚Üí3. Write a commit message in this format:\n  1511‚Üí   - First line: imperative mood, under 72 chars\n  1512‚Üí   - Body: explain WHY not WHAT\n  1513‚Üí   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n  1514‚Üí4. Stage appropriate files (never .env or secrets)\n  1515‚Üí5. Commit and verify with git status\n  1516‚ÜíEOF\n  1517‚Üí\n  1518‚Üí# Now use it:\n  1519‚Üíclaude\n  1520‚Üí> /commit`,\n  1521‚Üí        },\n  1522‚Üí      },\n  1523‚Üí      {\n  1524‚Üí        heading: \"Using Skills\",\n  1525‚Üí        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n  1526‚Üí        code: {\n  1527‚Üí          language: \"text\",\n  1528‚Üí          content: `# Invoke built-in and custom skills:\n  1529‚Üí/commit              ‚Üê run your commit skill\n  1530‚Üí/review-pr 123       ‚Üê review PR #123\n  1531‚Üí/deploy staging      ‚Üê deploy to staging environment\n  1532‚Üí/test auth           ‚Üê run auth-related tests\n  1533‚Üí\n  1534‚Üí# Skills can receive arguments via $ARGUMENTS:\n  1535‚Üí# In your skill file, use $ARGUMENTS to reference them\n  1536‚Üí# Example skill content:\n  1537‚Üí\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n  1538‚Üí        },\n  1539‚Üí      },\n  1540‚Üí      {\n  1541‚Üí        heading: \"Skill File Structure\",\n  1542‚Üí        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n  1543‚Üí        code: {\n  1544‚Üí          language: \"markdown\",\n  1545‚Üí          content: `# .claude/skills/review-pr.md\n  1546‚Üí\n  1547‚ÜíReview the pull request #$ARGUMENTS.\n  1548‚Üí\n  1549‚ÜíSteps:\n  1550‚Üí1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n  1551‚Üí2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n  1552‚Üí3. Analyze for:\n  1553‚Üí   - Security vulnerabilities (OWASP Top 10)\n  1554‚Üí   - Performance issues\n  1555‚Üí   - Missing error handling\n  1556‚Üí   - TypeScript type safety\n  1557‚Üí   - Test coverage gaps\n  1558‚Üí\n  1559‚ÜíOutput a structured review with:\n  1560‚Üí- Summary (1 paragraph)\n  1561‚Üí- Issues Found (severity: critical/major/minor)\n  1562‚Üí- Suggested Improvements\n  1563‚Üí- Overall assessment (approve/request changes)`,\n  1564‚Üí        },\n  1565‚Üí      },\n  1566‚Üí      {\n  1567‚Üí        heading: \"Tips\",\n  1568‚Üí        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n  1569‚Üí      },\n  1570‚Üí    ],\n  1571‚Üí  },\n  1572‚Üí  {\n  1573‚Üí    slug: \"worktrees\",\n  1574‚Üí    title: \"Worktrees\",\n  1575‚Üí    emoji: \"üå≥\",\n  1576‚Üí    category: \"Automation\",\n  1577‚Üí    difficulty: \"Advanced\",\n  1578‚Üí    released: false,\n  1579‚Üí    releaseDate: \"2026-03-01\",\n  1580‚Üí    shortDesc:\n  1581‚Üí      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n  1582‚Üí    sections: [\n  1583‚Üí      {\n  1584‚Üí        heading: \"Overview\",\n  1585‚Üí        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n  1586‚Üí      },\n  1587‚Üí      {\n  1588‚Üí        heading: \"What Are Worktrees?\",\n  1589‚Üí        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n  1590‚Üí        code: {\n  1591‚Üí          language: \"bash\",\n  1592‚Üí          content: `# Git worktrees basics:\n  1593‚Üígit worktree list                   # show all worktrees\n  1594‚Üígit worktree add ../feature-branch feature-branch  # add worktree\n  1595‚Üígit worktree remove ../feature-branch              # remove worktree\n  1596‚Üí\n  1597‚Üí# Claude Code creates them automatically in:\n  1598‚Üí.claude/worktrees/<name>/\n  1599‚Üí\n  1600‚Üí# Each worktree is a full checkout:\n  1601‚Üí.claude/worktrees/\n  1602‚Üí‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n  1603‚Üí‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n  1604‚Üí‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n  1605‚Üí    ‚îî‚îÄ‚îÄ [another full project copy]`,\n  1606‚Üí        },\n  1607‚Üí      },\n  1608‚Üí      {\n  1609‚Üí        heading: \"Using Worktrees in Claude Code\",\n  1610‚Üí        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n  1611‚Üí        code: {\n  1612‚Üí          language: \"text\",\n  1613‚Üí          content: `# Inside Claude Code session:\n  1614‚Üí> /worktree my-experiment\n  1615‚Üí\n  1616‚Üí[Claude creates a new worktree branch: claude/my-experiment]\n  1617‚Üí[Session working directory switches to .claude/worktrees/my-experiment/]\n  1618‚Üí\n  1619‚Üí> Now try refactoring the authentication module and see if all tests pass\n  1620‚Üí\n  1621‚Üí[Claude makes changes only in the worktree branch]\n  1622‚Üí[Main branch and working directory are untouched]\n  1623‚Üí\n  1624‚Üí# When done:\n  1625‚Üí> The refactoring looks good, merge it into main\n  1626‚Üí[Claude merges the worktree branch back]\n  1627‚Üí\n  1628‚Üí# Or discard:\n  1629‚Üí> Actually, let's abandon this approach\n  1630‚Üí[Worktree is removed, no changes to main branch]`,\n  1631‚Üí        },\n  1632‚Üí      },\n  1633‚Üí      {\n  1634‚Üí        heading: \"Worktree Isolation for Subagents\",\n  1635‚Üí        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n  1636‚Üí        code: {\n  1637‚Üí          language: \"text\",\n  1638‚Üí          content: `# In Claude Code, subagents with worktree isolation:\n  1639‚ÜíTask(\n  1640‚Üí    isolation=\"worktree\",\n  1641‚Üí    prompt=\"Try converting all class components to hooks and verify tests pass\"\n  1642‚Üí)\n  1643‚Üí\n  1644‚Üí# What happens:\n  1645‚Üí# 1. Claude creates .claude/worktrees/<random-name>/\n  1646‚Üí# 2. Subagent checks out a new branch there\n  1647‚Üí# 3. Subagent makes all changes in isolation\n  1648‚Üí# 4. If tests pass ‚Üí report success, offer to merge\n  1649‚Üí# 5. If tests fail ‚Üí report failure, discard worktree\n  1650‚Üí# 6. Main working directory untouched throughout`,\n  1651‚Üí        },\n  1652‚Üí      },\n  1653‚Üí      {\n  1654‚Üí        heading: \"Tips\",\n  1655‚Üí        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n  1656‚Üí      },\n  1657‚Üí    ],\n  1658‚Üí  },\n  1659‚Üí  {\n  1660‚Üí    slug: \"mcp\",\n  1661‚Üí    title: \"MCP (Model Context Protocol)\",\n  1662‚Üí    emoji: \"üîå\",\n  1663‚Üí    category: \"Integration\",\n  1664‚Üí    difficulty: \"Advanced\",\n  1665‚Üí    released: false,\n  1666‚Üí    releaseDate: \"2026-03-01\",\n  1667‚Üí    shortDesc:\n  1668‚Üí      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n  1669‚Üí    sections: [\n  1670‚Üí      {\n  1671‚Üí        heading: \"Overview\",\n  1672‚Üí        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n  1673‚Üí      },\n  1674‚Üí      {\n  1675‚Üí        heading: \"MCP Architecture\",\n  1676‚Üí        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n  1677‚Üí        code: {\n  1678‚Üí          language: \"text\",\n  1679‚Üí          content: `MCP Architecture:\n  1680‚Üí\n  1681‚Üí‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n  1682‚Üí‚îÇ              Claude Code                ‚îÇ\n  1683‚Üí‚îÇ  (MCP Client)                           ‚îÇ\n  1684‚Üí‚îÇ  - Discovers tools from servers         ‚îÇ\n  1685‚Üí‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n  1686‚Üí‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n  1687‚Üí             ‚îÇ stdio / HTTP+SSE\n  1688‚Üí    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n  1689‚Üí    ‚îÇ          MCP Servers          ‚îÇ\n  1690‚Üí    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n  1691‚Üí    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n  1692‚Üí    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n  1693‚Üí    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n  1694‚Üí    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n  1695‚Üí    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n  1696‚Üí    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n  1697‚Üí    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n  1698‚Üí        },\n  1699‚Üí      },",
          "numLines": 400,
          "startLine": 1300,
          "totalLines": 1878
        }
      },
      "tool_use_id": "toolu_01NrzTAS6W2uCnDbUP4d5uor"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:49.650Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
        "offset": 1698,
        "limit": 300
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\tool-results\\toolu_01TyEREifuoL2P1HTTLjypNP.txt",
          "content": "  1698‚Üí        },\n  1699‚Üí      },\n  1700‚Üí      {\n  1701‚Üí        heading: \"Configuring MCP Servers\",\n  1702‚Üí        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n  1703‚Üí        code: {\n  1704‚Üí          language: \"json\",\n  1705‚Üí          content: `// .claude/settings.json ‚Äî MCP server configuration\n  1706‚Üí{\n  1707‚Üí  \"mcpServers\": {\n  1708‚Üí    \"filesystem\": {\n  1709‚Üí      \"command\": \"npx\",\n  1710‚Üí      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n  1711‚Üí    },\n  1712‚Üí    \"github\": {\n  1713‚Üí      \"command\": \"npx\",\n  1714‚Üí      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n  1715‚Üí      \"env\": {\n  1716‚Üí        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n  1717‚Üí      }\n  1718‚Üí    },\n  1719‚Üí    \"postgres\": {\n  1720‚Üí      \"command\": \"npx\",\n  1721‚Üí      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n  1722‚Üí    }\n  1723‚Üí  }\n  1724‚Üí}`,\n  1725‚Üí        },\n  1726‚Üí      },\n  1727‚Üí      {\n  1728‚Üí        heading: \"Writing an MCP Server\",\n  1729‚Üí        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n  1730‚Üí        code: {\n  1731‚Üí          language: \"typescript\",\n  1732‚Üí          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\n  1733‚Üíimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n  1734‚Üíimport { z } from \"zod\";\n  1735‚Üí\n  1736‚Üíconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n  1737‚Üí\n  1738‚Üí// Register a tool Claude can call\n  1739‚Üíserver.tool(\n  1740‚Üí  \"query_database\",\n  1741‚Üí  \"Run a read-only SQL query against the production DB\",\n  1742‚Üí  {\n  1743‚Üí    query: z.string().describe(\"The SQL SELECT query to run\"),\n  1744‚Üí  },\n  1745‚Üí  async ({ query }) => {\n  1746‚Üí    const result = await db.execute(query);\n  1747‚Üí    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  1748‚Üí  }\n  1749‚Üí);\n  1750‚Üí\n  1751‚Üí// Start the server\n  1752‚Üíconst transport = new StdioServerTransport();\n  1753‚Üíawait server.connect(transport);`,\n  1754‚Üí        },\n  1755‚Üí      },\n  1756‚Üí      {\n  1757‚Üí        heading: \"Tips\",\n  1758‚Üí        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n  1759‚Üí      },\n  1760‚Üí    ],\n  1761‚Üí  },\n  1762‚Üí  {\n  1763‚Üí    slug: \"settings\",\n  1764‚Üí    title: \"Settings & Configuration\",\n  1765‚Üí    emoji: \"‚öôÔ∏è\",\n  1766‚Üí    category: \"Integration\",\n  1767‚Üí    difficulty: \"Intermediate\",\n  1768‚Üí    released: false,\n  1769‚Üí    releaseDate: \"2026-03-01\",\n  1770‚Üí    shortDesc:\n  1771‚Üí      \"Configure Claude Code behavior through settings files at user and project level.\",\n  1772‚Üí    sections: [\n  1773‚Üí      {\n  1774‚Üí        heading: \"Overview\",\n  1775‚Üí        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n  1776‚Üí      },\n  1777‚Üí      {\n  1778‚Üí        heading: \"Settings File Locations\",\n  1779‚Üí        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n  1780‚Üí        code: {\n  1781‚Üí          language: \"text\",\n  1782‚Üí          content: `# User-level settings (applies to all projects):\n  1783‚Üí~/.claude/settings.json\n  1784‚Üí\n  1785‚Üí# Project-level settings (applies to this project only):\n  1786‚Üí.claude/settings.json\n  1787‚Üí\n  1788‚Üí# Order of precedence (highest wins):\n  1789‚Üí1. Project settings (.claude/settings.json)\n  1790‚Üí2. User settings (~/.claude/settings.json)\n  1791‚Üí3. Default Claude Code behavior\n  1792‚Üí\n  1793‚Üí# The .claude/ directory also contains:\n  1794‚Üí.claude/\n  1795‚Üí‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n  1796‚Üí‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n  1797‚Üí‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n  1798‚Üí‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n  1799‚Üí        },\n  1800‚Üí      },\n  1801‚Üí      {\n  1802‚Üí        heading: \"Key Settings\",\n  1803‚Üí        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n  1804‚Üí        code: {\n  1805‚Üí          language: \"json\",\n  1806‚Üí          content: `// Complete settings.json example\n  1807‚Üí{\n  1808‚Üí  // Default model for this project\n  1809‚Üí  \"model\": \"claude-sonnet-4-6\",\n  1810‚Üí\n  1811‚Üí  // Permission rules\n  1812‚Üí  \"permissions\": {\n  1813‚Üí    \"allow\": [\n  1814‚Üí      \"Bash(npm run *)\",\n  1815‚Üí      \"Bash(git status)\",\n  1816‚Üí      \"Bash(git diff)\",\n  1817‚Üí      \"Write(src/**)\",\n  1818‚Üí      \"Read\"\n  1819‚Üí    ],\n  1820‚Üí    \"deny\": [\n  1821‚Üí      \"Bash(rm -rf *)\",\n  1822‚Üí      \"Bash(git push --force *)\"\n  1823‚Üí    ]\n  1824‚Üí  },\n  1825‚Üí\n  1826‚Üí  // MCP servers\n  1827‚Üí  \"mcpServers\": {\n  1828‚Üí    \"github\": {\n  1829‚Üí      \"command\": \"npx\",\n  1830‚Üí      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n  1831‚Üí      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n  1832‚Üí    }\n  1833‚Üí  },\n  1834‚Üí\n  1835‚Üí  // Hooks\n  1836‚Üí  \"hooks\": {\n  1837‚Üí    \"PostToolUse\": [\n  1838‚Üí      {\n  1839‚Üí        \"matcher\": \"Write|Edit\",\n  1840‚Üí        \"hooks\": [{\n  1841‚Üí          \"type\": \"command\",\n  1842‚Üí          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n  1843‚Üí        }]\n  1844‚Üí      }\n  1845‚Üí    ]\n  1846‚Üí  }\n  1847‚Üí}`,\n  1848‚Üí        },\n  1849‚Üí      },\n  1850‚Üí      {\n  1851‚Üí        heading: \"Environment Variables\",\n  1852‚Üí        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n  1853‚Üí        code: {\n  1854‚Üí          language: \"bash\",\n  1855‚Üí          content: `# Core environment variables:\n  1856‚ÜíANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\n  1857‚ÜíCLAUDE_MODEL=claude-opus-4-6        # Override default model\n  1858‚ÜíCLAUDE_MAX_TOKENS=8192              # Override max response tokens\n  1859‚ÜíANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n  1860‚Üí\n  1861‚Üí# Non-interactive / CI usage:\n  1862‚Üíexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\n  1863‚Üíclaude -p \"Review this code for security issues\" < code.ts`,\n  1864‚Üí        },\n  1865‚Üí      },\n  1866‚Üí      {\n  1867‚Üí        heading: \"Tips\",\n  1868‚Üí        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n  1869‚Üí      },\n  1870‚Üí    ],\n  1871‚Üí  },\n  1872‚Üí];\n  1873‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "numLines": 181,
          "startLine": 1698,
          "totalLines": 1878
        }
      },
      "tool_use_id": "toolu_01Pi4jr5CSPV9KD3ecfYaGnX"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:56.382Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "**/*.test.{ts,tsx}",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src"
      },
      "tool_response": {
        "filenames": [],
        "durationMs": 942,
        "numFiles": 0,
        "truncated": false
      },
      "tool_use_id": "toolu_01UBfQpPWzpsiYYzn6ywaY8w"
    }
  },
  {
    "timestamp": "2026-02-28T04:51:57.800Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "cd \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\" && npm list jest vitest 2>/dev/null | head -20",
        "description": "Check if jest or vitest is installed"
      },
      "tool_response": {
        "stdout": "claude-learning-app@0.1.0 C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\n‚îî‚îÄ‚îÄ (empty)",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01JM6xpdRur1KiMgC9TV5Hmh"
    }
  },
  {
    "timestamp": "2026-02-28T04:52:15.372Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Bash",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T04:53:34.640Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "cd \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\" && npm install --save-dev vitest 2>&1 | tail -10",
        "timeout": 60000,
        "description": "Install vitest as a dev dependency"
      },
      "tool_response": {
        "stdout": "8 moderate severity vulnerabilities\n\nTo address issues that do not require attention, run:\n  npm audit fix\n\nTo address all issues (including breaking changes), run:\n  npm audit fix --force\n\nRun `npm audit` for details.",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_014fZt2AFoTsPCwepgc2fiMa"
    }
  },
  {
    "timestamp": "2026-02-28T04:53:38.730Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "cd \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\" && npm list vitest 2>/dev/null | head -5",
        "description": "Verify vitest installed"
      },
      "tool_response": {
        "stdout": "claude-learning-app@0.1.0 C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\n‚îî‚îÄ‚îÄ vitest@4.0.18",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01Ri6avTsvgz7BaGvzHMx6Ea"
    }
  },
  {
    "timestamp": "2026-02-28T04:53:45.219Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "cd \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\" && npx vitest --version 2>&1",
        "description": "Verify vitest CLI works"
      },
      "tool_response": {
        "stdout": "vitest/4.0.18 win32-x64 node-v22.16.0",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01APqrNuRb2r2nUKvdVafWGB"
    }
  },
  {
    "timestamp": "2026-02-28T04:54:25.502Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Write",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.test.ts",
        "content": "import { describe, it, expect } from \"vitest\";\nimport {\n  difficultyBadgeStyles,\n  ALL_CATEGORIES,\n  concepts,\n} from \"../src/data/concepts\";\nimport type { Difficulty, ConceptCategory } from \"../src/data/concepts\";\n\n// ---------------------------------------------------------------------------\n// difficultyBadgeStyles\n// ---------------------------------------------------------------------------\n\ndescribe(\"difficultyBadgeStyles\", () => {\n  const validDifficulties: Difficulty[] = [\"Beginner\", \"Intermediate\", \"Advanced\"];\n\n  it(\"contains an entry for every valid difficulty\", () => {\n    for (const d of validDifficulties) {\n      expect(difficultyBadgeStyles).toHaveProperty(d);\n    }\n  });\n\n  it(\"has exactly 3 keys ‚Äî no extra or missing difficulties\", () => {\n    expect(Object.keys(difficultyBadgeStyles)).toHaveLength(3);\n  });\n\n  it.each(validDifficulties)(\n    'value for \"%s\" is a non-empty string',\n    (difficulty) => {\n      const value = difficultyBadgeStyles[difficulty];\n      expect(typeof value).toBe(\"string\");\n      expect(value.trim().length).toBeGreaterThan(0);\n    }\n  );\n});\n\n// ---------------------------------------------------------------------------\n// ALL_CATEGORIES\n// ---------------------------------------------------------------------------\n\ndescribe(\"ALL_CATEGORIES\", () => {\n  const expectedCategories: ConceptCategory[] = [\n    \"Core CLI\",\n    \"Intelligence\",\n    \"Memory\",\n    \"Automation\",\n    \"Integration\",\n  ];\n\n  it(\"contains exactly 5 categories\", () => {\n    expect(ALL_CATEGORIES).toHaveLength(5);\n  });\n\n  it.each(expectedCategories)(\n    'includes the category \"%s\"',\n    (category) => {\n      expect(ALL_CATEGORIES).toContain(category);\n    }\n  );\n\n  it(\"has no duplicate categories\", () => {\n    const unique = new Set(ALL_CATEGORIES);\n    expect(unique.size).toBe(ALL_CATEGORIES.length);\n  });\n});\n\n// ---------------------------------------------------------------------------\n// concepts array ‚Äî structural integrity\n// ---------------------------------------------------------------------------\n\ndescribe(\"concepts array\", () => {\n  it(\"is a non-empty array\", () => {\n    expect(Array.isArray(concepts)).toBe(true);\n    expect(concepts.length).toBeGreaterThan(0);\n  });\n\n  describe(\"required string fields on every concept\", () => {\n    it.each(concepts)('concept \"$slug\" has a non-empty slug', ({ slug }) => {\n      expect(typeof slug).toBe(\"string\");\n      expect(slug.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty title', ({ slug, title }) => {\n      expect(typeof title).toBe(\"string\");\n      expect(title.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty emoji', ({ slug, emoji }) => {\n      expect(typeof emoji).toBe(\"string\");\n      expect(emoji.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty shortDesc', ({ slug, shortDesc }) => {\n      expect(typeof shortDesc).toBe(\"string\");\n      expect(shortDesc.trim().length).toBeGreaterThan(0);\n    });\n  });\n\n  describe(\"slug uniqueness\", () => {\n    it(\"every slug is unique across all concepts\", () => {\n      const slugs = concepts.map((c) => c.slug);\n      const unique = new Set(slugs);\n      expect(unique.size).toBe(slugs.length);\n    });\n  });\n\n  describe(\"category validity\", () => {\n    it.each(concepts)(\n      'concept \"$slug\" has a valid category',\n      ({ slug, category }) => {\n        expect(ALL_CATEGORIES).toContain(category);\n      }\n    );\n  });\n\n  describe(\"difficulty validity\", () => {\n    const validDifficulties: Difficulty[] = [\"Beginner\", \"Intermediate\", \"Advanced\"];\n\n    it.each(concepts)(\n      'concept \"$slug\" has a valid difficulty',\n      ({ slug, difficulty }) => {\n        expect(validDifficulties).toContain(difficulty);\n      }\n    );\n  });\n\n  describe(\"sections ‚Äî every concept has at least one\", () => {\n    it.each(concepts)(\n      'concept \"$slug\" has at least one section',\n      ({ slug, sections }) => {\n        expect(Array.isArray(sections)).toBe(true);\n        expect(sections.length).toBeGreaterThan(0);\n      }\n    );\n  });\n\n  describe(\"sections ‚Äî heading and body\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        it(`concept \"${concept.slug}\" section[${index}] has a non-empty heading`, () => {\n          expect(typeof section.heading).toBe(\"string\");\n          expect(section.heading.trim().length).toBeGreaterThan(0);\n        });\n\n        it(`concept \"${concept.slug}\" section[${index}] has a non-empty body`, () => {\n          expect(typeof section.body).toBe(\"string\");\n          expect(section.body.trim().length).toBeGreaterThan(0);\n        });\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî screenshots shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.screenshots !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] screenshots is a non-empty array`, () => {\n            expect(Array.isArray(section.screenshots)).toBe(true);\n            expect(section.screenshots!.length).toBeGreaterThan(0);\n          });\n\n          for (const [imgIndex, screenshot] of section.screenshots.entries()) {\n            it(`concept \"${concept.slug}\" section[${index}] screenshot[${imgIndex}] has non-empty src`, () => {\n              expect(typeof screenshot.src).toBe(\"string\");\n              expect(screenshot.src.trim().length).toBeGreaterThan(0);\n            });\n\n            it(`concept \"${concept.slug}\" section[${index}] screenshot[${imgIndex}] has non-empty alt`, () => {\n              expect(typeof screenshot.alt).toBe(\"string\");\n              expect(screenshot.alt.trim().length).toBeGreaterThan(0);\n            });\n          }\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî carousel requires screenshots\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.carousel === true) {\n          it(`concept \"${concept.slug}\" section[${index}] with carousel:true also has a screenshots array`, () => {\n            expect(Array.isArray(section.screenshots)).toBe(true);\n            expect(section.screenshots!.length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî code block shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.code !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] code.language is non-empty`, () => {\n            expect(typeof section.code!.language).toBe(\"string\");\n            expect(section.code!.language.trim().length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" section[${index}] code.content is non-empty`, () => {\n            expect(typeof section.code!.content).toBe(\"string\");\n            expect(section.code!.content.trim().length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî table shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.table !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] table.headers is a non-empty array`, () => {\n            expect(Array.isArray(section.table!.headers)).toBe(true);\n            expect(section.table!.headers.length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" section[${index}] table.rows is an array`, () => {\n            expect(Array.isArray(section.table!.rows)).toBe(true);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"references ‚Äî shape when present\", () => {\n    for (const concept of concepts) {\n      if (concept.references !== undefined) {\n        it(`concept \"${concept.slug}\" references is a non-empty array`, () => {\n          expect(Array.isArray(concept.references)).toBe(true);\n          expect(concept.references!.length).toBeGreaterThan(0);\n        });\n\n        for (const [refIndex, ref] of concept.references.entries()) {\n          it(`concept \"${concept.slug}\" reference[${refIndex}] has non-empty label`, () => {\n            expect(typeof ref.label).toBe(\"string\");\n            expect(ref.label.trim().length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" reference[${refIndex}] has non-empty url`, () => {\n            expect(typeof ref.url).toBe(\"string\");\n            expect(ref.url.trim().length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"released concepts ‚Äî all required fields populated\", () => {\n    const releasedConcepts = concepts.filter((c) => c.released === true);\n\n    it(\"there is at least one released concept\", () => {\n      expect(releasedConcepts.length).toBeGreaterThan(0);\n    });\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty slug',\n      ({ slug }) => {\n        expect(slug.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty title',\n      ({ slug, title }) => {\n        expect(title.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty shortDesc',\n      ({ slug, shortDesc }) => {\n        expect(shortDesc.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has at least one section',\n      ({ slug, sections }) => {\n        expect(sections.length).toBeGreaterThan(0);\n      }\n    );\n  });\n});\n\n// ---------------------------------------------------------------------------\n// Specific spot-checks\n// ---------------------------------------------------------------------------\n\ndescribe(\"spot-checks ‚Äî specific concepts\", () => {\n  it('the \"getting-started\" concept exists', () => {\n    const c = concepts.find((c) => c.slug === \"getting-started\");\n    expect(c).toBeDefined();\n  });\n\n  it('the \"getting-started\" concept is released', () => {\n    const c = concepts.find((c) => c.slug === \"getting-started\");\n    expect(c?.released).toBe(true);\n  });\n\n  it('the \"subagents\" concept exists', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    expect(c).toBeDefined();\n  });\n\n  it('the \"subagents\" concept has title \"Subagents\"', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    expect(c?.title).toBe(\"Subagents\");\n  });\n\n  it('the \"subagents\" concept has a section with heading \"Creating Your Own Subagent\"', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section).toBeDefined();\n  });\n\n  it('the \"Creating Your Own Subagent\" section has carousel:true', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section?.carousel).toBe(true);\n  });\n\n  it('the \"Creating Your Own Subagent\" section has 10 or more screenshots', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section?.screenshots).toBeDefined();\n    expect(section?.screenshots!.length).toBeGreaterThanOrEqual(10);\n  });\n});\n"
      },
      "tool_response": {
        "type": "create",
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.test.ts",
        "content": "import { describe, it, expect } from \"vitest\";\nimport {\n  difficultyBadgeStyles,\n  ALL_CATEGORIES,\n  concepts,\n} from \"../src/data/concepts\";\nimport type { Difficulty, ConceptCategory } from \"../src/data/concepts\";\n\n// ---------------------------------------------------------------------------\n// difficultyBadgeStyles\n// ---------------------------------------------------------------------------\n\ndescribe(\"difficultyBadgeStyles\", () => {\n  const validDifficulties: Difficulty[] = [\"Beginner\", \"Intermediate\", \"Advanced\"];\n\n  it(\"contains an entry for every valid difficulty\", () => {\n    for (const d of validDifficulties) {\n      expect(difficultyBadgeStyles).toHaveProperty(d);\n    }\n  });\n\n  it(\"has exactly 3 keys ‚Äî no extra or missing difficulties\", () => {\n    expect(Object.keys(difficultyBadgeStyles)).toHaveLength(3);\n  });\n\n  it.each(validDifficulties)(\n    'value for \"%s\" is a non-empty string',\n    (difficulty) => {\n      const value = difficultyBadgeStyles[difficulty];\n      expect(typeof value).toBe(\"string\");\n      expect(value.trim().length).toBeGreaterThan(0);\n    }\n  );\n});\n\n// ---------------------------------------------------------------------------\n// ALL_CATEGORIES\n// ---------------------------------------------------------------------------\n\ndescribe(\"ALL_CATEGORIES\", () => {\n  const expectedCategories: ConceptCategory[] = [\n    \"Core CLI\",\n    \"Intelligence\",\n    \"Memory\",\n    \"Automation\",\n    \"Integration\",\n  ];\n\n  it(\"contains exactly 5 categories\", () => {\n    expect(ALL_CATEGORIES).toHaveLength(5);\n  });\n\n  it.each(expectedCategories)(\n    'includes the category \"%s\"',\n    (category) => {\n      expect(ALL_CATEGORIES).toContain(category);\n    }\n  );\n\n  it(\"has no duplicate categories\", () => {\n    const unique = new Set(ALL_CATEGORIES);\n    expect(unique.size).toBe(ALL_CATEGORIES.length);\n  });\n});\n\n// ---------------------------------------------------------------------------\n// concepts array ‚Äî structural integrity\n// ---------------------------------------------------------------------------\n\ndescribe(\"concepts array\", () => {\n  it(\"is a non-empty array\", () => {\n    expect(Array.isArray(concepts)).toBe(true);\n    expect(concepts.length).toBeGreaterThan(0);\n  });\n\n  describe(\"required string fields on every concept\", () => {\n    it.each(concepts)('concept \"$slug\" has a non-empty slug', ({ slug }) => {\n      expect(typeof slug).toBe(\"string\");\n      expect(slug.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty title', ({ slug, title }) => {\n      expect(typeof title).toBe(\"string\");\n      expect(title.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty emoji', ({ slug, emoji }) => {\n      expect(typeof emoji).toBe(\"string\");\n      expect(emoji.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty shortDesc', ({ slug, shortDesc }) => {\n      expect(typeof shortDesc).toBe(\"string\");\n      expect(shortDesc.trim().length).toBeGreaterThan(0);\n    });\n  });\n\n  describe(\"slug uniqueness\", () => {\n    it(\"every slug is unique across all concepts\", () => {\n      const slugs = concepts.map((c) => c.slug);\n      const unique = new Set(slugs);\n      expect(unique.size).toBe(slugs.length);\n    });\n  });\n\n  describe(\"category validity\", () => {\n    it.each(concepts)(\n      'concept \"$slug\" has a valid category',\n      ({ slug, category }) => {\n        expect(ALL_CATEGORIES).toContain(category);\n      }\n    );\n  });\n\n  describe(\"difficulty validity\", () => {\n    const validDifficulties: Difficulty[] = [\"Beginner\", \"Intermediate\", \"Advanced\"];\n\n    it.each(concepts)(\n      'concept \"$slug\" has a valid difficulty',\n      ({ slug, difficulty }) => {\n        expect(validDifficulties).toContain(difficulty);\n      }\n    );\n  });\n\n  describe(\"sections ‚Äî every concept has at least one\", () => {\n    it.each(concepts)(\n      'concept \"$slug\" has at least one section',\n      ({ slug, sections }) => {\n        expect(Array.isArray(sections)).toBe(true);\n        expect(sections.length).toBeGreaterThan(0);\n      }\n    );\n  });\n\n  describe(\"sections ‚Äî heading and body\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        it(`concept \"${concept.slug}\" section[${index}] has a non-empty heading`, () => {\n          expect(typeof section.heading).toBe(\"string\");\n          expect(section.heading.trim().length).toBeGreaterThan(0);\n        });\n\n        it(`concept \"${concept.slug}\" section[${index}] has a non-empty body`, () => {\n          expect(typeof section.body).toBe(\"string\");\n          expect(section.body.trim().length).toBeGreaterThan(0);\n        });\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî screenshots shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.screenshots !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] screenshots is a non-empty array`, () => {\n            expect(Array.isArray(section.screenshots)).toBe(true);\n            expect(section.screenshots!.length).toBeGreaterThan(0);\n          });\n\n          for (const [imgIndex, screenshot] of section.screenshots.entries()) {\n            it(`concept \"${concept.slug}\" section[${index}] screenshot[${imgIndex}] has non-empty src`, () => {\n              expect(typeof screenshot.src).toBe(\"string\");\n              expect(screenshot.src.trim().length).toBeGreaterThan(0);\n            });\n\n            it(`concept \"${concept.slug}\" section[${index}] screenshot[${imgIndex}] has non-empty alt`, () => {\n              expect(typeof screenshot.alt).toBe(\"string\");\n              expect(screenshot.alt.trim().length).toBeGreaterThan(0);\n            });\n          }\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî carousel requires screenshots\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.carousel === true) {\n          it(`concept \"${concept.slug}\" section[${index}] with carousel:true also has a screenshots array`, () => {\n            expect(Array.isArray(section.screenshots)).toBe(true);\n            expect(section.screenshots!.length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî code block shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.code !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] code.language is non-empty`, () => {\n            expect(typeof section.code!.language).toBe(\"string\");\n            expect(section.code!.language.trim().length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" section[${index}] code.content is non-empty`, () => {\n            expect(typeof section.code!.content).toBe(\"string\");\n            expect(section.code!.content.trim().length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî table shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.table !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] table.headers is a non-empty array`, () => {\n            expect(Array.isArray(section.table!.headers)).toBe(true);\n            expect(section.table!.headers.length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" section[${index}] table.rows is an array`, () => {\n            expect(Array.isArray(section.table!.rows)).toBe(true);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"references ‚Äî shape when present\", () => {\n    for (const concept of concepts) {\n      if (concept.references !== undefined) {\n        it(`concept \"${concept.slug}\" references is a non-empty array`, () => {\n          expect(Array.isArray(concept.references)).toBe(true);\n          expect(concept.references!.length).toBeGreaterThan(0);\n        });\n\n        for (const [refIndex, ref] of concept.references.entries()) {\n          it(`concept \"${concept.slug}\" reference[${refIndex}] has non-empty label`, () => {\n            expect(typeof ref.label).toBe(\"string\");\n            expect(ref.label.trim().length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" reference[${refIndex}] has non-empty url`, () => {\n            expect(typeof ref.url).toBe(\"string\");\n            expect(ref.url.trim().length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"released concepts ‚Äî all required fields populated\", () => {\n    const releasedConcepts = concepts.filter((c) => c.released === true);\n\n    it(\"there is at least one released concept\", () => {\n      expect(releasedConcepts.length).toBeGreaterThan(0);\n    });\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty slug',\n      ({ slug }) => {\n        expect(slug.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty title',\n      ({ slug, title }) => {\n        expect(title.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty shortDesc',\n      ({ slug, shortDesc }) => {\n        expect(shortDesc.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has at least one section',\n      ({ slug, sections }) => {\n        expect(sections.length).toBeGreaterThan(0);\n      }\n    );\n  });\n});\n\n// ---------------------------------------------------------------------------\n// Specific spot-checks\n// ---------------------------------------------------------------------------\n\ndescribe(\"spot-checks ‚Äî specific concepts\", () => {\n  it('the \"getting-started\" concept exists', () => {\n    const c = concepts.find((c) => c.slug === \"getting-started\");\n    expect(c).toBeDefined();\n  });\n\n  it('the \"getting-started\" concept is released', () => {\n    const c = concepts.find((c) => c.slug === \"getting-started\");\n    expect(c?.released).toBe(true);\n  });\n\n  it('the \"subagents\" concept exists', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    expect(c).toBeDefined();\n  });\n\n  it('the \"subagents\" concept has title \"Subagents\"', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    expect(c?.title).toBe(\"Subagents\");\n  });\n\n  it('the \"subagents\" concept has a section with heading \"Creating Your Own Subagent\"', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section).toBeDefined();\n  });\n\n  it('the \"Creating Your Own Subagent\" section has carousel:true', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section?.carousel).toBe(true);\n  });\n\n  it('the \"Creating Your Own Subagent\" section has 10 or more screenshots', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section?.screenshots).toBeDefined();\n    expect(section?.screenshots!.length).toBeGreaterThanOrEqual(10);\n  });\n});\n",
        "structuredPatch": [],
        "originalFile": null
      },
      "tool_use_id": "toolu_01WDMfXmXsBkqoKY1WBKy8WN"
    }
  },
  {
    "timestamp": "2026-02-28T04:54:42.141Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Bash",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T04:54:46.319Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "cd \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\" && npx vitest run src/data/concepts.test.ts 2>&1 | head -30",
        "timeout": 30000,
        "description": "Run tests to check for import errors"
      },
      "tool_response": {
        "stdout": "\u001b[1m\u001b[46m RUN \u001b[49m\u001b[22m \u001b[36mv4.0.18 \u001b[39m\u001b[90mC:/Learning/Personal/Anthropic Learning/claude-learning-app\u001b[39m\n\n \u001b[31m‚ùØ\u001b[39m src/data/concepts.test.ts \u001b[2m(\u001b[22m\u001b[2m0 test\u001b[22m\u001b[2m)\u001b[22m\n\n\u001b[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ\u001b[39m\u001b[1m\u001b[41m Failed Suites 1 \u001b[49m\u001b[22m\u001b[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ\u001b[39m\n\n\u001b[41m\u001b[1m FAIL \u001b[22m\u001b[49m src/data/concepts.test.ts\u001b[2m [ src/data/concepts.test.ts ]\u001b[22m\n\u001b[31m\u001b[1mError\u001b[22m: Cannot find module '../src/data/concepts' imported from 'C:/Learning/Personal/Anthropic Learning/claude-learning-app/src/data/concepts.test.ts'\u001b[39m\n\u001b[36m \u001b[2m‚ùØ\u001b[22m src/data/concepts.test.ts:\u001b[2m2:1\u001b[22m\u001b[39m\n    \u001b[90m  1| \u001b[39m\u001b[35mimport\u001b[39m { describe\u001b[33m,\u001b[39m it\u001b[33m,\u001b[39m expect } \u001b[35mfrom\u001b[39m \u001b[32m\"vitest\"\u001b[39m\u001b[33m;\u001b[39m\n    \u001b[90m  2| \u001b[39m\u001b[35mimport\u001b[39m {\n    \u001b[90m   | \u001b[39m\u001b[31m^\u001b[39m\n    \u001b[90m  3| \u001b[39m  difficultyBadgeStyles\u001b[33m,\u001b[39m\n    \u001b[90m  4| \u001b[39m  \u001b[33mALL_CATEGORIES\u001b[39m\u001b[33m,\u001b[39m\n\n\u001b[31m\u001b[2m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[1/1]‚éØ\u001b[22m\u001b[39m\n\n\n\u001b[2m Test Files \u001b[22m \u001b[1m\u001b[31m1 failed\u001b[39m\u001b[22m\u001b[90m (1)\u001b[39m\n\u001b[2m      Tests \u001b[22m \u001b[2mno tests\u001b[22m\n\u001b[2m   Start at \u001b[22m 10:24:45\n\u001b[2m   Duration \u001b[22m 203ms\u001b[2m (transform 45ms, setup 0ms, import 0ms, tests 0ms, environment 0ms)\u001b[22m",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_014LCbFmh5atxihDbz7nQtdV"
    }
  },
  {
    "timestamp": "2026-02-28T04:54:51.046Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.test.ts",
        "old_string": "import {\n  difficultyBadgeStyles,\n  ALL_CATEGORIES,\n  concepts,\n} from \"../src/data/concepts\";\nimport type { Difficulty, ConceptCategory } from \"../src/data/concepts\";",
        "new_string": "import {\n  difficultyBadgeStyles,\n  ALL_CATEGORIES,\n  concepts,\n} from \"./concepts\";\nimport type { Difficulty, ConceptCategory } from \"./concepts\";",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.test.ts",
        "oldString": "import {\n  difficultyBadgeStyles,\n  ALL_CATEGORIES,\n  concepts,\n} from \"../src/data/concepts\";\nimport type { Difficulty, ConceptCategory } from \"../src/data/concepts\";",
        "newString": "import {\n  difficultyBadgeStyles,\n  ALL_CATEGORIES,\n  concepts,\n} from \"./concepts\";\nimport type { Difficulty, ConceptCategory } from \"./concepts\";",
        "originalFile": "import { describe, it, expect } from \"vitest\";\nimport {\n  difficultyBadgeStyles,\n  ALL_CATEGORIES,\n  concepts,\n} from \"../src/data/concepts\";\nimport type { Difficulty, ConceptCategory } from \"../src/data/concepts\";\n\n// ---------------------------------------------------------------------------\n// difficultyBadgeStyles\n// ---------------------------------------------------------------------------\n\ndescribe(\"difficultyBadgeStyles\", () => {\n  const validDifficulties: Difficulty[] = [\"Beginner\", \"Intermediate\", \"Advanced\"];\n\n  it(\"contains an entry for every valid difficulty\", () => {\n    for (const d of validDifficulties) {\n      expect(difficultyBadgeStyles).toHaveProperty(d);\n    }\n  });\n\n  it(\"has exactly 3 keys ‚Äî no extra or missing difficulties\", () => {\n    expect(Object.keys(difficultyBadgeStyles)).toHaveLength(3);\n  });\n\n  it.each(validDifficulties)(\n    'value for \"%s\" is a non-empty string',\n    (difficulty) => {\n      const value = difficultyBadgeStyles[difficulty];\n      expect(typeof value).toBe(\"string\");\n      expect(value.trim().length).toBeGreaterThan(0);\n    }\n  );\n});\n\n// ---------------------------------------------------------------------------\n// ALL_CATEGORIES\n// ---------------------------------------------------------------------------\n\ndescribe(\"ALL_CATEGORIES\", () => {\n  const expectedCategories: ConceptCategory[] = [\n    \"Core CLI\",\n    \"Intelligence\",\n    \"Memory\",\n    \"Automation\",\n    \"Integration\",\n  ];\n\n  it(\"contains exactly 5 categories\", () => {\n    expect(ALL_CATEGORIES).toHaveLength(5);\n  });\n\n  it.each(expectedCategories)(\n    'includes the category \"%s\"',\n    (category) => {\n      expect(ALL_CATEGORIES).toContain(category);\n    }\n  );\n\n  it(\"has no duplicate categories\", () => {\n    const unique = new Set(ALL_CATEGORIES);\n    expect(unique.size).toBe(ALL_CATEGORIES.length);\n  });\n});\n\n// ---------------------------------------------------------------------------\n// concepts array ‚Äî structural integrity\n// ---------------------------------------------------------------------------\n\ndescribe(\"concepts array\", () => {\n  it(\"is a non-empty array\", () => {\n    expect(Array.isArray(concepts)).toBe(true);\n    expect(concepts.length).toBeGreaterThan(0);\n  });\n\n  describe(\"required string fields on every concept\", () => {\n    it.each(concepts)('concept \"$slug\" has a non-empty slug', ({ slug }) => {\n      expect(typeof slug).toBe(\"string\");\n      expect(slug.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty title', ({ slug, title }) => {\n      expect(typeof title).toBe(\"string\");\n      expect(title.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty emoji', ({ slug, emoji }) => {\n      expect(typeof emoji).toBe(\"string\");\n      expect(emoji.trim().length).toBeGreaterThan(0);\n    });\n\n    it.each(concepts)('concept \"$slug\" has a non-empty shortDesc', ({ slug, shortDesc }) => {\n      expect(typeof shortDesc).toBe(\"string\");\n      expect(shortDesc.trim().length).toBeGreaterThan(0);\n    });\n  });\n\n  describe(\"slug uniqueness\", () => {\n    it(\"every slug is unique across all concepts\", () => {\n      const slugs = concepts.map((c) => c.slug);\n      const unique = new Set(slugs);\n      expect(unique.size).toBe(slugs.length);\n    });\n  });\n\n  describe(\"category validity\", () => {\n    it.each(concepts)(\n      'concept \"$slug\" has a valid category',\n      ({ slug, category }) => {\n        expect(ALL_CATEGORIES).toContain(category);\n      }\n    );\n  });\n\n  describe(\"difficulty validity\", () => {\n    const validDifficulties: Difficulty[] = [\"Beginner\", \"Intermediate\", \"Advanced\"];\n\n    it.each(concepts)(\n      'concept \"$slug\" has a valid difficulty',\n      ({ slug, difficulty }) => {\n        expect(validDifficulties).toContain(difficulty);\n      }\n    );\n  });\n\n  describe(\"sections ‚Äî every concept has at least one\", () => {\n    it.each(concepts)(\n      'concept \"$slug\" has at least one section',\n      ({ slug, sections }) => {\n        expect(Array.isArray(sections)).toBe(true);\n        expect(sections.length).toBeGreaterThan(0);\n      }\n    );\n  });\n\n  describe(\"sections ‚Äî heading and body\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        it(`concept \"${concept.slug}\" section[${index}] has a non-empty heading`, () => {\n          expect(typeof section.heading).toBe(\"string\");\n          expect(section.heading.trim().length).toBeGreaterThan(0);\n        });\n\n        it(`concept \"${concept.slug}\" section[${index}] has a non-empty body`, () => {\n          expect(typeof section.body).toBe(\"string\");\n          expect(section.body.trim().length).toBeGreaterThan(0);\n        });\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî screenshots shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.screenshots !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] screenshots is a non-empty array`, () => {\n            expect(Array.isArray(section.screenshots)).toBe(true);\n            expect(section.screenshots!.length).toBeGreaterThan(0);\n          });\n\n          for (const [imgIndex, screenshot] of section.screenshots.entries()) {\n            it(`concept \"${concept.slug}\" section[${index}] screenshot[${imgIndex}] has non-empty src`, () => {\n              expect(typeof screenshot.src).toBe(\"string\");\n              expect(screenshot.src.trim().length).toBeGreaterThan(0);\n            });\n\n            it(`concept \"${concept.slug}\" section[${index}] screenshot[${imgIndex}] has non-empty alt`, () => {\n              expect(typeof screenshot.alt).toBe(\"string\");\n              expect(screenshot.alt.trim().length).toBeGreaterThan(0);\n            });\n          }\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî carousel requires screenshots\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.carousel === true) {\n          it(`concept \"${concept.slug}\" section[${index}] with carousel:true also has a screenshots array`, () => {\n            expect(Array.isArray(section.screenshots)).toBe(true);\n            expect(section.screenshots!.length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî code block shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.code !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] code.language is non-empty`, () => {\n            expect(typeof section.code!.language).toBe(\"string\");\n            expect(section.code!.language.trim().length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" section[${index}] code.content is non-empty`, () => {\n            expect(typeof section.code!.content).toBe(\"string\");\n            expect(section.code!.content.trim().length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"sections ‚Äî table shape when present\", () => {\n    for (const concept of concepts) {\n      for (const [index, section] of concept.sections.entries()) {\n        if (section.table !== undefined) {\n          it(`concept \"${concept.slug}\" section[${index}] table.headers is a non-empty array`, () => {\n            expect(Array.isArray(section.table!.headers)).toBe(true);\n            expect(section.table!.headers.length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" section[${index}] table.rows is an array`, () => {\n            expect(Array.isArray(section.table!.rows)).toBe(true);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"references ‚Äî shape when present\", () => {\n    for (const concept of concepts) {\n      if (concept.references !== undefined) {\n        it(`concept \"${concept.slug}\" references is a non-empty array`, () => {\n          expect(Array.isArray(concept.references)).toBe(true);\n          expect(concept.references!.length).toBeGreaterThan(0);\n        });\n\n        for (const [refIndex, ref] of concept.references.entries()) {\n          it(`concept \"${concept.slug}\" reference[${refIndex}] has non-empty label`, () => {\n            expect(typeof ref.label).toBe(\"string\");\n            expect(ref.label.trim().length).toBeGreaterThan(0);\n          });\n\n          it(`concept \"${concept.slug}\" reference[${refIndex}] has non-empty url`, () => {\n            expect(typeof ref.url).toBe(\"string\");\n            expect(ref.url.trim().length).toBeGreaterThan(0);\n          });\n        }\n      }\n    }\n  });\n\n  describe(\"released concepts ‚Äî all required fields populated\", () => {\n    const releasedConcepts = concepts.filter((c) => c.released === true);\n\n    it(\"there is at least one released concept\", () => {\n      expect(releasedConcepts.length).toBeGreaterThan(0);\n    });\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty slug',\n      ({ slug }) => {\n        expect(slug.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty title',\n      ({ slug, title }) => {\n        expect(title.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has a non-empty shortDesc',\n      ({ slug, shortDesc }) => {\n        expect(shortDesc.trim().length).toBeGreaterThan(0);\n      }\n    );\n\n    it.each(releasedConcepts)(\n      'released concept \"$slug\" has at least one section',\n      ({ slug, sections }) => {\n        expect(sections.length).toBeGreaterThan(0);\n      }\n    );\n  });\n});\n\n// ---------------------------------------------------------------------------\n// Specific spot-checks\n// ---------------------------------------------------------------------------\n\ndescribe(\"spot-checks ‚Äî specific concepts\", () => {\n  it('the \"getting-started\" concept exists', () => {\n    const c = concepts.find((c) => c.slug === \"getting-started\");\n    expect(c).toBeDefined();\n  });\n\n  it('the \"getting-started\" concept is released', () => {\n    const c = concepts.find((c) => c.slug === \"getting-started\");\n    expect(c?.released).toBe(true);\n  });\n\n  it('the \"subagents\" concept exists', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    expect(c).toBeDefined();\n  });\n\n  it('the \"subagents\" concept has title \"Subagents\"', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    expect(c?.title).toBe(\"Subagents\");\n  });\n\n  it('the \"subagents\" concept has a section with heading \"Creating Your Own Subagent\"', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section).toBeDefined();\n  });\n\n  it('the \"Creating Your Own Subagent\" section has carousel:true', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section?.carousel).toBe(true);\n  });\n\n  it('the \"Creating Your Own Subagent\" section has 10 or more screenshots', () => {\n    const c = concepts.find((c) => c.slug === \"subagents\");\n    const section = c?.sections.find(\n      (s) => s.heading === \"Creating Your Own Subagent\"\n    );\n    expect(section?.screenshots).toBeDefined();\n    expect(section?.screenshots!.length).toBeGreaterThanOrEqual(10);\n  });\n});\n",
        "structuredPatch": [
          {
            "oldStart": 3,
            "oldLines": 8,
            "newStart": 3,
            "newLines": 8,
            "lines": [
              "   difficultyBadgeStyles,",
              "   ALL_CATEGORIES,",
              "   concepts,",
              "-} from \"../src/data/concepts\";",
              "-import type { Difficulty, ConceptCategory } from \"../src/data/concepts\";",
              "+} from \"./concepts\";",
              "+import type { Difficulty, ConceptCategory } from \"./concepts\";",
              " ",
              " // ---------------------------------------------------------------------------",
              " // difficultyBadgeStyles"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01HNC6Axrd8i2MwXWzRiFKC1"
    }
  },
  {
    "timestamp": "2026-02-28T04:54:57.463Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "cd \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\" && npx vitest run src/data/concepts.test.ts 2>&1",
        "timeout": 30000,
        "description": "Run tests after import fix"
      },
      "tool_response": {
        "stdout": "\u001b[1m\u001b[46m RUN \u001b[49m\u001b[22m \u001b[36mv4.0.18 \u001b[39m\u001b[90mC:/Learning/Personal/Anthropic Learning/claude-learning-app\u001b[39m\n\n \u001b[32m‚úì\u001b[39m src/data/concepts.test.ts \u001b[2m(\u001b[22m\u001b[2m626 tests\u001b[22m\u001b[2m)\u001b[22m\u001b[32m 41\u001b[2mms\u001b[22m\u001b[39m\n\n\u001b[2m Test Files \u001b[22m \u001b[1m\u001b[32m1 passed\u001b[39m\u001b[22m\u001b[90m (1)\u001b[39m\n\u001b[2m      Tests \u001b[22m \u001b[1m\u001b[32m626 passed\u001b[39m\u001b[22m\u001b[90m (626)\u001b[39m\n\u001b[2m   Start at \u001b[22m 10:24:57\n\u001b[2m   Duration \u001b[22m 281ms\u001b[2m (transform 78ms, setup 0ms, import 108ms, tests 41ms, environment 0ms)\u001b[22m",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01HC5T5mBrchZQPx7deUTwPa"
    }
  },
  {
    "timestamp": "2026-02-28T04:55:15.498Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Write",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\agent-memory\\unit-test-writer\\MEMORY.md",
        "content": "# Unit Test Writer ‚Äî Agent Memory\n\n## Framework\n- Vitest is NOT pre-installed in this project. Install with: `npm install --save-dev vitest`\n- Installed version: vitest 4.x (latest)\n- No vitest config file needed for pure data/utility tests\n- Run tests: `npx vitest run <path-to-test-file>`\n\n## Import Conventions\n- Test files co-located with source: `src/data/concepts.test.ts` imports `./concepts`\n- Do NOT use `../src/data/concepts` ‚Äî the test is already inside `src/`\n- The `@/*` alias (maps to `src/*`) does NOT resolve in Vitest without a vite/vitest config ‚Äî use relative paths instead\n\n## Test Structure Patterns\n- `describe` blocks by concern: `difficultyBadgeStyles`, `ALL_CATEGORIES`, `concepts array`, `spot-checks`\n- Use `it.each(array)` with `\"$fieldName\"` interpolation for parameterized tests over data arrays\n- For nested validation (sections, screenshots inside concepts), use nested `for...of` loops with `it(...)` inside to generate individual test cases ‚Äî each gets a unique name including index\n- Optional fields: guard with `if (field !== undefined)` before generating tests for them\n\n## Project-Specific Notes\n- `src/data/concepts.ts` ‚Äî pure static data, no mocking needed\n- Concepts have optional: `released`, `releaseDate`, `references`, `bullets`, `code`, `screenshots`, `carousel`, `table`\n- `carousel: true` sections must also have a `screenshots` array (invariant enforced in tests)\n- 16 concepts total as of this writing: 12 released, 4 unreleased (skills, worktrees, mcp, settings)\n- References only on: `cli-commands`, `settings-json`\n\n## File Naming\n- Co-located test files: `*.test.ts` (not `*.spec.ts`)\n- Place at same path as source: `src/data/concepts.ts` -> `src/data/concepts.test.ts`\n"
      },
      "tool_response": {
        "type": "create",
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\agent-memory\\unit-test-writer\\MEMORY.md",
        "content": "# Unit Test Writer ‚Äî Agent Memory\n\n## Framework\n- Vitest is NOT pre-installed in this project. Install with: `npm install --save-dev vitest`\n- Installed version: vitest 4.x (latest)\n- No vitest config file needed for pure data/utility tests\n- Run tests: `npx vitest run <path-to-test-file>`\n\n## Import Conventions\n- Test files co-located with source: `src/data/concepts.test.ts` imports `./concepts`\n- Do NOT use `../src/data/concepts` ‚Äî the test is already inside `src/`\n- The `@/*` alias (maps to `src/*`) does NOT resolve in Vitest without a vite/vitest config ‚Äî use relative paths instead\n\n## Test Structure Patterns\n- `describe` blocks by concern: `difficultyBadgeStyles`, `ALL_CATEGORIES`, `concepts array`, `spot-checks`\n- Use `it.each(array)` with `\"$fieldName\"` interpolation for parameterized tests over data arrays\n- For nested validation (sections, screenshots inside concepts), use nested `for...of` loops with `it(...)` inside to generate individual test cases ‚Äî each gets a unique name including index\n- Optional fields: guard with `if (field !== undefined)` before generating tests for them\n\n## Project-Specific Notes\n- `src/data/concepts.ts` ‚Äî pure static data, no mocking needed\n- Concepts have optional: `released`, `releaseDate`, `references`, `bullets`, `code`, `screenshots`, `carousel`, `table`\n- `carousel: true` sections must also have a `screenshots` array (invariant enforced in tests)\n- 16 concepts total as of this writing: 12 released, 4 unreleased (skills, worktrees, mcp, settings)\n- References only on: `cli-commands`, `settings-json`\n\n## File Naming\n- Co-located test files: `*.test.ts` (not `*.spec.ts`)\n- Place at same path as source: `src/data/concepts.ts` -> `src/data/concepts.test.ts`\n",
        "structuredPatch": [],
        "originalFile": null
      },
      "tool_use_id": "toolu_01DzC5uGHyaQNxwFtb3ZqoQs"
    }
  },
  {
    "timestamp": "2026-02-28T04:55:34.577Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a2635fbf76ce6ec82",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-a2635fbf76ce6ec82.jsonl",
      "agent_type": "unit-test-writer",
      "last_assistant_message": "All 626 tests pass. Here is a summary of everything done.\n\n---\n\n## Analysis\n\nThe `src/data/concepts.ts` file exports pure static data ‚Äî no side effects, no async, no dependencies. Key observations:\n\n- **16 concepts** across 5 categories and 3 difficulty levels\n- **Optional fields** on `ConceptSection`: `bullets`, `code`, `screenshots`, `carousel`, `table` ‚Äî each has its own shape invariant to validate\n- **Invariant**: `carousel: true` is only meaningful when `screenshots` is also present (one section has both: `subagents` / \"Creating Your Own Subagent\" with 11 screenshots)\n- **References** appear on 2 concepts: `cli-commands` and `settings-json`\n- **4 unreleased** concepts (`skills`, `worktrees`, `mcp`, `settings`) have `released: false` and a `releaseDate`\n\nVitest was not installed ‚Äî installed it (`vitest@4.0.18`) as a dev dependency. The `@/` alias does not resolve in Vitest without a vite config, so a relative import (`./concepts`) was used.\n\n---\n\n## Test file: `src/data/concepts.test.ts`\n\n626 tests generated, all passing:\n\n```\nTest Files  1 passed (1)\n      Tests  626 passed (626)\n   Duration  281ms\n```\n\n### Coverage Summary\n\n| Area | What is tested |\n|---|---|\n| `difficultyBadgeStyles` | All 3 keys exist, exactly 3 keys, each value is a non-empty string |\n| `ALL_CATEGORIES` | Length is 5, all 5 expected values present, no duplicates |\n| `concepts` array | Non-empty array, all 16 concepts tested individually |\n| Required string fields | `slug`, `title`, `emoji`, `shortDesc` ‚Äî non-empty on every concept |\n| Slug uniqueness | Set size equals array length |\n| Category validity | Every concept's category is in `ALL_CATEGORIES` |\n| Difficulty validity | Every concept's difficulty is one of the 3 valid values |\n| Sections presence | Every concept has at least 1 section |\n| Section `heading` + `body` | Non-empty strings on every section across all concepts |\n| `screenshots` shape | When present: non-empty array, each screenshot has non-empty `src` + `alt` |\n| `carousel` invariant | When `carousel: true`, `screenshots` must be a non-empty array |\n| `code` block shape | When present: non-empty `language` + `content` |\n| `table` shape | When present: non-empty `headers` array + `rows` array |\n| `references` shape | When present: non-empty array, each reference has non-empty `label` + `url` |\n| Released concepts | At least 1 exists; all required fields populated on released concepts |\n| Spot-check: `getting-started` | Exists, `released === true` |\n| Spot-check: `subagents` | Exists, title is \"Subagents\", has \"Creating Your Own Subagent\" section with `carousel: true` and 11 screenshots (>= 10) |\n\n**Intentional gaps:** URL format validation on `references[].url` (would need a regex or URL constructor; the invariant that it's non-empty is sufficient for static data), and `releaseDate` format validation on unreleased concepts (not part of the spec)."
    }
  },
  {
    "timestamp": "2026-02-28T04:55:34.697Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Task",
      "tool_input": {
        "description": "Write unit tests for concepts.ts",
        "prompt": "Write comprehensive unit tests for `src/data/concepts.ts` in the project at `C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app`.\n\nThe file exports:\n- `ConceptCategory` type\n- `Difficulty` type\n- `ConceptSection` interface (with fields: heading, body, bullets?, code?, screenshots?, carousel?, table?)\n- `ConceptReference` interface\n- `Concept` interface\n- `difficultyBadgeStyles` ‚Äî a Record<Difficulty, string> mapping each difficulty to Tailwind classes\n- `ALL_CATEGORIES` ‚Äî array of all ConceptCategory values\n- `concepts` ‚Äî the main array of Concept objects\n\nWrite tests that cover:\n1. `difficultyBadgeStyles` ‚Äî all three difficulty keys exist and have non-empty string values\n2. `ALL_CATEGORIES` ‚Äî contains all 5 expected categories, no duplicates\n3. `concepts` array integrity:\n   - Every concept has a non-empty `slug`, `title`, `emoji`, `category`, `difficulty`, `shortDesc`\n   - Every `slug` is unique across all concepts\n   - Every `category` is one of the valid `ALL_CATEGORIES` values\n   - Every `difficulty` is one of: Beginner, Intermediate, Advanced\n   - Every concept has at least one section\n   - Every section has a non-empty `heading` and `body`\n   - If a section has `screenshots`, each screenshot has non-empty `src` and `alt`\n   - If a section has `carousel: true`, it must also have a `screenshots` array\n   - If a section has `code`, it has non-empty `language` and `content`\n   - If a section has `table`, it has `headers` array and `rows` array\n   - If a concept has `references`, each reference has non-empty `label` and `url`\n   - Released concepts (`released: true`) must have all required fields populated\n4. Specific concept spot-checks:\n   - The `subagents` concept exists, has title \"Subagents\", has a section with heading \"Creating Your Own Subagent\" that has `carousel: true` and 10+ screenshots\n   - The `getting-started` concept exists and is released\n\nUse **Vitest** as the test framework (it's already set up in this Next.js project ‚Äî check `package.json` to confirm). Place the test file at `src/data/concepts.test.ts`.\n\nDo not mock anything ‚Äî these are pure data validation tests. Import directly from `@/data/concepts` or use relative path `../data/concepts` depending on tsconfig setup ‚Äî check the project's `tsconfig.json` to confirm the `@` alias maps to `src/`.\n\nRun the tests after writing them to confirm they all pass. Use `npx vitest run src/data/concepts.test.ts` or check what test script is available in `package.json`.",
        "subagent_type": "unit-test-writer"
      },
      "tool_response": {
        "status": "completed",
        "prompt": "Write comprehensive unit tests for `src/data/concepts.ts` in the project at `C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app`.\n\nThe file exports:\n- `ConceptCategory` type\n- `Difficulty` type\n- `ConceptSection` interface (with fields: heading, body, bullets?, code?, screenshots?, carousel?, table?)\n- `ConceptReference` interface\n- `Concept` interface\n- `difficultyBadgeStyles` ‚Äî a Record<Difficulty, string> mapping each difficulty to Tailwind classes\n- `ALL_CATEGORIES` ‚Äî array of all ConceptCategory values\n- `concepts` ‚Äî the main array of Concept objects\n\nWrite tests that cover:\n1. `difficultyBadgeStyles` ‚Äî all three difficulty keys exist and have non-empty string values\n2. `ALL_CATEGORIES` ‚Äî contains all 5 expected categories, no duplicates\n3. `concepts` array integrity:\n   - Every concept has a non-empty `slug`, `title`, `emoji`, `category`, `difficulty`, `shortDesc`\n   - Every `slug` is unique across all concepts\n   - Every `category` is one of the valid `ALL_CATEGORIES` values\n   - Every `difficulty` is one of: Beginner, Intermediate, Advanced\n   - Every concept has at least one section\n   - Every section has a non-empty `heading` and `body`\n   - If a section has `screenshots`, each screenshot has non-empty `src` and `alt`\n   - If a section has `carousel: true`, it must also have a `screenshots` array\n   - If a section has `code`, it has non-empty `language` and `content`\n   - If a section has `table`, it has `headers` array and `rows` array\n   - If a concept has `references`, each reference has non-empty `label` and `url`\n   - Released concepts (`released: true`) must have all required fields populated\n4. Specific concept spot-checks:\n   - The `subagents` concept exists, has title \"Subagents\", has a section with heading \"Creating Your Own Subagent\" that has `carousel: true` and 10+ screenshots\n   - The `getting-started` concept exists and is released\n\nUse **Vitest** as the test framework (it's already set up in this Next.js project ‚Äî check `package.json` to confirm). Place the test file at `src/data/concepts.test.ts`.\n\nDo not mock anything ‚Äî these are pure data validation tests. Import directly from `@/data/concepts` or use relative path `../data/concepts` depending on tsconfig setup ‚Äî check the project's `tsconfig.json` to confirm the `@` alias maps to `src/`.\n\nRun the tests after writing them to confirm they all pass. Use `npx vitest run src/data/concepts.test.ts` or check what test script is available in `package.json`.",
        "agentId": "a2635fbf76ce6ec82",
        "content": [
          {
            "type": "text",
            "text": "All 626 tests pass. Here is a summary of everything done.\n\n---\n\n## Analysis\n\nThe `src/data/concepts.ts` file exports pure static data ‚Äî no side effects, no async, no dependencies. Key observations:\n\n- **16 concepts** across 5 categories and 3 difficulty levels\n- **Optional fields** on `ConceptSection`: `bullets`, `code`, `screenshots`, `carousel`, `table` ‚Äî each has its own shape invariant to validate\n- **Invariant**: `carousel: true` is only meaningful when `screenshots` is also present (one section has both: `subagents` / \"Creating Your Own Subagent\" with 11 screenshots)\n- **References** appear on 2 concepts: `cli-commands` and `settings-json`\n- **4 unreleased** concepts (`skills`, `worktrees`, `mcp`, `settings`) have `released: false` and a `releaseDate`\n\nVitest was not installed ‚Äî installed it (`vitest@4.0.18`) as a dev dependency. The `@/` alias does not resolve in Vitest without a vite config, so a relative import (`./concepts`) was used.\n\n---\n\n## Test file: `src/data/concepts.test.ts`\n\n626 tests generated, all passing:\n\n```\nTest Files  1 passed (1)\n      Tests  626 passed (626)\n   Duration  281ms\n```\n\n### Coverage Summary\n\n| Area | What is tested |\n|---|---|\n| `difficultyBadgeStyles` | All 3 keys exist, exactly 3 keys, each value is a non-empty string |\n| `ALL_CATEGORIES` | Length is 5, all 5 expected values present, no duplicates |\n| `concepts` array | Non-empty array, all 16 concepts tested individually |\n| Required string fields | `slug`, `title`, `emoji`, `shortDesc` ‚Äî non-empty on every concept |\n| Slug uniqueness | Set size equals array length |\n| Category validity | Every concept's category is in `ALL_CATEGORIES` |\n| Difficulty validity | Every concept's difficulty is one of the 3 valid values |\n| Sections presence | Every concept has at least 1 section |\n| Section `heading` + `body` | Non-empty strings on every section across all concepts |\n| `screenshots` shape | When present: non-empty array, each screenshot has non-empty `src` + `alt` |\n| `carousel` invariant | When `carousel: true`, `screenshots` must be a non-empty array |\n| `code` block shape | When present: non-empty `language` + `content` |\n| `table` shape | When present: non-empty `headers` array + `rows` array |\n| `references` shape | When present: non-empty array, each reference has non-empty `label` + `url` |\n| Released concepts | At least 1 exists; all required fields populated on released concepts |\n| Spot-check: `getting-started` | Exists, `released === true` |\n| Spot-check: `subagents` | Exists, title is \"Subagents\", has \"Creating Your Own Subagent\" section with `carousel: true` and 11 screenshots (>= 10) |\n\n**Intentional gaps:** URL format validation on `references[].url` (would need a regex or URL constructor; the invariant that it's non-empty is sufficient for static data), and `releaseDate` format validation on unreleased concepts (not part of the spec)."
          }
        ],
        "totalDurationMs": 272112,
        "totalTokens": 63149,
        "totalToolUseCount": 20,
        "usage": {
          "input_tokens": 1,
          "cache_creation_input_tokens": 674,
          "cache_read_input_tokens": 61648,
          "output_tokens": 826,
          "server_tool_use": {
            "web_search_requests": 0,
            "web_fetch_requests": 0
          },
          "service_tier": "standard",
          "cache_creation": {
            "ephemeral_1h_input_tokens": 674,
            "ephemeral_5m_input_tokens": 0
          },
          "inference_geo": "",
          "iterations": [],
          "speed": "standard"
        }
      },
      "tool_use_id": "toolu_012AkG2Dc1wm8jSoLpYe6w5R"
    }
  },
  {
    "timestamp": "2026-02-28T04:55:40.438Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "All 626 tests pass. Here's what was generated:\n\n**`src/data/concepts.test.ts`** ‚Äî pure data validation tests using Vitest, covering:\n\n- `difficultyBadgeStyles` ‚Äî all 3 keys exist with non-empty values\n- `ALL_CATEGORIES` ‚Äî 5 unique categories, no duplicates\n- Every concept: unique slugs, valid category/difficulty, non-empty required fields\n- Every section: non-empty `heading` + `body`, correct shapes for `code`, `screenshots`, `table`\n- `carousel: true` sections must also have `screenshots` ‚Äî validates the subagents section\n- Spot-checks: `getting-started` is released, `subagents` has title \"Subagents\" with \"Creating Your Own Subagent\" section carrying `carousel: true` and 11 screenshots\n\nVitest was installed as a dev dependency since it wasn't in the project. Tests run with:\n```\nnpx vitest run src/data/concepts.test.ts\n```"
    }
  },
  {
    "timestamp": "2026-02-28T04:55:42.434Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a5dedcb0070da52e9",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-a5dedcb0070da52e9.jsonl",
      "agent_type": "",
      "last_assistant_message": "commit this"
    }
  },
  {
    "timestamp": "2026-02-28T04:56:40.650Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude is waiting for your input",
      "notification_type": "idle_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T05:09:15.666Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "Add the 3rd section as Sub agent execution and attach the screenshot I have provided into name is subagent execution"
    }
  },
  {
    "timestamp": "2026-02-28T05:09:22.275Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "public/screenshots/subagents/*",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app"
      },
      "tool_response": {
        "filenames": [
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent1.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent2.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent3.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent4.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent5.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent6.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent7.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent8.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent9.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent10.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent11.png",
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\subagents\\Subagent Execution.png"
        ],
        "durationMs": 1146,
        "numFiles": 12,
        "truncated": false
      },
      "tool_use_id": "toolu_01Dv3HL63THRzffshecMCyW2"
    }
  },
  {
    "timestamp": "2026-02-28T05:09:29.439Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "      {\n        heading: \"Creating Your Own Subagent\",",
        "new_string": "      {\n        heading: \"Subagent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Creating Your Own Subagent\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "      {\n        heading: \"Creating Your Own Subagent\",",
        "newString": "      {\n        heading: \"Subagent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Creating Your Own Subagent\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n       \n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1241,
            "oldLines": 6,
            "newStart": 1241,
            "newLines": 13,
            "lines": [
              "         },",
              "       },",
              "       {",
              "+        heading: \"Subagent Execution\",",
              "+        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",",
              "+        screenshots: [",
              "+          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },",
              "+        ],",
              "+      },",
              "+      {",
              "         heading: \"Creating Your Own Subagent\",",
              "         body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",",
              "        "
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_014c4BtS84i8zuzNoGwyk5DS"
    }
  },
  {
    "timestamp": "2026-02-28T05:09:32.505Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Section 3 \"Subagent Execution\" is now inserted between \"Subagent Types in Claude Code\" and \"Creating Your Own Subagent\", with `Subagent Execution.png` attached as a single screenshot (non-carousel, just the standard lightbox viewer)."
    }
  },
  {
    "timestamp": "2026-02-28T05:09:34.323Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a3fd925e07f8d9f59",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-a3fd925e07f8d9f59.jsonl",
      "agent_type": "",
      "last_assistant_message": "now update the unit tests"
    }
  },
  {
    "timestamp": "2026-02-28T05:10:20.909Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "Make creating your own sub agent section as 3rd section and sub agent execution as 4th section and on both the agent A capital"
    }
  },
  {
    "timestamp": "2026-02-28T05:10:26.264Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "        heading: \"Subagent Execution\",",
        "new_string": "        heading: \"SubAgent Execution\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "        heading: \"Subagent Execution\",",
        "newString": "        heading: \"SubAgent Execution\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Subagent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n       \n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1241,
            "oldLines": 7,
            "newStart": 1241,
            "newLines": 7,
            "lines": [
              "         },",
              "       },",
              "       {",
              "-        heading: \"Subagent Execution\",",
              "+        heading: \"SubAgent Execution\",",
              "         body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",",
              "         screenshots: [",
              "           { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01LxQXHErBUF7KPDNgAVidu9"
    }
  },
  {
    "timestamp": "2026-02-28T05:10:29.400Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1242,
        "limit": 45
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n       \n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },",
          "numLines": 45,
          "startLine": 1242,
          "totalLines": 1880
        }
      },
      "tool_use_id": "toolu_01141T9ZcLJg9yKT74paesFW"
    }
  },
  {
    "timestamp": "2026-02-28T05:10:40.875Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n       \n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },",
        "new_string": "      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n       \n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },",
        "newString": "      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"Subagents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Creating Your Own Subagent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n       \n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation\",\n        body: \"Subagents can run in isolated git worktrees ‚Äî temporary branches where they can make changes without affecting the main working directory. Useful for exploratory code changes that may or may not be kept.\",\n        code: {\n          language: \"text\",\n          content: `# Subagent with git worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try refactoring the auth module and see if tests pass\"\n)\n# Claude creates a temporary branch, subagent makes changes\n# If changes are good ‚Üí merge; if not ‚Üí discard\n# Main working directory stays clean throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1241,
            "oldLines": 16,
            "newStart": 1241,
            "newLines": 8,
            "lines": [
              "         },",
              "       },",
              "       {",
              "-        heading: \"SubAgent Execution\",",
              "-        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",",
              "-        screenshots: [",
              "-          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"Subagent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },",
              "-        ],",
              "-      },",
              "-      {",
              "-        heading: \"Creating Your Own Subagent\",",
              "+        heading: \"Creating Your Own SubAgent\",",
              "         body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",",
              "-       ",
              "         carousel: true,",
              "         screenshots: [",
              "           { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },"
            ]
          },
          {
            "oldStart": 1263,
            "oldLines": 10,
            "newStart": 1255,
            "newLines": 17,
            "lines": [
              "           { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },",
              "           { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },",
              "           { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },",
              "-           { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },",
              "+          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },",
              "         ],",
              "       },",
              "       {",
              "+        heading: \"SubAgent Execution\",",
              "+        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",",
              "+        screenshots: [",
              "+          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },",
              "+        ],",
              "+      },",
              "+      {",
              "         heading: \"Parallel Execution\",",
              "         body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",",
              "         code: {"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01RakFeHCn2Hor6uX1t3H6iE"
    }
  },
  {
    "timestamp": "2026-02-28T05:10:44.285Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Section order is now:\n1. Overview\n2. SubAgent Types in Claude Code\n3. **Creating Your Own SubAgent** (carousel)\n4. **SubAgent Execution** (single screenshot)\n5. Parallel Execution\n6. Worktree Isolation\n7. Tips\n\nBoth headings now use capital A ‚Äî \"SubAgent\"."
    }
  },
  {
    "timestamp": "2026-02-28T05:10:46.181Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "afcc20a71d3bea3cf",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-afcc20a71d3bea3cf.jsonl",
      "agent_type": "",
      "last_assistant_message": "update the unit tests to reflect the changes"
    }
  },
  {
    "timestamp": "2026-02-28T05:18:12.811Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "Can you create a skill file for committing the code I think you can just follow the same example that you have provided in the skills section"
    }
  },
  {
    "timestamp": "2026-02-28T05:18:21.558Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": ".claude/skills/*",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app"
      },
      "tool_response": {
        "filenames": [],
        "durationMs": 1082,
        "numFiles": 0,
        "truncated": false
      },
      "tool_use_id": "toolu_01D7LscfDBUWZDfYK7EZwDP1"
    }
  },
  {
    "timestamp": "2026-02-28T05:18:35.907Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "mkdir -p \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\"",
        "description": "Create .claude/skills directory"
      },
      "tool_response": {
        "stdout": "",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": true
      },
      "tool_use_id": "toolu_01R84MYyPEDJVrz4b2WbUbTH"
    }
  },
  {
    "timestamp": "2026-02-28T05:18:47.707Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Write",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T05:18:55.594Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Write",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\\commit.md",
        "content": "Create a git commit following these steps:\n\n1. Run `git status` to see all changes\n2. Run `git diff` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\n"
      },
      "tool_response": {
        "type": "create",
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\\commit.md",
        "content": "Create a git commit following these steps:\n\n1. Run `git status` to see all changes\n2. Run `git diff` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\n",
        "structuredPatch": [],
        "originalFile": null
      },
      "tool_use_id": "toolu_01GSYKuLgG596aghYMged5J7"
    }
  },
  {
    "timestamp": "2026-02-28T05:18:58.471Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Created `.claude/skills/commit.md`. You can now invoke it inside any Claude Code session with:\n\n```\n/commit\n```"
    }
  },
  {
    "timestamp": "2026-02-28T05:19:00.870Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a5e9aeed455f64a1a",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-a5e9aeed455f64a1a.jsonl",
      "agent_type": "",
      "last_assistant_message": "now update the unit tests to reflect the changes"
    }
  },
  {
    "timestamp": "2026-02-28T05:19:58.662Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude is waiting for your input",
      "notification_type": "idle_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T05:23:54.199Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude is waiting for your input",
      "notification_type": "idle_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T05:24:05.561Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "add the image in section 2 skill.png"
    }
  },
  {
    "timestamp": "2026-02-28T05:24:10.043Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "public/screenshots/skills/*",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app"
      },
      "tool_response": {
        "filenames": [
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\skills\\Skill.png"
        ],
        "durationMs": 1217,
        "numFiles": 1,
        "truncated": false
      },
      "tool_use_id": "toolu_01JT1qcyM8FGYe84xvTdvFWL"
    }
  },
  {
    "timestamp": "2026-02-28T05:24:13.445Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1496,
        "limit": 35
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "cat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },",
          "numLines": 35,
          "startLine": 1496,
          "totalLines": 1864
        }
      },
      "tool_use_id": "toolu_01Vtr4W3XLxgjuemdJ3HtvL9"
    }
  },
  {
    "timestamp": "2026-02-28T05:24:19.553Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "        },\n      },\n      {\n        heading: \"Using Skills\",",
        "new_string": "        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Using Skills\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "        },\n      },\n      {\n        heading: \"Using Skills\",",
        "newString": "        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Using Skills\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1510,
            "oldLines": 6,
            "newStart": 1510,
            "newLines": 9,
            "lines": [
              " claude",
              " > /commit`,",
              "         },",
              "+        screenshots: [",
              "+          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },",
              "+        ],",
              "       },",
              "       {",
              "         heading: \"Using Skills\","
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01Xa5CAcLemt2HoQCPxnUcQ2"
    }
  },
  {
    "timestamp": "2026-02-28T05:24:22.128Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "`Skill.png` added to the \"Creating a Skill\" section (section 2) of the Skills concept."
    }
  },
  {
    "timestamp": "2026-02-28T05:24:23.899Z",
    "payload": {
      "session_id": "55b3b9d5-ec8a-4314-ac68-0e4ca770fc32",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "acceptEdits",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a22fed6c041bcde0c",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\55b3b9d5-ec8a-4314-ac68-0e4ca770fc32\\subagents\\agent-a22fed6c041bcde0c.jsonl",
      "agent_type": "",
      "last_assistant_message": "commit this"
    }
  },
  {
    "timestamp": "2026-02-28T05:25:09.184Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionStart",
      "source": "startup",
      "model": "claude-sonnet-4-6"
    }
  },
  {
    "timestamp": "2026-02-28T05:26:18.974Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "i have created a skill called commit.md how to execute it"
    }
  },
  {
    "timestamp": "2026-02-28T05:26:22.922Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": ".claude/skills/**"
      },
      "tool_response": {
        "filenames": [
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\\commit.md"
        ],
        "durationMs": 1114,
        "numFiles": 1,
        "truncated": false
      },
      "tool_use_id": "toolu_01RXcJf7H4LLToDhU5LQjzp1"
    }
  },
  {
    "timestamp": "2026-02-28T05:26:26.143Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "To execute your `commit.md` skill, type:\n\n```\n/commit\n```\n\nClaude Code automatically maps skill files to slash commands ‚Äî the filename (without `.md`) becomes the command name. So `.claude/skills/commit.md` ‚Üí `/commit`.\n\n**Note:** The skill must be inside `.claude/skills/` relative to your project root, which it is. Just type `/commit` in the chat and it will expand and run your skill's instructions."
    }
  },
  {
    "timestamp": "2026-02-28T05:26:29.896Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "aeed2eed701ca7ea7",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10\\subagents\\agent-aeed2eed701ca7ea7.jsonl",
      "agent_type": "",
      "last_assistant_message": "/commit"
    }
  },
  {
    "timestamp": "2026-02-28T05:29:43.176Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "---\nname: nextjs-commit\ndescription: >\n  Generates clean, conventional Git commit messages and handles the full commit\n  workflow for Next.js projects. Use this skill whenever the user wants to commit\n  code, stage files, write a commit message, or wrap up a feature/fix ‚Äî even if\n  they just say \"commit this\", \"let's commit\", or \"what should my commit message be\".\n---\n\n# Next.js Commit Skill\n\nAutomates and standardizes the Git commit workflow for Next.js projects using **Conventional Commits** format, with awareness of Next.js-specific file patterns.\n\n---\n\n## Commit Message Format\n\n```\n<type>(<scope>): <short summary>\n\n[optional body]\n\n[optional footer]\n```\n\n### Types\n\n| Type       | When to use                                                    |\n|------------|----------------------------------------------------------------|\n| `feat`     | New page, route, component, or feature                        |\n| `fix`      | Bug fix in logic, layout, or API route                        |\n| `chore`    | Config changes, dependency updates, `next.config.js` edits    |\n| `style`    | CSS/Tailwind changes, no logic change                         |\n| `refactor` | Restructuring components, moving to Server Components, etc.   |\n| `perf`     | Improving rendering strategy, caching, image optimization     |\n| `test`     | Adding or updating tests (Jest, Playwright, Vitest)           |\n| `docs`     | README, JSDoc, inline comments                                |\n| `ci`       | GitHub Actions, Vercel config, deployment pipeline            |\n| `revert`   | Reverting a previous commit                                   |\n\n### Scopes (Next.js-aware)\n\n| Scope        | Area                                          |\n|--------------|-----------------------------------------------|\n| `app`        | App Router pages/layouts                      |\n| `pages`      | Pages Router (if used)                        |\n| `api`        | Route handlers / API routes                   |\n| `components` | Shared UI components                          |\n| `auth`       | Authentication (NextAuth, Clerk, etc.)        |\n| `db`         | Database / Prisma schema or queries           |\n| `middleware` | `middleware.ts`                               |\n| `config`     | `next.config.js`, `tsconfig.json`, env files  |\n| `styles`     | Global CSS, Tailwind config                   |\n\n---\n\n## Workflow\n\n### Step 1 ‚Äî Understand what changed\n\n```bash\ngit status\ngit diff --staged   # if files already staged\ngit diff            # if files not yet staged\n```\n\nIdentify which files changed and what logical group they belong to.\n\n### Step 2 ‚Äî Stage files intentionally\n\nDo not blindly `git add .` unless all changes belong to one logical commit.\n\n```bash\n# Focused staging\ngit add app/dashboard/page.tsx components/charts/BarChart.tsx\n\n# All related changes\ngit add .\n```\n\nIf there are unrelated changes mixed together, split into multiple commits.\n\n### Step 3 ‚Äî Write the commit message\n\n- Summary line: **50 chars or less**, imperative mood (\"add\" not \"added\")\n- No period at end of summary line\n- Body: wrap at 72 chars, explain *why* not *what*\n- Reference issues if known: `Closes #42`\n\n**Next.js-specific tips:**\n- Mention if a component moved from Client ‚Üí Server Component or vice versa\n- Note caching strategy changes (`force-cache`, `no-store`, `revalidate`)\n- Flag any breaking changes to route structure\n\n### Step 4 ‚Äî Commit\n\n```bash\n# Single line\ngit commit -m \"<type>(<scope>): <summary>\"\n\n# Multi-line\ngit commit -m \"<type>(<scope>): <summary>\" -m \"<body>\"\n```\n\n### Step 5 ‚Äî Verify\n\n```bash\ngit log --oneline -5\n```\n\n---\n\n## Examples\n\n**New feature:**\n```\nfeat(app): add /dashboard/analytics page with server-side data fetching\n```\n\n**Bug fix with body:**\n```\nfix(api): handle missing session in /api/user route\n\nPreviously the route threw 500 when session was undefined.\nAdded early return with 401 response.\n\nCloses #88\n```\n\n**Refactor to Server Component:**\n```\nrefactor(components): convert ProductList to Server Component\n\nRemoves useEffect data fetch in favor of async RSC with Prisma query.\nReduces client bundle size and improves TTFB.\n```\n\n**Dependency update:**\n```\nchore(config): upgrade Next.js to 15.1.0\n```\n\n**Tailwind styling:**\n```\nstyle(components): update Button hover states and spacing\n```\n\n---\n\n## Rules to Always Follow\n\n- One logical change per commit ‚Äî don't bundle unrelated work\n- Never commit `.env.local` or secrets\n- Always run `next build` locally before committing if changing config or data fetching logic\n- If unsure about scope, use the folder name where most changes live consider this and create a skill file for our project"
    }
  },
  {
    "timestamp": "2026-02-28T05:29:52.299Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": ".claude/skills/*"
      },
      "tool_response": {
        "filenames": [
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\\commit.md"
        ],
        "durationMs": 1116,
        "numFiles": 1,
        "truncated": false
      },
      "tool_use_id": "toolu_011iUixa6SU6TTNBVUqfVqZo"
    }
  },
  {
    "timestamp": "2026-02-28T05:29:54.418Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\\commit.md"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\\commit.md",
          "content": "Create a git commit following these steps:\n\n1. Run `git status` to see all changes\n2. Run `git diff` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Mohanaprasad\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\n",
          "numLines": 11,
          "startLine": 1,
          "totalLines": 11
        }
      },
      "tool_use_id": "toolu_014zgRGDKBed2UJhDsh1T3BD"
    }
  },
  {
    "timestamp": "2026-02-28T05:30:24.829Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Write",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\\commit.md",
        "content": "---\nname: nextjs-commit\ndescription: >\n  Generates clean, conventional Git commit messages and handles the full commit\n  workflow for this Next.js project. Use whenever the user wants to commit\n  code, stage files, write a commit message, or wrap up a feature/fix ‚Äî even if\n  they just say \"commit this\", \"let's commit\", or \"what should my commit message be\".\n---\n\n# Next.js Commit Skill\n\nAutomates and standardizes the Git commit workflow using **Conventional Commits** format, with awareness of this project's file structure.\n\n---\n\n## Commit Message Format\n\n```\n<type>(<scope>): <short summary>\n\n[optional body]\n\n[optional footer]\n```\n\n### Types\n\n| Type       | When to use                                                    |\n|------------|----------------------------------------------------------------|\n| `feat`     | New page, route, component, or feature                        |\n| `fix`      | Bug fix in logic, layout, or API route                        |\n| `chore`    | Config changes, dependency updates, `next.config.js` edits    |\n| `style`    | CSS/Tailwind changes, no logic change                         |\n| `refactor` | Restructuring components, moving to Server Components, etc.   |\n| `perf`     | Improving rendering strategy, caching, image optimization     |\n| `test`     | Adding or updating tests                                      |\n| `docs`     | README, JSDoc, inline comments                                |\n| `ci`       | GitHub Actions, Vercel config, deployment pipeline            |\n| `revert`   | Reverting a previous commit                                   |\n\n### Scopes (project-aware)\n\n| Scope        | Area                                                      |\n|--------------|-----------------------------------------------------------|\n| `app`        | App Router pages/layouts (`src/app/`)                     |\n| `concepts`   | Concept data or concept pages (`src/data/concepts.ts`)    |\n| `components` | Shared UI components (`src/components/`)                  |\n| `actions`    | Server actions (`src/app/actions/`)                       |\n| `auth`       | Auth flow (Supabase, login/signup, proxy)                 |\n| `db`         | Prisma schema or queries                                  |\n| `proxy`      | `src/proxy.ts` (Next.js 16 middleware replacement)        |\n| `config`     | `next.config.ts`, `tsconfig.json`, `prisma.config.ts`     |\n| `styles`     | Global CSS, Tailwind config                               |\n| `skills`     | `.claude/skills/` changes                                 |\n| `memory`     | `.claude/agent-memory/` or memory files                   |\n\n---\n\n## Workflow\n\n### Step 1 ‚Äî Understand what changed\n\n```bash\ngit status\ngit diff --staged   # if files already staged\ngit diff            # if files not yet staged\n```\n\nIdentify which files changed and what logical group they belong to.\n\n### Step 2 ‚Äî Stage files intentionally\n\nDo not blindly `git add .` unless all changes belong to one logical commit.\n\n```bash\n# Focused staging\ngit add src/app/concepts/[slug]/page.tsx src/data/concepts.ts\n\n# All related changes\ngit add .\n```\n\nIf there are unrelated changes mixed together, split into multiple commits.\n\n### Step 3 ‚Äî Write the commit message\n\n- Summary line: **72 chars or less**, imperative mood (\"add\" not \"added\")\n- No period at end of summary line\n- Body: wrap at 72 chars, explain *why* not *what*\n- Reference issues if known: `Closes #42`\n\n**Project-specific tips:**\n- Mention if a concept section was added/updated in `src/data/concepts.ts`\n- Note if screenshots folder was created under `public/screenshots/`\n- Flag any Prisma schema changes that require `prisma db push`\n- Mention if a component moved from Client ‚Üí Server Component\n\n### Step 4 ‚Äî Commit\n\nUse a heredoc to preserve formatting:\n\n```bash\ngit commit -m \"$(cat <<'EOF'\n<type>(<scope>): <summary>\n\n<optional body>\n\nCo-Authored-By: Mohanaprasad\nEOF\n)\"\n```\n\n### Step 5 ‚Äî Verify\n\n```bash\ngit log --oneline -5\ngit status\n```\n\n---\n\n## Examples\n\n**New concept added:**\n```\nfeat(concepts): add hooks concept with sections and screenshots\n```\n\n**Bug fix with body:**\n```\nfix(auth): handle missing session in proxy redirect\n\nPreviously unauthenticated users hit a 500 instead of being\nredirected to /login. Added null check in src/proxy.ts.\n```\n\n**Concept data update:**\n```\nfeat(concepts): add subagents section to claude-code concept\n```\n\n**Prisma schema change:**\n```\nfeat(db): add views column to Concept model\n\nRequires prisma db push + prisma generate after deploy.\n```\n\n**Tailwind styling:**\n```\nstyle(components): update ConceptCard hover states and spacing\n```\n\n**Skill file update:**\n```\nchore(skills): improve commit skill with project-specific scopes\n```\n\n---\n\n## Rules to Always Follow\n\n- One logical change per commit ‚Äî don't bundle unrelated work\n- Never commit `.env`, `.env.local`, or any secrets\n- Always include `Co-Authored-By: Mohanaprasad` in the footer\n- If Prisma schema changed, note that `prisma db push` is required\n- If unsure about scope, use the folder name where most changes live\n"
      },
      "tool_response": {
        "type": "update",
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\skills\\commit.md",
        "content": "---\nname: nextjs-commit\ndescription: >\n  Generates clean, conventional Git commit messages and handles the full commit\n  workflow for this Next.js project. Use whenever the user wants to commit\n  code, stage files, write a commit message, or wrap up a feature/fix ‚Äî even if\n  they just say \"commit this\", \"let's commit\", or \"what should my commit message be\".\n---\n\n# Next.js Commit Skill\n\nAutomates and standardizes the Git commit workflow using **Conventional Commits** format, with awareness of this project's file structure.\n\n---\n\n## Commit Message Format\n\n```\n<type>(<scope>): <short summary>\n\n[optional body]\n\n[optional footer]\n```\n\n### Types\n\n| Type       | When to use                                                    |\n|------------|----------------------------------------------------------------|\n| `feat`     | New page, route, component, or feature                        |\n| `fix`      | Bug fix in logic, layout, or API route                        |\n| `chore`    | Config changes, dependency updates, `next.config.js` edits    |\n| `style`    | CSS/Tailwind changes, no logic change                         |\n| `refactor` | Restructuring components, moving to Server Components, etc.   |\n| `perf`     | Improving rendering strategy, caching, image optimization     |\n| `test`     | Adding or updating tests                                      |\n| `docs`     | README, JSDoc, inline comments                                |\n| `ci`       | GitHub Actions, Vercel config, deployment pipeline            |\n| `revert`   | Reverting a previous commit                                   |\n\n### Scopes (project-aware)\n\n| Scope        | Area                                                      |\n|--------------|-----------------------------------------------------------|\n| `app`        | App Router pages/layouts (`src/app/`)                     |\n| `concepts`   | Concept data or concept pages (`src/data/concepts.ts`)    |\n| `components` | Shared UI components (`src/components/`)                  |\n| `actions`    | Server actions (`src/app/actions/`)                       |\n| `auth`       | Auth flow (Supabase, login/signup, proxy)                 |\n| `db`         | Prisma schema or queries                                  |\n| `proxy`      | `src/proxy.ts` (Next.js 16 middleware replacement)        |\n| `config`     | `next.config.ts`, `tsconfig.json`, `prisma.config.ts`     |\n| `styles`     | Global CSS, Tailwind config                               |\n| `skills`     | `.claude/skills/` changes                                 |\n| `memory`     | `.claude/agent-memory/` or memory files                   |\n\n---\n\n## Workflow\n\n### Step 1 ‚Äî Understand what changed\n\n```bash\ngit status\ngit diff --staged   # if files already staged\ngit diff            # if files not yet staged\n```\n\nIdentify which files changed and what logical group they belong to.\n\n### Step 2 ‚Äî Stage files intentionally\n\nDo not blindly `git add .` unless all changes belong to one logical commit.\n\n```bash\n# Focused staging\ngit add src/app/concepts/[slug]/page.tsx src/data/concepts.ts\n\n# All related changes\ngit add .\n```\n\nIf there are unrelated changes mixed together, split into multiple commits.\n\n### Step 3 ‚Äî Write the commit message\n\n- Summary line: **72 chars or less**, imperative mood (\"add\" not \"added\")\n- No period at end of summary line\n- Body: wrap at 72 chars, explain *why* not *what*\n- Reference issues if known: `Closes #42`\n\n**Project-specific tips:**\n- Mention if a concept section was added/updated in `src/data/concepts.ts`\n- Note if screenshots folder was created under `public/screenshots/`\n- Flag any Prisma schema changes that require `prisma db push`\n- Mention if a component moved from Client ‚Üí Server Component\n\n### Step 4 ‚Äî Commit\n\nUse a heredoc to preserve formatting:\n\n```bash\ngit commit -m \"$(cat <<'EOF'\n<type>(<scope>): <summary>\n\n<optional body>\n\nCo-Authored-By: Mohanaprasad\nEOF\n)\"\n```\n\n### Step 5 ‚Äî Verify\n\n```bash\ngit log --oneline -5\ngit status\n```\n\n---\n\n## Examples\n\n**New concept added:**\n```\nfeat(concepts): add hooks concept with sections and screenshots\n```\n\n**Bug fix with body:**\n```\nfix(auth): handle missing session in proxy redirect\n\nPreviously unauthenticated users hit a 500 instead of being\nredirected to /login. Added null check in src/proxy.ts.\n```\n\n**Concept data update:**\n```\nfeat(concepts): add subagents section to claude-code concept\n```\n\n**Prisma schema change:**\n```\nfeat(db): add views column to Concept model\n\nRequires prisma db push + prisma generate after deploy.\n```\n\n**Tailwind styling:**\n```\nstyle(components): update ConceptCard hover states and spacing\n```\n\n**Skill file update:**\n```\nchore(skills): improve commit skill with project-specific scopes\n```\n\n---\n\n## Rules to Always Follow\n\n- One logical change per commit ‚Äî don't bundle unrelated work\n- Never commit `.env`, `.env.local`, or any secrets\n- Always include `Co-Authored-By: Mohanaprasad` in the footer\n- If Prisma schema changed, note that `prisma db push` is required\n- If unsure about scope, use the folder name where most changes live\n",
        "structuredPatch": [
          {
            "oldStart": 1,
            "oldLines": 10,
            "newStart": 1,
            "newLines": 167,
            "lines": [
              "-Create a git commit following these steps:",
              "+---",
              "+name: nextjs-commit",
              "+description: >",
              "+  Generates clean, conventional Git commit messages and handles the full commit",
              "+  workflow for this Next.js project. Use whenever the user wants to commit",
              "+  code, stage files, write a commit message, or wrap up a feature/fix ‚Äî even if",
              "+  they just say \"commit this\", \"let's commit\", or \"what should my commit message be\".",
              "+---",
              " ",
              "-1. Run `git status` to see all changes",
              "-2. Run `git diff` to review what changed",
              "-3. Write a commit message in this format:",
              "-   - First line: imperative mood, under 72 chars",
              "-   - Body: explain WHY not WHAT",
              "-   - Footer: Co-Authored-By: Mohanaprasad",
              "-4. Stage appropriate files (never .env or secrets)",
              "-5. Commit and verify with git status",
              "+# Next.js Commit Skill",
              "+",
              "+Automates and standardizes the Git commit workflow using **Conventional Commits** format, with awareness of this project's file structure.",
              "+",
              "+---",
              "+",
              "+## Commit Message Format",
              "+",
              "+```",
              "+<type>(<scope>): <short summary>",
              "+",
              "+[optional body]",
              "+",
              "+[optional footer]",
              "+```",
              "+",
              "+### Types",
              "+",
              "+| Type       | When to use                                                    |",
              "+|------------|----------------------------------------------------------------|",
              "+| `feat`     | New page, route, component, or feature                        |",
              "+| `fix`      | Bug fix in logic, layout, or API route                        |",
              "+| `chore`    | Config changes, dependency updates, `next.config.js` edits    |",
              "+| `style`    | CSS/Tailwind changes, no logic change                         |",
              "+| `refactor` | Restructuring components, moving to Server Components, etc.   |",
              "+| `perf`     | Improving rendering strategy, caching, image optimization     |",
              "+| `test`     | Adding or updating tests                                      |",
              "+| `docs`     | README, JSDoc, inline comments                                |",
              "+| `ci`       | GitHub Actions, Vercel config, deployment pipeline            |",
              "+| `revert`   | Reverting a previous commit                                   |",
              "+",
              "+### Scopes (project-aware)",
              "+",
              "+| Scope        | Area                                                      |",
              "+|--------------|-----------------------------------------------------------|",
              "+| `app`        | App Router pages/layouts (`src/app/`)                     |",
              "+| `concepts`   | Concept data or concept pages (`src/data/concepts.ts`)    |",
              "+| `components` | Shared UI components (`src/components/`)                  |",
              "+| `actions`    | Server actions (`src/app/actions/`)                       |",
              "+| `auth`       | Auth flow (Supabase, login/signup, proxy)                 |",
              "+| `db`         | Prisma schema or queries                                  |",
              "+| `proxy`      | `src/proxy.ts` (Next.js 16 middleware replacement)        |",
              "+| `config`     | `next.config.ts`, `tsconfig.json`, `prisma.config.ts`     |",
              "+| `styles`     | Global CSS, Tailwind config                               |",
              "+| `skills`     | `.claude/skills/` changes                                 |",
              "+| `memory`     | `.claude/agent-memory/` or memory files                   |",
              "+",
              "+---",
              "+",
              "+## Workflow",
              "+",
              "+### Step 1 ‚Äî Understand what changed",
              "+",
              "+```bash",
              "+git status",
              "+git diff --staged   # if files already staged",
              "+git diff            # if files not yet staged",
              "+```",
              "+",
              "+Identify which files changed and what logical group they belong to.",
              "+",
              "+### Step 2 ‚Äî Stage files intentionally",
              "+",
              "+Do not blindly `git add .` unless all changes belong to one logical commit.",
              "+",
              "+```bash",
              "+# Focused staging",
              "+git add src/app/concepts/[slug]/page.tsx src/data/concepts.ts",
              "+",
              "+# All related changes",
              "+git add .",
              "+```",
              "+",
              "+If there are unrelated changes mixed together, split into multiple commits.",
              "+",
              "+### Step 3 ‚Äî Write the commit message",
              "+",
              "+- Summary line: **72 chars or less**, imperative mood (\"add\" not \"added\")",
              "+- No period at end of summary line",
              "+- Body: wrap at 72 chars, explain *why* not *what*",
              "+- Reference issues if known: `Closes #42`",
              "+",
              "+**Project-specific tips:**",
              "+- Mention if a concept section was added/updated in `src/data/concepts.ts`",
              "+- Note if screenshots folder was created under `public/screenshots/`",
              "+- Flag any Prisma schema changes that require `prisma db push`",
              "+- Mention if a component moved from Client ‚Üí Server Component",
              "+",
              "+### Step 4 ‚Äî Commit",
              "+",
              "+Use a heredoc to preserve formatting:",
              "+",
              "+```bash",
              "+git commit -m \"$(cat <<'EOF'",
              "+<type>(<scope>): <summary>",
              "+",
              "+<optional body>",
              "+",
              "+Co-Authored-By: Mohanaprasad",
              "+EOF",
              "+)\"",
              "+```",
              "+",
              "+### Step 5 ‚Äî Verify",
              "+",
              "+```bash",
              "+git log --oneline -5",
              "+git status",
              "+```",
              "+",
              "+---",
              "+",
              "+## Examples",
              "+",
              "+**New concept added:**",
              "+```",
              "+feat(concepts): add hooks concept with sections and screenshots",
              "+```",
              "+",
              "+**Bug fix with body:**",
              "+```",
              "+fix(auth): handle missing session in proxy redirect",
              "+",
              "+Previously unauthenticated users hit a 500 instead of being",
              "+redirected to /login. Added null check in src/proxy.ts.",
              "+```",
              "+",
              "+**Concept data update:**",
              "+```",
              "+feat(concepts): add subagents section to claude-code concept",
              "+```",
              "+",
              "+**Prisma schema change:**",
              "+```",
              "+feat(db): add views column to Concept model",
              "+",
              "+Requires prisma db push + prisma generate after deploy.",
              "+```",
              "+",
              "+**Tailwind styling:**",
              "+```",
              "+style(components): update ConceptCard hover states and spacing",
              "+```",
              "+",
              "+**Skill file update:**",
              "+```",
              "+chore(skills): improve commit skill with project-specific scopes",
              "+```",
              "+",
              "+---",
              "+",
              "+## Rules to Always Follow",
              "+",
              "+- One logical change per commit ‚Äî don't bundle unrelated work",
              "+- Never commit `.env`, `.env.local`, or any secrets",
              "+- Always include `Co-Authored-By: Mohanaprasad` in the footer",
              "+- If Prisma schema changed, note that `prisma db push` is required",
              "+- If unsure about scope, use the folder name where most changes live"
            ]
          }
        ],
        "originalFile": "Create a git commit following these steps:\n\n1. Run `git status` to see all changes\n2. Run `git diff` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Mohanaprasad\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\n"
      },
      "tool_use_id": "toolu_01QrtzY33otHNAbGUFM8BZ2E"
    }
  },
  {
    "timestamp": "2026-02-28T05:30:29.454Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Your `/commit` skill now includes:\n\n- **Project-specific scopes** ‚Äî `concepts`, `actions`, `proxy`, `skills`, `memory` mapped to your actual folder structure\n- **Conventional Commits** format with types table\n- **Heredoc commit template** with `Co-Authored-By: Mohanaprasad` footer baked in\n- **Project tips** ‚Äî reminds about `prisma db push`, screenshot folders, and Server Component migrations\n- **Examples** drawn from your actual codebase patterns\n\nUse `/commit` anytime you want to commit and it will follow this workflow automatically."
    }
  },
  {
    "timestamp": "2026-02-28T05:30:32.788Z",
    "payload": {
      "session_id": "63b3e240-1f4b-497c-9435-b69cf8c59c10",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "ac96498c4c23c6a66",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\63b3e240-1f4b-497c-9435-b69cf8c59c10\\subagents\\agent-ac96498c4c23c6a66.jsonl",
      "agent_type": "",
      "last_assistant_message": "/commit"
    }
  },
  {
    "timestamp": "2026-02-28T05:33:35.308Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionStart",
      "source": "startup",
      "model": "claude-sonnet-4-6"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:21.996Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "Can you create for performance optimization for our web application"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:26.343Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "limit": 80
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",",
          "numLines": 80,
          "startLine": 1,
          "totalLines": 1867
        }
      },
      "tool_use_id": "toolu_01FFihh53EagzkTXHtDSPser"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:30.436Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "grep -n \"slug:\" \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts\" | tail -20"
      },
      "tool_response": {
        "stdout": "36:  slug: string;\n64:    slug: \"getting-started\",\n127:    slug: \"claude-md\",\n193:    slug: \"cli-commands\",\n328:    slug: \"keyboard-shortcuts\",\n446:    slug: \"permission-modes\",\n542:    slug: \"settings-json\",\n651:    slug: \"plan-vs-think-mode\",\n774:    slug: \"tool-use\",\n843:    slug: \"extended-thinking\",\n907:    slug: \"auto-memory\",\n1022:    slug: \"context-management\",\n1112:    slug: \"prompt-caching\",\n1209:    slug: \"subagents\",\n1294:    slug: \"hooks\",\n1474:    slug: \"skills\",\n1567:    slug: \"worktrees\",\n1654:    slug: \"mcp\",\n1757:    slug: \"settings\",",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_0143cV3D9EDijzSmVZ3bVL5F"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:32.973Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1757,
        "limit": 60
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"",
          "numLines": 60,
          "startLine": 1757,
          "totalLines": 1867
        }
      },
      "tool_use_id": "toolu_019h4fduPaEbKFvzwTAsz1QZ"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:35.785Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "wc -l \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts\""
      },
      "tool_response": {
        "stdout": "1866 C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_016fxeKa9fYMSkL63cQnEabi"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:39.346Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1840,
        "limit": 26
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },",
          "numLines": 26,
          "startLine": 1840,
          "totalLines": 1867
        }
      },
      "tool_use_id": "toolu_01AZJHHQor5Ny1L2XgauWD2i"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:51.950Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "Can you create a skill for performance optimization for our web application"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:56.694Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": ".claude/agents/**/*",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app"
      },
      "tool_response": {
        "filenames": [
          "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\agents\\unit-test-writer.md"
        ],
        "durationMs": 1076,
        "numFiles": 1,
        "truncated": false
      },
      "tool_use_id": "toolu_01TzbowtnkM8rumqK32q5cdr"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:56.737Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "ls \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude/\""
      },
      "tool_response": {
        "stdout": "agent-memory\nagents\ncommands\nsettings.json\nsettings.local.json",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01CfAmKPGfpwGDxyowZfQW8S"
    }
  },
  {
    "timestamp": "2026-02-28T05:34:57.203Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": ".claude/skills/**/*",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app"
      },
      "tool_response": {
        "filenames": [],
        "durationMs": 970,
        "numFiles": 0,
        "truncated": false
      },
      "tool_use_id": "toolu_01GpJk4jr4Weo892gXMfD2AG"
    }
  },
  {
    "timestamp": "2026-02-28T05:35:00.024Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "ls \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude/commands/\""
      },
      "tool_response": {
        "stdout": "audit.md",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01Rq8DVL28pMy3HpaD1xYJSr"
    }
  },
  {
    "timestamp": "2026-02-28T05:35:00.451Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\agents\\unit-test-writer.md"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\agents\\unit-test-writer.md",
          "content": "---\nname: unit-test-writer\ndescription: \"Use this agent when a developer has written new code or modified existing code and needs comprehensive unit tests written for it. This agent should be triggered after meaningful implementation work is complete ‚Äî new functions, classes, modules, or bug fixes that lack test coverage.\\\\n\\\\n<example>\\\\nContext: The user asks for a utility function to be written, and it gets implemented.\\\\nuser: \\\"Write a function that parses a date string into a Date object with timezone support\\\"\\\\nassistant: \\\"Here is the implementation in src/lib/dateParser.ts:\\\"\\\\n<function call omitted for brevity>\\\\n<commentary>\\\\nA non-trivial utility function was just written. Use the Task tool to launch the unit-test-writer agent to generate comprehensive tests for it.\\\\n</commentary>\\\\nassistant: \\\"Now let me use the unit-test-writer agent to write comprehensive tests for this function.\\\"\\\\n</example>\\\\n\\\\n<example>\\\\nContext: A bug was fixed in an existing module.\\\\nuser: \\\"Fix the off-by-one error in the pagination logic in src/lib/paginate.ts\\\"\\\\nassistant: \\\"Fixed the off-by-one error in src/lib/paginate.ts:34.\\\"\\\\n<commentary>\\\\nA bug fix was applied ‚Äî this is a prime candidate for regression tests. Use the unit-test-writer agent to write tests that cover the fixed behavior and prevent regressions.\\\\n</commentary>\\\\nassistant: \\\"Let me now use the unit-test-writer agent to add tests that cover this fix and prevent regressions.\\\"\\\\n</example>\\\\n\\\\n<example>\\\\nContext: A new server action was added to the Next.js app.\\\\nuser: \\\"Add a toggleLike server action for concepts\\\"\\\\nassistant: \\\"Implemented toggleLike in src/app/actions/concepts.ts.\\\"\\\\n<commentary>\\\\nA new server action with auth logic and DB mutations was written. Use the unit-test-writer agent to generate tests covering auth guards, happy paths, and error scenarios.\\\\n</commentary>\\\\nassistant: \\\"I'll now use the unit-test-writer agent to write tests for the toggleLike action.\\\"\\\\n</example>\"\nmodel: sonnet\ncolor: green\nmemory: project\n---\n\nYou are a senior software engineer with 15+ years of experience writing production-grade unit tests. You have deep expertise in test-driven development, testing patterns, and multiple testing frameworks. You write tests that are thorough, readable, maintainable, and actually catch bugs.\n\n## Your Mission\n\nYou will be given source code ‚Äî read it deeply, understand the logic, identify all code paths, then write comprehensive unit tests that provide high confidence in the code's correctness.\n\n## Step 1: Analyze the Code\n\nBefore writing a single test, perform a structured analysis:\n\n1. **Understand the contract**: What does each function/method promise to do? What are its inputs, outputs, and side effects?\n2. **Map all code paths**: Trace every branch, conditional, loop, and early return.\n3. **Identify edge cases**: Empty inputs, null/undefined, zero, negative numbers, max values, empty arrays, single-element collections, concurrent access, etc.\n4. **Identify failure scenarios**: What can throw? What external dependencies can fail? What invalid inputs are possible?\n5. **Note dependencies**: What needs to be mocked ‚Äî DB calls, API calls, auth, filesystem, timers, environment variables?\n\n## Step 2: Determine the Testing Framework\n\nInspect the project to identify the correct framework before writing any tests:\n\n- Check `package.json` for `jest`, `vitest`, `mocha`, `jasmine`, `@testing-library/*`, etc.\n- Check for config files: `jest.config.*`, `vitest.config.*`, `.mocharc.*`\n- Check existing test files to understand patterns, file naming conventions, and import styles\n- Match the framework, assertion style, and mock patterns already in use\n- For this project (Next.js 16 + TypeScript), prefer `vitest` if present; fall back to `jest` with TypeScript config\n\n## Step 3: Write the Tests\n\nStructure tests with clear, descriptive names organized by function/method:\n\n```\ndescribe('functionName', () => {\n  describe('happy path', () => { ... })\n  describe('edge cases', () => { ... })\n  describe('error handling', () => { ... })\n})\n```\n\n### Coverage Requirements\n\n**Happy paths**: Every documented use case and expected behavior.\n\n**Edge cases** (cover ALL that apply):\n- Empty string, null, undefined, 0, false as inputs\n- Arrays: empty, single element, very large\n- Numbers: negative, zero, max safe integer, floats, NaN, Infinity\n- Objects: missing optional properties, extra unexpected properties\n- Boundary values: off-by-one, min/max limits\n- Async: resolved promises, rejected promises, race conditions\n- Auth: authenticated user, unauthenticated user, wrong user accessing another's resource\n\n**Failure scenarios**:\n- Invalid input types\n- Dependency failures (DB down, network error, auth failure)\n- Thrown errors ‚Äî verify message, type, and that they propagate correctly\n- Functions that should NOT throw ‚Äî verify they don't\n\n## Test Quality Standards\n\n- **One assertion concept per test** ‚Äî tests should have a single reason to fail\n- **Descriptive names** ‚Äî `it('returns null when userId is missing')` not `it('works correctly')`\n- **Arrange-Act-Assert** ‚Äî clear setup, execution, and verification sections\n- **No implementation leakage** ‚Äî test behavior, not internal implementation details\n- **Isolated tests** ‚Äî no shared mutable state; use `beforeEach` to reset\n- **Meaningful assertions** ‚Äî assert on the actual output value, not just that something was called\n- **Mock at the right boundary** ‚Äî mock external I/O, not business logic\n\n## Project-Specific Rules\n\n- This is a Next.js 16 App Router project with TypeScript (strict mode)\n- Server actions in `src/app/actions/` use Supabase auth ‚Äî mock `createClient()` from `src/lib/supabase/server.ts`\n- Prisma queries come from `src/lib/prisma.ts` singleton ‚Äî mock at the prisma client level\n- `revalidatePath` from `next/cache` must be mocked in server action tests\n- Use `radix-ui` (not `@radix-ui/react-*`) if any UI component tests are needed\n- No emojis in test descriptions or comments\n- File naming: `*.test.ts` or `*.test.tsx` co-located with the source file\n\n## Output Format\n\n1. **Brief analysis** (3-10 lines): What you found in the code ‚Äî key logic, identified paths, mocking needs\n2. **Test file**: Complete, runnable test file with all imports, mocks, and test cases\n3. **Coverage summary**: A brief list of what is covered and any gaps you intentionally left (with rationale)\n\nDo not ask for clarification on obvious details. Read the source, make reasonable assumptions, and write the tests. If a critical ambiguity would cause you to write wrong tests, state the assumption explicitly at the top.\n\n**Update your agent memory** as you discover testing patterns, mock strategies, common failure modes, and framework-specific conventions used in this codebase. Record:\n- Which testing framework and version is in use\n- Mock patterns for Supabase, Prisma, and Next.js APIs\n- Any custom test utilities or helpers found in the project\n- Recurring edge cases that turn out to be important for this domain\n- Patterns the codebase team prefers (file naming, describe structure, assertion style)\n\n# Persistent Agent Memory\n\nYou have a persistent Persistent Agent Memory directory at `C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\agent-memory\\unit-test-writer\\`. Its contents persist across conversations.\n\nAs you work, consult your memory files to build on previous experience. When you encounter a mistake that seems like it could be common, check your Persistent Agent Memory for relevant notes ‚Äî and if nothing is written yet, record what you learned.\n\nGuidelines:\n- `MEMORY.md` is always loaded into your system prompt ‚Äî lines after 200 will be truncated, so keep it concise\n- Create separate topic files (e.g., `debugging.md`, `patterns.md`) for detailed notes and link to them from MEMORY.md\n- Update or remove memories that turn out to be wrong or outdated\n- Organize memory semantically by topic, not chronologically\n- Use the Write and Edit tools to update your memory files\n\nWhat to save:\n- Stable patterns and conventions confirmed across multiple interactions\n- Key architectural decisions, important file paths, and project structure\n- User preferences for workflow, tools, and communication style\n- Solutions to recurring problems and debugging insights\n\nWhat NOT to save:\n- Session-specific context (current task details, in-progress work, temporary state)\n- Information that might be incomplete ‚Äî verify against project docs before writing\n- Anything that duplicates or contradicts existing CLAUDE.md instructions\n- Speculative or unverified conclusions from reading a single file\n\nExplicit user requests:\n- When the user asks you to remember something across sessions (e.g., \"always use bun\", \"never auto-commit\"), save it ‚Äî no need to wait for multiple interactions\n- When the user asks to forget or stop remembering something, find and remove the relevant entries from your memory files\n- Since this memory is project-scope and shared with your team via version control, tailor your memories to this project\n\n## MEMORY.md\n\nYour MEMORY.md is currently empty. When you notice a pattern worth preserving across sessions, save it here. Anything in MEMORY.md will be included in your system prompt next time.\n",
          "numLines": 134,
          "startLine": 1,
          "totalLines": 134
        }
      },
      "tool_use_id": "toolu_0121VdmyGrrtQ1wYZU4v5yQp"
    }
  },
  {
    "timestamp": "2026-02-28T05:35:04.154Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\commands\\audit.md"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\.claude\\commands\\audit.md",
          "content": "Your goal is to update any vulnerable dependencies.\n\nDo the following:\n\n1. Run `npm audit` to find vulnerable installed packages in this project\n2. Run `npm audit fix` to apply updates\n3. Run tests and verify the updates didn't break anything",
          "numLines": 7,
          "startLine": 1,
          "totalLines": 7
        }
      },
      "tool_use_id": "toolu_01LAH1mNxB8BNpaofxVC3RCK"
    }
  },
  {
    "timestamp": "2026-02-28T05:35:47.820Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Write",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T05:40:35.239Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "skill.md content \"---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.\" based on this update our skill section"
    }
  },
  {
    "timestamp": "2026-02-28T05:40:41.643Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1474,
        "limit": 95
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",",
          "numLines": 95,
          "startLine": 1474,
          "totalLines": 1867
        }
      },
      "tool_use_id": "toolu_015Nh8QUc6AM18ioHTLk5PHY"
    }
  },
  {
    "timestamp": "2026-02-28T05:43:40.789Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "still the skill concet point to old commit example"
    }
  },
  {
    "timestamp": "2026-02-28T05:43:48.879Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1482,
        "limit": 85
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {",
          "numLines": 85,
          "startLine": 1482,
          "totalLines": 1867
        }
      },
      "tool_use_id": "toolu_01RCZktCcEy2KCcRmZXdx2Nn"
    }
  },
  {
    "timestamp": "2026-02-28T05:44:12.392Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },",
        "new_string": "      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },",
        "newString": "      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Creating a Skill\",\n        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",\n        code: {\n          language: \"bash\",\n          content: `# Create a project-specific skill:\nmkdir -p .claude/skills\n\n# Create a skill file:\ncat > .claude/skills/commit.md << 'EOF'\nCreate a git commit following these steps:\n\n1. Run \\`git status\\` to see all changes\n2. Run \\`git diff\\` to review what changed\n3. Write a commit message in this format:\n   - First line: imperative mood, under 72 chars\n   - Body: explain WHY not WHAT\n   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>\n4. Stage appropriate files (never .env or secrets)\n5. Commit and verify with git status\nEOF\n\n# Now use it:\nclaude\n> /commit`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Using Skills\",\n        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Invoke built-in and custom skills:\n/commit              ‚Üê run your commit skill\n/review-pr 123       ‚Üê review PR #123\n/deploy staging      ‚Üê deploy to staging environment\n/test auth           ‚Üê run auth-related tests\n\n# Skills can receive arguments via $ARGUMENTS:\n# In your skill file, use $ARGUMENTS to reference them\n# Example skill content:\n\"Review PR #$ARGUMENTS for security issues and code quality...\"`,\n        },\n      },\n      {\n        heading: \"Skill File Structure\",\n        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/skills/review-pr.md\n\nReview the pull request #$ARGUMENTS.\n\nSteps:\n1. Run \\`gh pr view $ARGUMENTS\\` to get PR details\n2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes\n3. Analyze for:\n   - Security vulnerabilities (OWASP Top 10)\n   - Performance issues\n   - Missing error handling\n   - TypeScript type safety\n   - Test coverage gaps\n\nOutput a structured review with:\n- Summary (1 paragraph)\n- Issues Found (severity: critical/major/minor)\n- Suggested Improvements\n- Overall assessment (approve/request changes)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1485,
            "oldLines": 81,
            "newStart": 1485,
            "newLines": 59,
            "lines": [
              "         body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",",
              "       },",
              "       {",
              "-        heading: \"Creating a Skill\",",
              "-        body: \"Skills are markdown files stored in ~/.claude/skills/ (user-wide) or .claude/skills/ (project-specific). The filename becomes the command name. The file content is the prompt that gets expanded.\",",
              "+        heading: \"Step 1 ‚Äî Create the Skill Directory\",",
              "+        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",",
              "         code: {",
              "           language: \"bash\",",
              "-          content: `# Create a project-specific skill:",
              "-mkdir -p .claude/skills",
              "+          content: `# Personal skill ‚Äî available in all your projects:",
              "+mkdir -p ~/.claude/skills/explain-code",
              " ",
              "-# Create a skill file:",
              "-cat > .claude/skills/commit.md << 'EOF'",
              "-Create a git commit following these steps:",
              "-",
              "-1. Run \\`git status\\` to see all changes",
              "-2. Run \\`git diff\\` to review what changed",
              "-3. Write a commit message in this format:",
              "-   - First line: imperative mood, under 72 chars",
              "-   - Body: explain WHY not WHAT",
              "-   - Footer: Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>",
              "-4. Stage appropriate files (never .env or secrets)",
              "-5. Commit and verify with git status",
              "-EOF",
              "-",
              "-# Now use it:",
              "-claude",
              "-> /commit`,",
              "+# Project-specific skill ‚Äî commit to git so the team shares it:",
              "+mkdir -p .claude/skills/explain-code`,",
              "         },",
              "         screenshots: [",
              "-          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating a skill file in .claude/skills/\" },",
              "+          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },",
              "         ],",
              "       },",
              "       {",
              "-        heading: \"Using Skills\",",
              "-        body: \"Invoke skills with the slash command syntax: /skill-name. You can also pass arguments after the command name. Claude Code expands the skill's markdown content into a full prompt and executes it.\",",
              "+        heading: \"Step 2 ‚Äî Write SKILL.md\",",
              "+        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",",
              "         code: {",
              "-          language: \"text\",",
              "-          content: `# Invoke built-in and custom skills:",
              "-/commit              ‚Üê run your commit skill",
              "-/review-pr 123       ‚Üê review PR #123",
              "-/deploy staging      ‚Üê deploy to staging environment",
              "-/test auth           ‚Üê run auth-related tests",
              "+          language: \"markdown\",",
              "+          content: `# ~/.claude/skills/explain-code/SKILL.md",
              " ",
              "-# Skills can receive arguments via $ARGUMENTS:",
              "-# In your skill file, use $ARGUMENTS to reference them",
              "-# Example skill content:",
              "-\"Review PR #$ARGUMENTS for security issues and code quality...\"`,",
              "+---",
              "+name: explain-code",
              "+description: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"",
              "+---",
              "+",
              "+When explaining code, always include:",
              "+",
              "+1. **Start with an analogy**: Compare the code to something from everyday life",
              "+2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships",
              "+3. **Walk through the code**: Explain step-by-step what happens",
              "+4. **Highlight a gotcha**: What's a common mistake or misconception?",
              "+",
              "+Keep explanations conversational. For complex concepts, use multiple analogies.`,",
              "         },",
              "       },",
              "       {",
              "-        heading: \"Skill File Structure\",",
              "-        body: \"A skill file is just markdown ‚Äî but it's a detailed prompt. Good skills include context about the task, step-by-step instructions, quality standards, and what to output at the end.\",",
              "+        heading: \"Step 3 ‚Äî Test the Skill\",",
              "+        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",",
              "         code: {",
              "-          language: \"markdown\",",
              "-          content: `# .claude/skills/review-pr.md",
              "+          language: \"text\",",
              "+          content: `# Let Claude invoke it automatically (matches description):",
              "+How does this code work?",
              " ",
              "-Review the pull request #$ARGUMENTS.",
              "+# Or invoke it directly with the skill name:",
              "+/explain-code src/auth/login.ts",
              " ",
              "-Steps:",
              "-1. Run \\`gh pr view $ARGUMENTS\\` to get PR details",
              "-2. Run \\`gh pr diff $ARGUMENTS\\` to see all changes",
              "-3. Analyze for:",
              "-   - Security vulnerabilities (OWASP Top 10)",
              "-   - Performance issues",
              "-   - Missing error handling",
              "-   - TypeScript type safety",
              "-   - Test coverage gaps",
              "-",
              "-Output a structured review with:",
              "-- Summary (1 paragraph)",
              "-- Issues Found (severity: critical/major/minor)",
              "-- Suggested Improvements",
              "-- Overall assessment (approve/request changes)`,",
              "+# Either way Claude should include an analogy and ASCII diagram.`,",
              "         },",
              "       },",
              "       {",
              "         heading: \"Tips\",",
              "-        body: \"Create skills for any workflow you repeat more than twice. Store project skills in .claude/skills/ and commit them to git so the whole team benefits. User-level skills in ~/.claude/skills/ apply across all your projects. Keep skill prompts specific and detailed ‚Äî vague skills produce vague results.\",",
              "+        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",",
              "       },",
              "     ],",
              "   },"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_013HWVuSKjfSKSqanmf4ftre"
    }
  },
  {
    "timestamp": "2026-02-28T05:44:20.434Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",",
        "new_string": "        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",",
        "newString": "        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"2026-03-01\",\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1482,
            "oldLines": 7,
            "newStart": 1482,
            "newLines": 7,
            "lines": [
              "     sections: [",
              "       {",
              "         heading: \"Overview\",",
              "-        body: \"Skills are custom slash commands you define for Claude Code. Each skill maps a short command (like /commit or /review-pr) to a detailed prompt that gets expanded when the command is invoked. They're stored as markdown files and can be shared across your team. Skills eliminate the need to retype complex, repeated instructions.\",",
              "+        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",",
              "       },",
              "       {",
              "         heading: \"Step 1 ‚Äî Create the Skill Directory\","
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01Fn5uhSV2jYs55CQtRibzt1"
    }
  },
  {
    "timestamp": "2026-02-28T05:44:26.280Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Changes made to `src/data/concepts.ts`:\n\n- **Overview** ‚Äî updated to describe the directory + SKILL.md structure instead of flat `.md` files\n- **Creating a Skill** ‚Üí **Step 1** ‚Äî shows `mkdir -p ~/.claude/skills/explain-code` (directory, not a flat file)\n- **Skill File Structure** ‚Üí **Step 2** ‚Äî shows the full `SKILL.md` with YAML frontmatter (`name`, `description`) matching the example you provided\n- **Using Skills** ‚Üí **Step 3** ‚Äî shows both auto-invoke (matches description) and direct `/explain-code src/auth/login.ts`\n- **Tips** ‚Äî updated to focus on writing a tight `description` for auto-invocation"
    }
  },
  {
    "timestamp": "2026-02-28T05:44:28.105Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "ae22a84d8e6bc2d55",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63\\subagents\\agent-ae22a84d8e6bc2d55.jsonl",
      "agent_type": "",
      "last_assistant_message": "can you show me a preview of the skills concept page"
    }
  },
  {
    "timestamp": "2026-02-28T05:49:03.036Z",
    "payload": {
      "session_id": "5817861c-a775-43fd-9b14-580a27f91e63",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\5817861c-a775-43fd-9b14-580a27f91e63.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionEnd",
      "reason": "prompt_input_exit"
    }
  },
  {
    "timestamp": "2026-02-28T05:49:08.594Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionStart",
      "source": "startup",
      "model": "claude-sonnet-4-6"
    }
  },
  {
    "timestamp": "2026-02-28T05:49:27.757Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "/explain-code "
    }
  },
  {
    "timestamp": "2026-02-28T05:49:40.370Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "/explain-code \"c:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(auth)\\signup\\page.tsx\""
    }
  },
  {
    "timestamp": "2026-02-28T05:49:42.561Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(auth)\\signup\\page.tsx"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(auth)\\signup\\page.tsx",
          "content": "'use client'\n\nimport { useActionState } from 'react'\nimport Link from 'next/link'\nimport { signup, signInWithGoogle, type AuthState } from '@/app/actions/auth'\nimport { Input } from '@/components/ui/input'\nimport { Label } from '@/components/ui/label'\n\nconst initialState: AuthState = { error: null, fieldErrors: {} }\n\nfunction GoogleIcon() {\n  return (\n    <svg width=\"18\" height=\"18\" viewBox=\"0 0 18 18\" fill=\"none\" aria-hidden=\"true\">\n      <path d=\"M17.64 9.205c0-.639-.057-1.252-.164-1.841H9v3.481h4.844a4.14 4.14 0 0 1-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z\" fill=\"#4285F4\" />\n      <path d=\"M9 18c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 0 0 9 18z\" fill=\"#34A853\" />\n      <path d=\"M3.964 10.71A5.41 5.41 0 0 1 3.682 9c0-.593.102-1.17.282-1.71V4.958H.957A8.996 8.996 0 0 0 0 9c0 1.452.348 2.827.957 4.042l3.007-2.332z\" fill=\"#FBBC05\" />\n      <path d=\"M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 0 0 .957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z\" fill=\"#EA4335\" />\n    </svg>\n  )\n}\n\nfunction FieldError({ msg }: { msg?: string }) {\n  if (!msg) return null\n  return <p className=\"text-xs text-red-400 mt-1\">{msg}</p>\n}\n\nexport default function SignupPage() {\n  const [state, formAction, isPending] = useActionState(signup, initialState)\n\n  return (\n    <div className=\"mx-auto w-full max-w-[420px]\">\n      {/* Card */}\n      <div className=\"rounded-2xl border border-zinc-800 bg-zinc-900/80 backdrop-blur-sm p-8 shadow-2xl\">\n\n        {/* Logo mark */}\n        <div className=\"mb-6 flex flex-col items-center gap-3\">\n          <div className=\"flex h-11 w-11 items-center justify-center rounded-xl bg-gradient-to-br from-amber-400 to-orange-500 shadow-lg shadow-amber-500/25\">\n            <span className=\"text-[15px] font-black text-white tracking-tight\">CC</span>\n          </div>\n          <div className=\"text-center\">\n            <h1 className=\"text-lg font-bold text-white\">\n              Claude Code <span className=\"text-amber-400\">Learning Hub</span>\n            </h1>\n            <p className=\"mt-0.5 text-sm text-zinc-400\">Create your account to get started</p>\n          </div>\n        </div>\n\n        {/* Google sign-in */}\n        <form action={signInWithGoogle} className=\"mb-5\">\n          <button\n            type=\"submit\"\n            className=\"flex w-full items-center justify-center gap-3 rounded-lg border border-zinc-700 bg-zinc-800/50 px-4 py-2.5 text-sm font-medium text-zinc-300 transition-colors hover:bg-zinc-700/60 hover:border-zinc-600\"\n          >\n            <GoogleIcon />\n            Sign up with Google\n          </button>\n        </form>\n\n        {/* Divider */}\n        <div className=\"mb-5 flex items-center gap-3\">\n          <div className=\"h-px flex-1 bg-zinc-800\" />\n          <span className=\"text-xs text-zinc-600\">or continue with email</span>\n          <div className=\"h-px flex-1 bg-zinc-800\" />\n        </div>\n\n        {/* Error */}\n        {state.error && (\n          <div className=\"mb-4 rounded-lg border border-red-800/50 bg-red-950/40 px-4 py-3 text-sm text-red-400\">\n            {state.error}\n          </div>\n        )}\n\n        {/* Form */}\n        <form action={formAction} className=\"space-y-4\">\n          <div>\n            <Label htmlFor=\"name\" className=\"text-zinc-300 text-xs font-medium\">\n              Full name\n            </Label>\n            <Input\n              id=\"name\"\n              name=\"name\"\n              type=\"text\"\n              placeholder=\"John Doe\"\n              required\n              autoComplete=\"name\"\n              aria-invalid={!!state.fieldErrors?.name}\n              className=\"mt-1.5 border-zinc-700 bg-zinc-800/60 text-white placeholder:text-zinc-600 focus-visible:border-amber-500 focus-visible:ring-amber-500/20\"\n            />\n            <FieldError msg={state.fieldErrors?.name} />\n          </div>\n\n          <div>\n            <Label htmlFor=\"email\" className=\"text-zinc-300 text-xs font-medium\">\n              Email address\n            </Label>\n            <Input\n              id=\"email\"\n              name=\"email\"\n              type=\"email\"\n              placeholder=\"you@example.com\"\n              required\n              autoComplete=\"email\"\n              aria-invalid={!!state.fieldErrors?.email}\n              className=\"mt-1.5 border-zinc-700 bg-zinc-800/60 text-white placeholder:text-zinc-600 focus-visible:border-amber-500 focus-visible:ring-amber-500/20\"\n            />\n            <FieldError msg={state.fieldErrors?.email} />\n          </div>\n\n          <div>\n            <Label htmlFor=\"password\" className=\"text-zinc-300 text-xs font-medium\">\n              Password\n            </Label>\n            <Input\n              id=\"password\"\n              name=\"password\"\n              type=\"password\"\n              placeholder=\"Min. 6 characters\"\n              required\n              autoComplete=\"new-password\"\n              aria-invalid={!!state.fieldErrors?.password}\n              className=\"mt-1.5 border-zinc-700 bg-zinc-800/60 text-white placeholder:text-zinc-600 focus-visible:border-amber-500 focus-visible:ring-amber-500/20\"\n            />\n            <FieldError msg={state.fieldErrors?.password} />\n          </div>\n\n          <div>\n            <Label htmlFor=\"confirmPassword\" className=\"text-zinc-300 text-xs font-medium\">\n              Confirm password\n            </Label>\n            <Input\n              id=\"confirmPassword\"\n              name=\"confirmPassword\"\n              type=\"password\"\n              placeholder=\"‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\"\n              required\n              autoComplete=\"new-password\"\n              aria-invalid={!!state.fieldErrors?.confirmPassword}\n              className=\"mt-1.5 border-zinc-700 bg-zinc-800/60 text-white placeholder:text-zinc-600 focus-visible:border-amber-500 focus-visible:ring-amber-500/20\"\n            />\n            <FieldError msg={state.fieldErrors?.confirmPassword} />\n          </div>\n\n          <button\n            type=\"submit\"\n            disabled={isPending}\n            className=\"mt-1 w-full rounded-lg bg-amber-500 px-4 py-2.5 text-sm font-semibold text-white shadow-lg shadow-amber-500/25 transition-all hover:bg-amber-400 active:scale-[0.98] disabled:cursor-not-allowed disabled:opacity-60\"\n          >\n            {isPending ? 'Creating account‚Ä¶' : 'Create account'}\n          </button>\n        </form>\n\n        {/* Footer */}\n        <p className=\"mt-6 text-center text-sm text-zinc-500\">\n          Already have an account?{' '}\n          <Link href=\"/login\" className=\"font-medium text-amber-400 transition-colors hover:text-amber-300\">\n            Sign in\n          </Link>\n        </p>\n      </div>\n    </div>\n  )\n}\n",
          "numLines": 163,
          "startLine": 1,
          "totalLines": 163
        }
      },
      "tool_use_id": "toolu_01AV7Js2GrvHP39T5Bhg47oq"
    }
  },
  {
    "timestamp": "2026-02-28T05:49:45.624Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\actions\\auth.ts"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\actions\\auth.ts",
          "content": "'use server'\n\nimport { redirect } from 'next/navigation'\nimport { createClient } from '@/lib/supabase/server'\nimport { prisma } from '@/lib/prisma'\n\nexport type AuthState = {\n  error: string | null\n  fieldErrors?: {\n    name?: string\n    email?: string\n    password?: string\n    confirmPassword?: string\n  }\n}\n\nexport async function login(prevState: AuthState, formData: FormData): Promise<AuthState> {\n  const email = formData.get('email') as string\n  const password = formData.get('password') as string\n\n  const supabase = await createClient()\n  const { error } = await supabase.auth.signInWithPassword({ email, password })\n\n  if (error) {\n    return { error: error.message }\n  }\n\n  redirect('/?toast=login')\n}\n\nexport async function signup(prevState: AuthState, formData: FormData): Promise<AuthState> {\n  const name = formData.get('name') as string\n  const email = formData.get('email') as string\n  const password = formData.get('password') as string\n  const confirmPassword = formData.get('confirmPassword') as string\n\n  const fieldErrors: AuthState['fieldErrors'] = {}\n\n  if (!name || name.trim().length < 2) {\n    fieldErrors.name = 'Name must be at least 2 characters.'\n  }\n  if (!email || !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n    fieldErrors.email = 'Please enter a valid email address.'\n  }\n  if (!password || password.length < 6) {\n    fieldErrors.password = 'Password must be at least 6 characters.'\n  }\n  if (password !== confirmPassword) {\n    fieldErrors.confirmPassword = 'Passwords do not match.'\n  }\n\n  if (Object.keys(fieldErrors).length > 0) {\n    return { error: null, fieldErrors }\n  }\n\n  const supabase = await createClient()\n  const { data, error } = await supabase.auth.signUp({ email, password })\n\n  if (error) {\n    return { error: error.message }\n  }\n\n  if (data.user) {\n    await prisma.profile.upsert({\n      where: { userId: data.user.id },\n      update: { email, name: name.trim() },\n      create: { userId: data.user.id, email, name: name.trim() },\n    })\n  }\n\n  redirect('/')\n}\n\nexport async function signInWithGoogle() {\n  const supabase = await createClient()\n  const { data, error } = await supabase.auth.signInWithOAuth({\n    provider: 'google',\n    options: {\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`,\n    },\n  })\n  if (error || !data.url) redirect('/login?error=oauth_failed')\n  redirect(data.url)\n}\n\nexport async function logout() {\n  const supabase = await createClient()\n  await supabase.auth.signOut()\n  redirect('/login')\n}\n",
          "numLines": 91,
          "startLine": 1,
          "totalLines": 91
        }
      },
      "tool_use_id": "toolu_01QrBGiDwC9yRnDf3mJccFgG"
    }
  },
  {
    "timestamp": "2026-02-28T05:50:13.902Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "---\n\n## The Analogy: A Hotel Front Desk Check-In\n\nThink of this signup page like a **hotel front desk**. A guest walks in (the user), fills out a paper registration card (the form), hands it to the clerk (the server action), who then:\n1. Validates the card (field checks)\n2. Checks the hotel's system (Supabase auth)\n3. Creates a guest profile (Prisma DB)\n4. Hands them a room key (session cookie + redirect)\n\nThe clever part: the clerk (server action) and the guest (browser) share a single state object (`AuthState`) that bounces between them ‚Äî errors flow back, success redirects forward.\n\n---\n\n## The Flow Diagram\n\n```\nBrowser                                 Server\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nSignupPage renders\n  ‚îÇ\n  ‚îú‚îÄ useActionState(signup, initialState)\n  ‚îÇ    ‚îî‚îÄ state = { error: null, fieldErrors: {} }\n  ‚îÇ\nUser fills form ‚Üí clicks \"Create account\"\n  ‚îÇ\n  ‚ñº\n<form action={formAction}> submits (POST)\n  ‚îÇ\n  ‚ñº                              signup(prevState, formData)\n                                    ‚îÇ\n                                    ‚îú‚îÄ Extract: name, email, password, confirmPassword\n                                    ‚îÇ\n                                    ‚îú‚îÄ Validate fields\n                                    ‚îÇ   ‚îî‚îÄ if errors ‚Üí return { fieldErrors }\n                                    ‚îÇ          ‚îÇ\n                                    ‚îÇ    ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò (state updates, UI re-renders with errors)\n                                    ‚îÇ\n                                    ‚îú‚îÄ supabase.auth.signUp()\n                                    ‚îÇ   ‚îî‚îÄ if error ‚Üí return { error: message }\n                                    ‚îÇ          ‚îÇ\n                                    ‚îÇ    ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò (banner error shown)\n                                    ‚îÇ\n                                    ‚îú‚îÄ prisma.profile.upsert()\n                                    ‚îÇ   (create DB row linked to Supabase user ID)\n                                    ‚îÇ\n                                    ‚îî‚îÄ redirect('/')  ‚Üê success\n```\n\n---\n\n## Step-by-Step Walkthrough\n\n### 1. State Management ‚Äî `useActionState` (page.tsx:28)\n```ts\nconst [state, formAction, isPending] = useActionState(signup, initialState)\n```\nReact's `useActionState` hook wires a server action to a form. It gives you:\n- `state` ‚Äî the last return value from the server action (errors live here)\n- `formAction` ‚Äî a wrapped version of `signup` to use as the form's `action`\n- `isPending` ‚Äî `true` while the server action is running (used to disable the button at line 145)\n\n### 2. Two Independent Forms (page.tsx:49 + 74)\nThere are **two separate `<form>` elements** on this page:\n- Line 49: Google OAuth form ‚Äî its action is `signInWithGoogle`\n- Line 74: Email/password form ‚Äî its action is `formAction` (the wrapped `signup`)\n\nThey don't share state; each submits independently.\n\n### 3. Server-Side Validation (auth.ts:39‚Äì53)\n```ts\nconst fieldErrors: AuthState['fieldErrors'] = {}\nif (!name || name.trim().length < 2) fieldErrors.name = '...'\n// ... more checks\nif (Object.keys(fieldErrors).length > 0) return { error: null, fieldErrors }\n```\nValidation runs on the server, not the browser. The error object is returned and React puts it back into `state`, causing the component to re-render with inline errors under each field via `<FieldError>`.\n\n### 4. Two-Step User Creation (auth.ts:57‚Äì68)\n```ts\nconst { data, error } = await supabase.auth.signUp({ email, password })  // Supabase auth record\n// ...\nawait prisma.profile.upsert({ ... })  // Prisma DB profile row\n```\nA user is created in **two places**: Supabase (handles auth/sessions) and your Postgres DB via Prisma (stores display name, etc.). The Prisma `userId` field stores the Supabase user UUID, linking them.\n\n### 5. `FieldError` Component (page.tsx:22‚Äì25)\n```ts\nfunction FieldError({ msg }: { msg?: string }) {\n  if (!msg) return null\n  return <p className=\"text-xs text-red-400 mt-1\">{msg}</p>\n}\n```\nA tiny presentational component. Returns nothing when there's no error ‚Äî clean and idiomatic.\n\n---\n\n## The Gotcha: Server Actions Don't Reset Form Fields\n\nWhen the server action returns field errors, React re-renders the form with the error messages ‚Äî but the **input values are NOT reset**. However, they also aren't re-populated from `state` because the inputs are uncontrolled (no `value` prop). This means:\n\n- Errors appear correctly under each field\n- But if you had a typo in your email, the wrong value stays in the input (good UX)\n- If validation passes but Supabase fails, the form also keeps its values (also good)\n\nThe gotcha is the **opposite** case: there's no `defaultValue={state.prevValues?.email}` pattern here. If you navigate away and back, the form resets. Some apps persist draft values in `state` to survive that ‚Äî this one doesn't, which is fine for a signup form but worth knowing.\n\n**Another subtlety:** `redirect()` inside a server action throws a special Next.js error internally ‚Äî it's not a normal function return. So the line `redirect('/')` at `auth.ts:71` never reaches the caller; React catches it at the framework level and navigates the browser."
    }
  },
  {
    "timestamp": "2026-02-28T05:50:15.403Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a698db320bae46202",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42\\subagents\\agent-a698db320bae46202.jsonl",
      "agent_type": "",
      "last_assistant_message": "explain the signup server action"
    }
  },
  {
    "timestamp": "2026-02-28T05:55:43.303Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "can u just combine \"settings.json vs settings.local.json\" section and \"Settings & Configuration\" section has one section and merge the content and remove the same content if anything present"
    }
  },
  {
    "timestamp": "2026-02-28T05:55:46.716Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  }, \n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
          "numLines": 1846,
          "startLine": 1,
          "totalLines": 1846
        }
      },
      "tool_use_id": "toolu_01YViAyfR2fnyX8Fjyeg4p91"
    }
  },
  {
    "timestamp": "2026-02-28T05:55:54.238Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Grep",
      "tool_input": {
        "pattern": "settings\\.json vs settings\\.local\\.json|Settings & Configuration|Settings \\& Configuration",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "output_mode": "content",
        "-n": true
      },
      "tool_response": {
        "mode": "content",
        "numFiles": 0,
        "filenames": [],
        "content": "543:    title: \"settings.json vs settings.local.json\",\r\n1738:    title: \"Settings & Configuration\",",
        "numLines": 2
      },
      "tool_use_id": "toolu_01WXaCLJUgWdFAFRUcnm21NT"
    }
  },
  {
    "timestamp": "2026-02-28T05:55:56.693Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 530,
        "limit": 300
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,",
          "numLines": 300,
          "startLine": 530,
          "totalLines": 1846
        }
      },
      "tool_use_id": "toolu_01F7MaAqWvArTxFSFYRaB1Zk"
    }
  },
  {
    "timestamp": "2026-02-28T05:56:00.269Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1730,
        "limit": 250
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  }, \n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
          "numLines": 117,
          "startLine": 1730,
          "totalLines": 1846
        }
      },
      "tool_use_id": "toolu_01Cc5WyHDHLTguXFwHSztuDP"
    }
  },
  {
    "timestamp": "2026-02-28T05:56:32.827Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1732,
        "limit": 15
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  }, \n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {",
          "numLines": 15,
          "startLine": 1732,
          "totalLines": 1846
        }
      },
      "tool_use_id": "toolu_01VahpFiW7pgJArB63uxvQWk"
    }
  },
  {
    "timestamp": "2026-02-28T05:57:20.694Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Update",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T05:59:02.756Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },",
        "new_string": "  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },",
        "newString": "  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings-json\",\n    title: \"settings.json vs settings.local.json\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": []\n  },\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Merge Order\",\n        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\nExample: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],\nthe final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  }, \n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 539,
            "oldLines": 8,
            "newStart": 539,
            "newLines": 8,
            "lines": [
              "     ],",
              "   },",
              "   {",
              "-    slug: \"settings-json\",",
              "-    title: \"settings.json vs settings.local.json\",",
              "+    slug: \"settings\",",
              "+    title: \"Settings & Configuration\",",
              "     emoji: \"‚öôÔ∏è\",",
              "     category: \"Core CLI\",",
              "     difficulty: \"Beginner\","
            ]
          },
          {
            "oldStart": 550,
            "oldLines": 19,
            "newStart": 550,
            "newLines": 52,
            "lines": [
              "     sections: [",
              "       {",
              "         heading: \"Overview\",",
              "-        body: \"Claude Code uses two layered configuration files to control its behaviour. `settings.json` is the shared project config (committed to git), while `settings.local.json` is a machine-specific override that stays out of version control. Together they let teams share a baseline while each developer keeps their own personal tweaks.\",",
              "+        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",",
              "       },",
              "       {",
              "+        heading: \"Settings File Locations\",",
              "+        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",",
              "+        code: {",
              "+          language: \"text\",",
              "+          content: `Layer 1 ‚Äî Global (applies to every project on your machine)",
              "+  ~/.claude/settings.json",
              "+",
              "+    Layer 2 ‚Äî Project shared (committed, applies to all teammates)",
              "+      .claude/settings.json",
              "+",
              "+        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)",
              "+          .claude/settings.local.json   ‚Üê wins on conflict",
              "+",
              "+# The .claude/ directory structure:",
              "+.claude/",
              "+‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)",
              "+‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)",
              "+‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills",
              "+‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,",
              "+        },",
              "+      },",
              "+      {",
              "         heading: \"settings.json ‚Äî Shared Project Config\",",
              "         body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",",
              "         code: {",
              "           language: \"json\",",
              "           content: `// .claude/settings.json  (committed to git)",
              " {",
              "+  \"model\": \"claude-sonnet-4-6\",",
              "+",
              "   \"permissions\": {",
              "     \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],",
              "-    \"deny\": []",
              "+    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]",
              "   },",
              "+",
              "+  \"mcpServers\": {",
              "+    \"github\": {",
              "+      \"command\": \"npx\",",
              "+      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],",
              "+      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }",
              "+    }",
              "+  },",
              "+",
              "   \"hooks\": {",
              "     \"PostToolUse\": [",
              "       {"
            ]
          },
          {
            "oldStart": 576,
            "oldLines": 7,
            "newStart": 609,
            "newLines": 7,
            "lines": [
              "       },",
              "       {",
              "         heading: \"settings.local.json ‚Äî Personal Overrides\",",
              "-        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. Settings here are merged on top of `settings.json`, so you only need to specify what you're overriding.\",",
              "+        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",",
              "         screenshots: [",
              "           {",
              "             src: \"/screenshots/Setting.png\","
            ]
          },
          {
            "oldStart": 604,
            "oldLines": 26,
            "newStart": 637,
            "newLines": 8,
            "lines": [
              "         },",
              "       },",
              "       {",
              "-        heading: \"Merge Order\",",
              "-        body: \"Think of it as three layers stacked on top of each other. Claude Code reads all three files and combines them ‚Äî the file closest to you (settings.local.json) always wins if the same setting appears in multiple places. Nothing is lost from lower layers; only conflicting keys get overwritten.\",",
              "-        code: {",
              "-          language: \"text\",",
              "-          content: `Layer 1 ‚Äî Global (applies to every project on your machine)",
              "-  ~/.claude/settings.json",
              "-",
              "-    Layer 2 ‚Äî Project shared (committed, applies to all teammates)",
              "-      .claude/settings.json",
              "-",
              "-        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)",
              "-          .claude/settings.local.json   ‚Üê wins on conflict",
              "-",
              "-Example: if Layer 1 allows [\"Read\"] and Layer 3 allows [\"Read\", \"Write\"],",
              "-the final result is [\"Read\", \"Write\"] ‚Äî layers add, not replace.`,",
              "-        },",
              "-      },",
              "-      {",
              "         heading: \"What Belongs Where\",",
              "-        body: \"A simple rule of thumb: if every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens ‚Äî use the local file or environment variables injected outside Claude Code.\",",
              "+        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",",
              "         code: {",
              "           language: \"text\",",
              "           content: `settings.json (commit)         settings.local.json (don't commit)"
            ]
          },
          {
            "oldStart": 635,
            "oldLines": 8,
            "newStart": 650,
            "newLines": 24,
            "lines": [
              "         },",
              "       },",
              "       {",
              "+        heading: \"Environment Variables\",",
              "+        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",",
              "+        code: {",
              "+          language: \"bash\",",
              "+          content: `# Core environment variables:",
              "+ANTHROPIC_API_KEY=sk-ant-...        # Required: your API key",
              "+CLAUDE_MODEL=claude-opus-4-6        # Override default model",
              "+CLAUDE_MAX_TOKENS=8192              # Override max response tokens",
              "+ANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)",
              "+",
              "+# Non-interactive / CI usage:",
              "+export ANTHROPIC_API_KEY=\"$SECRET_KEY\"",
              "+claude -p \"Review this code for security issues\" < code.ts`,",
              "+        },",
              "+      },",
              "+      {",
              "         heading: \"Tips\",",
              "-        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. If you're bootstrapping a new project, start with an empty `settings.json` and let each developer build their own `settings.local.json`. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",",
              "+        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",",
              "       },",
              "     ],",
              "     references: ["
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01WF2bPNkVmEkzvE32eDmVLP"
    }
  },
  {
    "timestamp": "2026-02-28T05:59:21.663Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "  }, \n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];",
        "new_string": "  },\n];",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "  }, \n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];",
        "newString": "  },\n];",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  }, \n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code behavior through settings files at user and project level.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",\n        code: {\n          language: \"text\",\n          content: `# User-level settings (applies to all projects):\n~/.claude/settings.json\n\n# Project-level settings (applies to this project only):\n.claude/settings.json\n\n# Order of precedence (highest wins):\n1. Project settings (.claude/settings.json)\n2. User settings (~/.claude/settings.json)\n3. Default Claude Code behavior\n\n# The .claude/ directory also contains:\n.claude/\n‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings\n‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills\n‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts\n‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,\n        },\n      },\n      {\n        heading: \"Key Settings\",\n        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",\n        code: {\n          language: \"json\",\n          content: `// Complete settings.json example\n{\n  // Default model for this project\n  \"model\": \"claude-sonnet-4-6\",\n\n  // Permission rules\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git status)\",\n      \"Bash(git diff)\",\n      \"Write(src/**)\",\n      \"Read\"\n    ],\n    \"deny\": [\n      \"Bash(rm -rf *)\",\n      \"Bash(git push --force *)\"\n    ]\n  },\n\n  // MCP servers\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  // Hooks\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{\n          \"type\": \"command\",\n          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"\n        }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1763,
            "oldLines": 114,
            "newStart": 1763,
            "newLines": 5,
            "lines": [
              "         body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",",
              "       },",
              "     ],",
              "-  }, ",
              "-  {",
              "-    slug: \"settings\",",
              "-    title: \"Settings & Configuration\",",
              "-    emoji: \"‚öôÔ∏è\",",
              "-    category: \"Integration\",",
              "-    difficulty: \"Intermediate\",",
              "-    released: true,",
              "-    shortDesc:",
              "-      \"Configure Claude Code behavior through settings files at user and project level.\",",
              "-    sections: [",
              "-      {",
              "-        heading: \"Overview\",",
              "-        body: \"Claude Code is configured through settings.json files. There are two levels: user-level (~/.claude/settings.json) which applies to all projects, and project-level (.claude/settings.json) which overrides user settings for a specific project. Settings control permissions, MCP servers, hooks, models, and more.\",",
              "-      },",
              "-      {",
              "-        heading: \"Settings File Locations\",",
              "-        body: \"Settings cascade from user to project level. Project settings override user settings. This lets you set global defaults (preferred model, audit hooks) at the user level and project-specific overrides (different permissions, project MCP servers) at the project level.\",",
              "-        code: {",
              "-          language: \"text\",",
              "-          content: `# User-level settings (applies to all projects):",
              "-~/.claude/settings.json",
              "-",
              "-# Project-level settings (applies to this project only):",
              "-.claude/settings.json",
              "-",
              "-# Order of precedence (highest wins):",
              "-1. Project settings (.claude/settings.json)",
              "-2. User settings (~/.claude/settings.json)",
              "-3. Default Claude Code behavior",
              "-",
              "-# The .claude/ directory also contains:",
              "-.claude/",
              "-‚îú‚îÄ‚îÄ settings.json      ‚Üê project settings",
              "-‚îú‚îÄ‚îÄ skills/            ‚Üê project-specific skills",
              "-‚îú‚îÄ‚îÄ worktrees/         ‚Üê temporary worktree checkouts",
              "-‚îî‚îÄ‚îÄ memory/            ‚Üê (handled by user-level memory system)`,",
              "-        },",
              "-      },",
              "-      {",
              "-        heading: \"Key Settings\",",
              "-        body: \"The most important settings are: permissions (allow/deny tool patterns), mcpServers (external tool connections), hooks (lifecycle automation), and model (default Claude model to use).\",",
              "-        code: {",
              "-          language: \"json\",",
              "-          content: `// Complete settings.json example",
              "-{",
              "-  // Default model for this project",
              "-  \"model\": \"claude-sonnet-4-6\",",
              "-",
              "-  // Permission rules",
              "-  \"permissions\": {",
              "-    \"allow\": [",
              "-      \"Bash(npm run *)\",",
              "-      \"Bash(git status)\",",
              "-      \"Bash(git diff)\",",
              "-      \"Write(src/**)\",",
              "-      \"Read\"",
              "-    ],",
              "-    \"deny\": [",
              "-      \"Bash(rm -rf *)\",",
              "-      \"Bash(git push --force *)\"",
              "-    ]",
              "   },",
              "-",
              "-  // MCP servers",
              "-  \"mcpServers\": {",
              "-    \"github\": {",
              "-      \"command\": \"npx\",",
              "-      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],",
              "-      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }",
              "-    }",
              "-  },",
              "-",
              "-  // Hooks",
              "-  \"hooks\": {",
              "-    \"PostToolUse\": [",
              "-      {",
              "-        \"matcher\": \"Write|Edit\",",
              "-        \"hooks\": [{",
              "-          \"type\": \"command\",",
              "-          \"command\": \"npx prettier --write $(echo $CLAUDE_TOOL_INPUT | jq -r '.file_path // empty') 2>/dev/null; true\"",
              "-        }]",
              "-      }",
              "-    ]",
              "-  }",
              "-}`,",
              "-        },",
              "-      },",
              "-      {",
              "-        heading: \"Environment Variables\",",
              "-        body: \"Some Claude Code behavior is also configurable via environment variables, useful for CI/CD environments where you can't easily write settings files.\",",
              "-        code: {",
              "-          language: \"bash\",",
              "-          content: `# Core environment variables:",
              "-ANTHROPIC_API_KEY=sk-ant-...        # Required: your API key",
              "-CLAUDE_MODEL=claude-opus-4-6        # Override default model",
              "-CLAUDE_MAX_TOKENS=8192              # Override max response tokens",
              "-ANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)",
              "-",
              "-# Non-interactive / CI usage:",
              "-export ANTHROPIC_API_KEY=\"$SECRET_KEY\"",
              "-claude -p \"Review this code for security issues\" < code.ts`,",
              "-        },",
              "-      },",
              "-      {",
              "-        heading: \"Tips\",",
              "-        body: \"Commit .claude/settings.json to your repository so the whole team shares project-level configuration. Keep sensitive values (API keys) in environment variables, not in settings files. Use the allow/deny permission system to create a safety net that matches your team's risk tolerance.\",",
              "-      },",
              "-    ],",
              "-  },",
              " ];"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01PSGdmTfjG6r5KFoDdocamR"
    }
  },
  {
    "timestamp": "2026-02-28T05:59:29.535Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "cd \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\" && npx tsc --noEmit 2>&1 | head -30",
        "description": "Type-check the project to catch any syntax errors"
      },
      "tool_response": {
        "stdout": "",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01TAeRCbtgBWhApnS13hv8oQ"
    }
  },
  {
    "timestamp": "2026-02-28T05:59:35.986Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Clean. Here's what was done:\n\n- **Merged into one concept** at the original `settings-json` slot, now with slug `settings` and title \"Settings & Configuration\"\n- **Kept unique content from both:**\n  - From the first: `settings.local.json` section, \"What Belongs Where\" table, screenshot\n  - From the second: Environment Variables section\n- **Merged overlapping content:**\n  - File locations + merge order ‚Üí single \"Settings File Locations\" section with the 3-layer diagram + `.claude/` directory tree\n  - `settings.json` example ‚Üí enriched with `model`, `mcpServers`, and `deny` from the second concept's \"Key Settings\"\n  - Tips ‚Üí combined into one paragraph\n- **Removed the duplicate** \"Settings & Configuration\" concept entirely"
    }
  },
  {
    "timestamp": "2026-02-28T05:59:38.310Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a7ba1daf44a1f8b8c",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42\\subagents\\agent-a7ba1daf44a1f8b8c.jsonl",
      "agent_type": "",
      "last_assistant_message": "can u also remove the \"settings.json vs settings.local.json\" slug concept that might still be referenced anywhere"
    }
  },
  {
    "timestamp": "2026-02-28T06:32:07.914Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionStart",
      "source": "startup",
      "model": "claude-sonnet-4-6"
    }
  },
  {
    "timestamp": "2026-02-28T06:32:53.010Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "open the browse and go to youtube.com"
    }
  },
  {
    "timestamp": "2026-02-28T06:33:07.701Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_navigate",
      "tool_input": {
        "url": "https://www.youtube.com"
      },
      "tool_response": [
        {
          "type": "text",
          "text": "### Ran Playwright code\n```js\nawait page.goto('https://www.youtube.com');\n```\n### Page\n- Page URL: https://www.youtube.com/\n- Page Title: YouTube\n- Console: 1 errors, 0 warnings\n### Snapshot\n```yaml\n- generic [ref=e2]:\n  - banner [ref=e4]:\n    - generic [ref=e6]:\n      - generic [ref=e7]:\n        - button \"Guide\" [ref=e9] [cursor=pointer]:\n          - generic [ref=e12]:\n            - img\n        - generic [ref=e13]:\n          - link \"YouTube Home\" [ref=e14] [cursor=pointer]:\n            - /url: /\n            - generic [ref=e19]:\n              - img\n          - generic [ref=e20]: IN\n        - button \"Skip navigation\" [ref=e24] [cursor=pointer]:\n          - generic [ref=e25]: Skip navigation\n      - generic [ref=e29]:\n        - search [ref=e30]:\n          - generic [ref=e31]:\n            - combobox \"Search\" [expanded] [ref=e34]\n            - button \"Search\" [ref=e35] [cursor=pointer]:\n              - generic [ref=e38]:\n                - img\n        - generic [ref=e40]:\n          - button \"Search with your voice\" [ref=e42] [cursor=pointer]:\n            - generic [ref=e46]:\n              - img\n          - tooltip \"tooltip\"\n      - generic [ref=e51]:\n        - button \"Settings\" [ref=e56] [cursor=pointer]:\n          - generic [ref=e59]:\n            - img\n        - link \"Sign in\" [ref=e62] [cursor=pointer]:\n          - /url: https://accounts.google.com/ServiceLogin?service=youtube&uilel=3&passive=true&continue=https%3A%2F%2Fwww.youtube.com%2Fsignin%3Faction_handle_signin%3Dtrue%26app%3Ddesktop%26hl%3Den%26next%3Dhttps%253A%252F%252Fwww.youtube.com%252F&hl=en&ec=65620\n          - generic [ref=e66]:\n            - img\n          - generic [ref=e67]: Sign in\n  - navigation [ref=e71]:\n    - generic [ref=e72]:\n      - link \"Home\" [ref=e74] [cursor=pointer]:\n        - /url: /\n        - generic [ref=e77]:\n          - img\n        - generic [ref=e78]: Home\n      - link \"Shorts\" [ref=e80] [cursor=pointer]:\n        - /url: /shorts/\n        - generic [ref=e83]:\n          - img\n        - generic [ref=e84]: Shorts\n      - link \"Subscriptions\" [ref=e86] [cursor=pointer]:\n        - /url: /feed/subscriptions\n        - generic [ref=e89]:\n          - img\n        - generic [ref=e90]: Subscriptions\n      - link \"You\" [ref=e92] [cursor=pointer]:\n        - /url: /feed/you\n        - generic [ref=e95]:\n          - img\n        - generic [ref=e96]: You\n  - generic [ref=e97]:\n    - main [ref=e98]:\n      - generic [ref=e108]:\n        - generic [ref=e109]: Try searching to get started\n        - generic [ref=e110]: Start watching videos to help us build a feed of videos you'll love.\n    - text: ‚Ä¢\n```\n### Events\n- New console entries: .playwright-mcp\\console-2026-02-28T06-33-06-250Z.log#L1\n- [INFO] LegacyDataMixin will be applied to all lega...xvjjafIA/m=kevlar_base_module,kevlar_main_module:9901\n- [ERROR] Failed to load resource: the server respon...lel=3&flowName=GlifWebSignIn&flowEntry=ServiceLogin:0\n- [INFO] Banner not shown: beforeinstallpromptevent....pt() to show the banner. @ https://www.youtube.com/:0"
        }
      ],
      "tool_use_id": "toolu_01PimscApsJanjpbU6Ahj9aB"
    }
  },
  {
    "timestamp": "2026-02-28T06:33:09.292Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Browser is open and navigated to YouTube.com."
    }
  },
  {
    "timestamp": "2026-02-28T06:33:10.912Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "af4af54181aad4be8",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b\\subagents\\agent-af4af54181aad4be8.jsonl",
      "agent_type": "",
      "last_assistant_message": "search for lofi music"
    }
  },
  {
    "timestamp": "2026-02-28T06:34:21.487Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "open the browse and go to localhost 3000 and logout from application"
    }
  },
  {
    "timestamp": "2026-02-28T06:34:24.216Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_navigate",
      "tool_input": {
        "url": "http://localhost:3000"
      },
      "tool_response": [
        {
          "type": "text",
          "text": "### Ran Playwright code\n```js\nawait page.goto('http://localhost:3000');\n```\n### Page\n- Page URL: http://localhost:3000/login\n- Page Title: Claude Code Learning Hub\n### Snapshot\n```yaml\n- generic [active] [ref=e1]:\n  - generic [ref=e5]:\n    - generic [ref=e6]:\n      - generic [ref=e8]: CC\n      - generic [ref=e9]:\n        - heading \"Claude Code Learning Hub\" [level=1] [ref=e10]\n        - paragraph [ref=e11]: Welcome back ‚Äî sign in to continue\n    - button \"Continue with Google\" [ref=e13]:\n      - img [ref=e14]\n      - text: Continue with Google\n    - generic [ref=e21]: or continue with email\n    - generic [ref=e23]:\n      - generic [ref=e24]:\n        - generic [ref=e25]: Email address\n        - textbox \"Email address\" [ref=e26]:\n          - /placeholder: you@example.com\n      - generic [ref=e27]:\n        - generic [ref=e28]: Password\n        - textbox \"Password\" [ref=e29]:\n          - /placeholder: ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\n      - button \"Sign in\" [ref=e30]\n    - paragraph [ref=e31]:\n      - text: Don't have an account?\n      - link \"Create one\" [ref=e32] [cursor=pointer]:\n        - /url: /signup\n  - region \"Notifications alt+T\"\n  - button \"Open Next.js Dev Tools\" [ref=e38] [cursor=pointer]:\n    - img [ref=e39]\n```\n### Events\n- [INFO] %cDownload the React DevTools for a better ...atic/chunks/node_modules_next_dist_f3530cac._.js:2297\n- [LOG] [HMR] connected @ http://localhost:3000/_nex...atic/chunks/node_modules_next_dist_f3530cac._.js:2297"
        }
      ],
      "tool_use_id": "toolu_015ZdN76Jn2CZyWvvpEHnNyg"
    }
  },
  {
    "timestamp": "2026-02-28T06:34:30.922Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "The app redirected to `/login`, which means there's no active session ‚Äî you're already logged out. If you'd like to log in first and then log out, I can do that. Just provide your credentials."
    }
  },
  {
    "timestamp": "2026-02-28T06:34:32.272Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a8d0d2b089aa58e53",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b\\subagents\\agent-a8d0d2b089aa58e53.jsonl",
      "agent_type": "",
      "last_assistant_message": "login with my credentials and then logout"
    }
  },
  {
    "timestamp": "2026-02-28T06:35:01.203Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "open the browse and go to localhost 3000 and login and use the credential johndoe@gmail.com and password Test@123"
    }
  },
  {
    "timestamp": "2026-02-28T06:35:03.154Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_navigate",
      "tool_input": {
        "url": "http://localhost:3000"
      },
      "tool_response": [
        {
          "type": "text",
          "text": "### Ran Playwright code\n```js\nawait page.goto('http://localhost:3000');\n```\n### Page\n- Page URL: http://localhost:3000/login\n- Page Title: Claude Code Learning Hub\n### Snapshot\n```yaml\n- generic [active] [ref=e1]:\n  - generic [ref=e5]:\n    - generic [ref=e6]:\n      - generic [ref=e8]: CC\n      - generic [ref=e9]:\n        - heading \"Claude Code Learning Hub\" [level=1] [ref=e10]\n        - paragraph [ref=e11]: Welcome back ‚Äî sign in to continue\n    - button \"Continue with Google\" [ref=e13]:\n      - img [ref=e14]\n      - text: Continue with Google\n    - generic [ref=e21]: or continue with email\n    - generic [ref=e23]:\n      - generic [ref=e24]:\n        - generic [ref=e25]: Email address\n        - textbox \"Email address\" [ref=e26]:\n          - /placeholder: you@example.com\n      - generic [ref=e27]:\n        - generic [ref=e28]: Password\n        - textbox \"Password\" [ref=e29]:\n          - /placeholder: ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\n      - button \"Sign in\" [ref=e30]\n    - paragraph [ref=e31]:\n      - text: Don't have an account?\n      - link \"Create one\" [ref=e32] [cursor=pointer]:\n        - /url: /signup\n  - region \"Notifications alt+T\"\n  - button \"Open Next.js Dev Tools\" [ref=e38] [cursor=pointer]:\n    - img [ref=e39]\n  - alert [ref=e42]\n```\n### Events\n- [INFO] %cDownload the React DevTools for a better ...atic/chunks/node_modules_next_dist_f3530cac._.js:2297\n- [LOG] [HMR] connected @ http://localhost:3000/_nex...atic/chunks/node_modules_next_dist_f3530cac._.js:2297"
        }
      ],
      "tool_use_id": "toolu_01A7j66tCmghzchL9T3FD8oe"
    }
  },
  {
    "timestamp": "2026-02-28T06:35:09.055Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_fill_form",
      "tool_input": {
        "fields": [
          {
            "name": "Email address",
            "type": "textbox",
            "ref": "e26",
            "value": "johndoe@gmail.com"
          },
          {
            "name": "Password",
            "type": "textbox",
            "ref": "e29",
            "value": "Test@123"
          }
        ]
      },
      "tool_response": [
        {
          "type": "text",
          "text": "### Ran Playwright code\n```js\nawait page.getByRole('textbox', { name: 'Email address' }).fill('johndoe@gmail.com');\nawait page.getByRole('textbox', { name: 'Password' }).fill('Test@123');\n```"
        }
      ],
      "tool_use_id": "toolu_018aL5PMERiLUEWpRBLy5QcZ"
    }
  },
  {
    "timestamp": "2026-02-28T06:35:15.357Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_click",
      "tool_input": {
        "ref": "e30",
        "element": "Sign in button"
      },
      "tool_response": [
        {
          "type": "text",
          "text": "### Ran Playwright code\n```js\nawait page.getByRole('button', { name: 'Sign in' }).click();\n```\n### Page\n- Page URL: http://localhost:3000/\n- Page Title: Claude Code Learning Hub\n### Snapshot\n```yaml\n- <changed> generic [active] [ref=e1]:\n  - banner [ref=e43]:\n    - generic [ref=e44]:\n      - link \"Claude Code Learning Hub\" [ref=e45] [cursor=pointer]:\n        - /url: /\n      - generic [ref=e46]:\n        - generic [ref=e47]:\n          - generic [ref=e48]: J\n          - generic [ref=e49]: JohnDoe\n        - button \"Sign out\" [ref=e51]:\n          - img\n          - generic [ref=e52]: Sign out\n        - button \"Toggle theme\" [ref=e53]:\n          - img\n  - generic [ref=e54]:\n    - main [ref=e55]:\n      - tablist \"Filter by category\" [ref=e57]:\n        - tab \"All\" [selected] [ref=e58]\n        - tab \"Core CLI\" [ref=e59]\n        - tab \"Intelligence\" [ref=e60]\n        - tab \"Memory\" [ref=e61]\n        - tab \"Automation\" [ref=e62]\n        - tab \"Integration\" [ref=e63]\n      - paragraph [ref=e64]: Showing 17 of 17 concepts\n      - generic [ref=e65]:\n        - link \"üöÄ Core CLI Getting Started Install Claude Code and run your first AI-powered coding session. Beginner\" [ref=e66] [cursor=pointer]:\n          - /url: /concepts/getting-started\n          - generic [ref=e68]:\n            - generic [ref=e69]: üöÄ\n            - generic [ref=e70]: Core CLI\n            - heading \"Getting Started\" [level=3] [ref=e71]\n            - paragraph [ref=e72]: Install Claude Code and run your first AI-powered coding session.\n            - generic [ref=e74]: Beginner\n        - link \"üìÑ Memory CLAUDE.md Give Claude persistent project-level instructions via a markdown file. Intermediate\" [ref=e75] [cursor=pointer]:\n          - /url: /concepts/claude-md\n          - generic [ref=e77]:\n            - generic [ref=e78]: üìÑ\n            - generic [ref=e79]: Memory\n            - heading \"CLAUDE.md\" [level=3] [ref=e80]\n            - paragraph [ref=e81]: Give Claude persistent project-level instructions via a markdown file.\n            - generic [ref=e83]: Intermediate\n        - link \"‚å®Ô∏è Core CLI CLI Commands Master the full set of CLI flags, modes, and slash commands. Beginner\" [ref=e84] [cursor=pointer]:\n          - /url: /concepts/cli-commands\n          - generic [ref=e86]:\n            - generic [ref=e87]: ‚å®Ô∏è\n            - generic [ref=e88]: Core CLI\n            - heading \"CLI Commands\" [level=3] [ref=e89]\n            - paragraph [ref=e90]: Master the full set of CLI flags, modes, and slash commands.\n            - generic [ref=e92]: Beginner\n        - link \"‚ö° Core CLI Keyboard Shortcuts Navigate and control Claude Code sessions with keyboard shortcuts. Beginner\" [ref=e93] [cursor=pointer]:\n          - /url: /concepts/keyboard-shortcuts\n          - generic [ref=e95]:\n            - generic [ref=e96]: ‚ö°\n            - generic [ref=e97]: Core CLI\n            - heading \"Keyboard Shortcuts\" [level=3] [ref=e98]\n            - paragraph [ref=e99]: Navigate and control Claude Code sessions with keyboard shortcuts.\n            - generic [ref=e101]: Beginner\n        - link \"üîê Core CLI Permission Modes Control what Claude can do automatically vs. what requires your approval. Intermediate\" [ref=e102] [cursor=pointer]:\n          - /url: /concepts/permission-modes\n          - generic [ref=e104]:\n            - generic [ref=e105]: üîê\n            - generic [ref=e106]: Core CLI\n            - heading \"Permission Modes\" [level=3] [ref=e107]\n            - paragraph [ref=e108]: Control what Claude can do automatically vs. what requires your approval.\n            - generic [ref=e110]: Intermediate\n        - link \"‚öôÔ∏è Core CLI Settings & Configuration Configure Claude Code globally or per-project, and keep secrets out of version control. Beginner\" [ref=e111] [cursor=pointer]:\n          - /url: /concepts/settings\n          - generic [ref=e113]:\n            - generic [ref=e114]: ‚öôÔ∏è\n            - generic [ref=e115]: Core CLI\n            - heading \"Settings & Configuration\" [level=3] [ref=e116]\n            - paragraph [ref=e117]: Configure Claude Code globally or per-project, and keep secrets out of version control.\n            - generic [ref=e119]: Beginner\n        - link \"üìã Intelligence Plan Mode vs Think Mode Make Claude plan before acting ‚Äî get architectural clarity upfront. Intermediate\" [ref=e120] [cursor=pointer]:\n          - /url: /concepts/plan-vs-think-mode\n          - generic [ref=e122]:\n            - generic [ref=e123]: üìã\n            - generic [ref=e124]: Intelligence\n            - heading \"Plan Mode vs Think Mode\" [level=3] [ref=e125]\n            - paragraph [ref=e126]: Make Claude plan before acting ‚Äî get architectural clarity upfront.\n            - generic [ref=e128]: Intermediate\n        - link \"üõ†Ô∏è Intelligence Tool Use Understand the tools Claude uses to interact with your system. Intermediate\" [ref=e129] [cursor=pointer]:\n          - /url: /concepts/tool-use\n          - generic [ref=e131]:\n            - generic [ref=e132]: üõ†Ô∏è\n            - generic [ref=e133]: Intelligence\n            - heading \"Tool Use\" [level=3] [ref=e134]\n            - paragraph [ref=e135]: Understand the tools Claude uses to interact with your system.\n            - generic [ref=e137]: Intermediate\n        - link \"üß† Intelligence Extended Thinking Enable deep reasoning for complex architectural and algorithmic problems. Advanced\" [ref=e138] [cursor=pointer]:\n          - /url: /concepts/extended-thinking\n          - generic [ref=e140]:\n            - generic [ref=e141]: üß†\n            - generic [ref=e142]: Intelligence\n            - heading \"Extended Thinking\" [level=3] [ref=e143]\n            - paragraph [ref=e144]: Enable deep reasoning for complex architectural and algorithmic problems.\n            - generic [ref=e146]: Advanced\n        - link \"üóÇÔ∏è Memory Auto Memory Persist knowledge across sessions with Claude's auto memory system. Intermediate\" [ref=e147] [cursor=pointer]:\n          - /url: /concepts/auto-memory\n          - generic [ref=e149]:\n            - generic [ref=e150]: üóÇÔ∏è\n            - generic [ref=e151]: Memory\n            - heading \"Auto Memory\" [level=3] [ref=e152]\n            - paragraph [ref=e153]: Persist knowledge across sessions with Claude's auto memory system.\n            - generic [ref=e155]: Intermediate\n        - link \"üîÑ Memory Context Management Manage Claude's context window to maintain performance on long sessions. Intermediate\" [ref=e156] [cursor=pointer]:\n          - /url: /concepts/context-management\n          - generic [ref=e158]:\n            - generic [ref=e159]: üîÑ\n            - generic [ref=e160]: Memory\n            - heading \"Context Management\" [level=3] [ref=e161]\n            - paragraph [ref=e162]: Manage Claude's context window to maintain performance on long sessions.\n            - generic [ref=e164]: Intermediate\n        - link \"‚ö° Memory Prompt Caching Reduce API costs and latency by caching repeated context prefixes. Advanced\" [ref=e165] [cursor=pointer]:\n          - /url: /concepts/prompt-caching\n          - generic [ref=e167]:\n            - generic [ref=e168]: ‚ö°\n            - generic [ref=e169]: Memory\n            - heading \"Prompt Caching\" [level=3] [ref=e170]\n            - paragraph [ref=e171]: Reduce API costs and latency by caching repeated context prefixes.\n            - generic [ref=e173]: Advanced\n        - link \"ü§ñ Automation SubAgents Spawn specialized subagents for parallel, isolated, and focused tasks. Advanced\" [ref=e174] [cursor=pointer]:\n          - /url: /concepts/subagents\n          - generic [ref=e176]:\n            - generic [ref=e177]: ü§ñ\n            - generic [ref=e178]: Automation\n            - heading \"SubAgents\" [level=3] [ref=e179]\n            - paragraph [ref=e180]: Spawn specialized subagents for parallel, isolated, and focused tasks.\n            - generic [ref=e182]: Advanced\n        - link \"ü™ù Automation Hooks System Run shell commands automatically before or after Claude's tool calls. Advanced\" [ref=e183] [cursor=pointer]:\n          - /url: /concepts/hooks\n          - generic [ref=e185]:\n            - generic [ref=e186]: ü™ù\n            - generic [ref=e187]: Automation\n            - heading \"Hooks System\" [level=3] [ref=e188]\n            - paragraph [ref=e189]: Run shell commands automatically before or after Claude's tool calls.\n            - generic [ref=e191]: Advanced\n        - link \"üéØ Automation Skills System Create custom slash commands that expand into full prompts for repeated workflows. Intermediate\" [ref=e192] [cursor=pointer]:\n          - /url: /concepts/skills\n          - generic [ref=e194]:\n            - generic [ref=e195]: üéØ\n            - generic [ref=e196]: Automation\n            - heading \"Skills System\" [level=3] [ref=e197]\n            - paragraph [ref=e198]: Create custom slash commands that expand into full prompts for repeated workflows.\n            - generic [ref=e200]: Intermediate\n        - link \"üîå Integration MCP (Model Context Protocol) Connect Claude to external tools, databases, and services via MCP servers. Advanced\" [ref=e201] [cursor=pointer]:\n          - /url: /concepts/mcp\n          - generic [ref=e203]:\n            - generic [ref=e204]: üîå\n            - generic [ref=e205]: Integration\n            - heading \"MCP (Model Context Protocol)\" [level=3] [ref=e206]\n            - paragraph [ref=e207]: Connect Claude to external tools, databases, and services via MCP servers.\n            - generic [ref=e209]: Advanced\n        - link \"üå≥ Automation Worktrees Isolate experimental changes in git worktrees for safe parallel development. Advanced\" [ref=e210] [cursor=pointer]:\n          - /url: /concepts/worktrees\n          - generic [ref=e212]:\n            - generic [ref=e213]: üå≥\n            - generic [ref=e214]: Automation\n            - heading \"Worktrees\" [level=3] [ref=e215]\n            - paragraph [ref=e216]: Isolate experimental changes in git worktrees for safe parallel development.\n            - generic [ref=e218]: Advanced\n    - generic [ref=e220]:\n      - generic [ref=e221]:\n        - img \"Mohanaprasad G\" [ref=e222]\n        - generic [ref=e223]:\n          - heading \"Mohanaprasad G\" [level=3] [ref=e224]\n          - paragraph [ref=e225]: Creator & Developer\n      - paragraph [ref=e226]: Full-stack developer with 7 years of industry experience building scalable web applications, cloud-native solutions on AWS, and generative AI integrations. I work across the entire product lifecycle ‚Äî from backend architecture to polished frontend experiences.\n      - paragraph [ref=e227]: I built this app because mastering Claude Code's full potential takes time and there's no single structured resource for it. This platform is my way of sharing what I've learned ‚Äî giving developers a hands-on path from CLI basics to advanced agentic workflows, completely free.\n      - generic [ref=e228]:\n        - link \"linkedin.com/in/mohanaprasad-g-23926a209\" [ref=e229] [cursor=pointer]:\n          - /url: https://www.linkedin.com/in/mohanaprasad-g-23926a209\n          - img [ref=e230]\n          - text: linkedin.com/in/mohanaprasad-g-23926a209\n        - link \"mohanaprasadgmp@gmail.com\" [ref=e234] [cursor=pointer]:\n          - /url: mailto:mohanaprasadgmp@gmail.com\n          - img [ref=e235]\n          - text: mohanaprasadgmp@gmail.com\n    - contentinfo [ref=e238]:\n      - generic [ref=e239]: ¬© 2026 Mohanaprasad G. All rights reserved.\n  - region \"Notifications alt+T\":\n    - list:\n      - listitem [ref=e240]:\n        - img [ref=e242]\n        - generic [ref=e245]: Welcome back!\n      - listitem [ref=e246]:\n        - img [ref=e248]\n        - generic [ref=e251]: Welcome back!\n  - ref=e38 [unchanged]\n  - ref=e42 [unchanged]\n```"
        }
      ],
      "tool_use_id": "toolu_01TgkpYCWeYqvxuU2pdZCsAt"
    }
  },
  {
    "timestamp": "2026-02-28T06:35:17.784Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Successfully logged in as JohnDoe. The app is now on the homepage showing all 17 concepts. A \"Welcome back!\" toast notification is visible in the top-right corner."
    }
  },
  {
    "timestamp": "2026-02-28T06:35:18.856Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "a6e0eb7d29b0c2344",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b\\subagents\\agent-a6e0eb7d29b0c2344.jsonl",
      "agent_type": "",
      "last_assistant_message": "now logout from the application"
    }
  },
  {
    "timestamp": "2026-02-28T06:39:35.549Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "use  has section 3 in mcp concept\n2. image 2  has section 4\n3. image 3 has section 5 and remove other section"
    }
  },
  {
    "timestamp": "2026-02-28T06:39:43.084Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Grep",
      "tool_input": {
        "pattern": "mcp",
        "path": "src/data/concepts.ts",
        "output_mode": "content",
        "-n": true,
        "head_limit": 20
      },
      "tool_response": {
        "mode": "content",
        "numFiles": 0,
        "filenames": [],
        "content": "591:  \"mcpServers\": {\r\n860:mcp__*        ‚Äî Tools from connected MCP servers`,\r\n1580:    slug: \"mcp\",\r\n1604:‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\r\n1626:  \"mcpServers\": {\r\n1651:          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\r\n1677:        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",",
        "numLines": 7,
        "appliedLimit": 20
      },
      "tool_use_id": "toolu_01NgFQ6C4VrLC3YQG52aue3M"
    }
  },
  {
    "timestamp": "2026-02-28T06:39:45.798Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1580,
        "limit": 150
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]",
          "numLines": 150,
          "startLine": 1580,
          "totalLines": 1768
        }
      },
      "tool_use_id": "toolu_01P5SYyEK8kegRnEuD2qKXv1"
    }
  },
  {
    "timestamp": "2026-02-28T06:40:12.348Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "src/app/concepts/**/*.tsx"
      },
      "tool_response": {
        "filenames": [],
        "durationMs": 1626,
        "numFiles": 0,
        "truncated": false
      },
      "tool_use_id": "toolu_01HCXngbJyiPYbhTix8Bvej9"
    }
  },
  {
    "timestamp": "2026-02-28T06:40:15.116Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "src/app/concepts/[slug]/*.tsx"
      },
      "tool_response": {
        "filenames": [],
        "durationMs": 1115,
        "numFiles": 0,
        "truncated": false
      },
      "tool_use_id": "toolu_01Kh1mC9WjaGGoCBkxYMuoVY"
    }
  },
  {
    "timestamp": "2026-02-28T06:40:18.312Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "src/app/concepts/**/*"
      },
      "tool_response": {
        "filenames": [],
        "durationMs": 1342,
        "numFiles": 0,
        "truncated": false
      },
      "tool_use_id": "toolu_013USviXATqrNctg7mTExChi"
    }
  },
  {
    "timestamp": "2026-02-28T06:40:21.654Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Glob",
      "tool_input": {
        "pattern": "src/app/concepts*"
      },
      "tool_response": {
        "filenames": [],
        "durationMs": 1229,
        "numFiles": 0,
        "truncated": false
      },
      "tool_use_id": "toolu_015J5EqQdfKaEeKh5hTQrNEG"
    }
  },
  {
    "timestamp": "2026-02-28T06:40:24.772Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "ls \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\""
      },
      "tool_response": {
        "stdout": "(auth)\n(main)\nactions\nauth\nglobals.css\nicon.svg\nlayout.tsx",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01G4rHkscCoXySqUUzGoAhLK"
    }
  },
  {
    "timestamp": "2026-02-28T06:40:38.914Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Bash",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T06:42:42.580Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "ls \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\""
      },
      "tool_response": {
        "stdout": "concepts\nlayout.tsx\npage.tsx",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01U4zcbM4EGtRXdoo4szCM8K"
    }
  },
  {
    "timestamp": "2026-02-28T06:42:47.563Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "ls \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\""
      },
      "tool_response": {
        "stdout": "[slug]",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01YL7gGfJxpEc8A96bitX2vN"
    }
  },
  {
    "timestamp": "2026-02-28T06:42:50.881Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "ls \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\""
      },
      "tool_response": {
        "stdout": "page.tsx",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_011gGyb8HUBEREjD68oo8GND"
    }
  },
  {
    "timestamp": "2026-02-28T06:42:54.491Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\\page.tsx"
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\\page.tsx",
          "content": "import { notFound } from 'next/navigation';\nimport Link from 'next/link';\nimport { concepts, difficultyBadgeStyles } from '@/data/concepts';\nimport ConceptCard from '@/components/ConceptCard';\nimport CodeBlock from '@/components/CodeBlock';\nimport LikeButton from '@/components/LikeButton';\nimport CommentsSection from '@/components/CommentsSection';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Separator } from '@/components/ui/separator';\nimport { ChevronLeft, ExternalLink } from 'lucide-react';\nimport ScreenshotViewer from '@/components/ScreenshotViewer';\nimport { createClient } from '@/lib/supabase/server';\nimport { prisma } from '@/lib/prisma';\n\nexport const dynamic = 'force-dynamic';\n\ntype Params = Promise<{ slug: string }>;\n\nexport function generateStaticParams() {\n  return concepts.map((c) => ({ slug: c.slug }));\n}\n\nexport async function generateMetadata({ params }: { params: Params }) {\n  const { slug } = await params;\n  const concept = concepts.find((c) => c.slug === slug);\n  if (!concept) return {};\n  return {\n    title: `${concept.title} ‚Äî Claude Code Learning Hub`,\n    description: concept.shortDesc,\n  };\n}\n\nexport default async function ConceptPage({ params }: { params: Params }) {\n  const { slug } = await params;\n  const concept = concepts.find((c) => c.slug === slug);\n\n  if (!concept || !concept.released) notFound();\n\n  const related = concepts\n    .filter((c) => c.category === concept.category && c.slug !== concept.slug)\n    .slice(0, 3);\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  const [likesCount, userLike, rawComments] = await Promise.all([\n    prisma.conceptLike.count({ where: { conceptSlug: slug } }),\n    user\n      ? prisma.conceptLike.findUnique({\n          where: { userId_conceptSlug: { userId: user.id, conceptSlug: slug } },\n        })\n      : Promise.resolve(null),\n    prisma.conceptComment.findMany({\n      where: { conceptSlug: slug, parentId: null },\n      include: {\n        profile: { select: { name: true } },\n        likes: { select: { userId: true } },\n        replies: {\n          include: {\n            profile: { select: { name: true } },\n            likes: { select: { userId: true } },\n          },\n          orderBy: { createdAt: 'asc' },\n        },\n      },\n      orderBy: { createdAt: 'asc' },\n    }),\n  ] as const);\n\n  const comments = rawComments.map((c: any) => ({\n    id: c.id,\n    content: c.content,\n    createdAt: c.createdAt,\n    userId: c.userId,\n    profile: c.profile,\n    likeCount: c.likes.length,\n    userLiked: user ? c.likes.some((l:any) => l.userId === user.id) : false,\n    replies: c.replies.map((r:any) => ({\n      id: r.id,\n      content: r.content,\n      createdAt: r.createdAt,\n      userId: r.userId,\n      profile: r.profile,\n      likeCount: r.likes.length,\n      userLiked: user ? r.likes.some((l:any) => l.userId === user.id) : false,\n      replies: [] as never[],\n    })),\n  }));\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-[#0a0a0a] text-gray-900 dark:text-white transition-colors\">\n\n      <div className=\"mx-auto max-w-4xl px-6 py-12\">\n        {/* Concept header */}\n        <header className=\"mb-12\">\n          <div className=\"flex items-start gap-5 mb-6\">\n            <span className=\"text-6xl leading-none\" aria-hidden=\"true\">\n              {concept.emoji}\n            </span>\n            <div className=\"flex-1 min-w-0 pt-1\">\n              <div className=\"flex flex-wrap items-center gap-2 mb-3\">\n                <Badge\n                  variant=\"outline\"\n                  className=\"border-amber-500/30 dark:border-amber-400/30 text-amber-600 dark:text-amber-400 bg-amber-500/10 dark:bg-amber-400/10\"\n                >\n                  {concept.category}\n                </Badge>\n                <Badge\n                  variant=\"outline\"\n                  className={difficultyBadgeStyles[concept.difficulty]}\n                >\n                  {concept.difficulty}\n                </Badge>\n              </div>\n              <h1 className=\"text-3xl font-extrabold tracking-tight text-gray-900 dark:text-white mb-3\">\n                {concept.title}\n              </h1>\n              <p className=\"text-gray-500 dark:text-zinc-400 text-lg leading-relaxed\">\n                {concept.shortDesc}\n              </p>\n            </div>\n          </div>\n\n          {/* Section nav */}\n          <Separator className=\"mb-4 bg-gray-200 dark:bg-zinc-800\" />\n          <nav className=\"flex flex-wrap gap-1\" aria-label=\"Section navigation\">\n            {concept.sections.map((section, i) => (\n              <Button\n                key={i}\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"text-xs text-gray-400 dark:text-zinc-500 hover:text-amber-600 dark:hover:text-amber-400 hover:bg-amber-500/10 dark:hover:bg-amber-400/10 h-7 px-2\"\n                asChild\n              >\n                <a href={`#section-${i}`}>{section.heading}</a>\n              </Button>\n            ))}\n          </nav>\n        </header>\n\n        {/* Sections */}\n        <article className=\"space-y-12\">\n          {concept.sections.map((section, i) => (\n            <section key={i} id={`section-${i}`} className=\"scroll-mt-20\">\n              <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-4 flex items-center gap-3\">\n                <span className=\"flex h-7 w-7 items-center justify-center rounded-full bg-amber-500/10 dark:bg-amber-400/10 text-xs font-bold text-amber-600 dark:text-amber-400\">\n                  {i + 1}\n                </span>\n                {section.heading}\n              </h2>\n\n              <p className=\"text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                {section.body}\n              </p>\n\n              {section.bullets && (\n                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.bullets.map((bullet, j) => (\n                    <li key={j}>{bullet}</li>\n                  ))}\n                </ul>\n              )}\n\n              {section.code && (\n                <CodeBlock\n                  language={section.code.language}\n                  content={section.code.content}\n                />\n              )}\n\n              {section.screenshots && (\n                <ScreenshotViewer screenshots={section.screenshots} carousel={section.carousel} />\n              )}\n\n              {section.table && (\n                <div className=\"mt-4 overflow-x-auto\">\n                  <table className=\"w-full text-sm border border-zinc-700 rounded-lg overflow-hidden\">\n                    <thead>\n                      <tr className=\"bg-zinc-800 text-zinc-300\">\n                        {section.table.headers.map((h, j) => (\n                          <th key={j} className=\"text-left px-4 py-2 font-semibold border-b border-zinc-700\">\n                            {h}\n                          </th>\n                        ))}\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {section.table.rows.map((row, j) => (\n                        <tr key={j} className={j % 2 === 0 ? \"bg-zinc-900\" : \"bg-zinc-800/50\"}>\n                          {row.map((cell, k) => (\n                            <td key={k} className=\"px-4 py-2 text-zinc-300 border-b border-zinc-700/50 font-mono\">\n                              {cell}\n                            </td>\n                          ))}\n                        </tr>\n                      ))}\n                    </tbody>\n                  </table>\n                </div>\n              )}\n            </section>\n          ))}\n        </article>\n\n        {/* Likes */}\n        <div className=\"mt-10 pt-8 border-t border-gray-200 dark:border-zinc-800\">\n          <LikeButton\n            conceptSlug={slug}\n            initialCount={likesCount}\n            initialLiked={!!userLike}\n            userId={user?.id ?? null}\n          />\n        </div>\n\n        {/* Comments */}\n        <CommentsSection\n          conceptSlug={slug}\n          initialComments={comments}\n          userId={user?.id ?? null}\n        />\n\n        {/* References */}\n        {concept.references && concept.references.length > 0 && (\n          <div className=\"mt-12 pt-8 border-t border-gray-200 dark:border-zinc-800\">\n            <h2 className=\"text-base font-semibold text-gray-700 dark:text-zinc-300 mb-3 uppercase tracking-wider text-xs\">\n              Official References\n            </h2>\n            <div className=\"flex flex-col gap-2\">\n              {concept.references.map((ref, i) => (\n                <a\n                  key={i}\n                  href={ref.url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"group flex items-center justify-between rounded-lg border border-gray-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 px-4 py-3 hover:border-amber-400/60 hover:bg-amber-500/5 dark:hover:border-amber-400/60 dark:hover:bg-amber-400/5 transition-all\"\n                >\n                  <div>\n                    <span className=\"text-sm font-medium text-gray-900 dark:text-white group-hover:text-amber-600 dark:group-hover:text-amber-400 transition-colors\">\n                      {ref.label}\n                    </span>\n                    {ref.description && (\n                      <p className=\"text-xs text-gray-500 dark:text-zinc-500 mt-0.5\">{ref.description}</p>\n                    )}\n                  </div>\n                  <ExternalLink className=\"h-3.5 w-3.5 text-gray-400 dark:text-zinc-600 group-hover:text-amber-500 dark:group-hover:text-amber-400 transition-colors shrink-0 ml-4\" />\n                </a>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Related concepts */}\n        {related.length > 0 && (\n          <aside className=\"mt-16 pt-10 border-t border-gray-200 dark:border-zinc-800\">\n            <h2 className=\"text-lg font-bold text-gray-900 dark:text-white mb-5\">\n              More in{' '}\n              <span className=\"text-amber-500 dark:text-amber-400\">{concept.category}</span>\n            </h2>\n            <div className=\"grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-3\">\n              {related.map((c) => (\n                <ConceptCard key={c.slug} concept={c} compact />\n              ))}\n            </div>\n          </aside>\n        )}\n\n        {/* Back to home */}\n        <div className=\"mt-12 pt-8 border-t border-gray-200 dark:border-zinc-800 text-center\">\n          <Button\n            variant=\"outline\"\n            className=\"rounded-full border-gray-300 dark:border-zinc-700 text-gray-500 dark:text-zinc-400 hover:border-amber-500/50 dark:hover:border-amber-400/50 hover:text-amber-600 dark:hover:text-amber-400 bg-transparent\"\n            asChild\n          >\n            <Link href=\"/\">\n              <ChevronLeft className=\"h-4 w-4\" />\n              Back to all concepts\n            </Link>\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
          "numLines": 285,
          "startLine": 1,
          "totalLines": 285
        }
      },
      "tool_use_id": "toolu_01JVrkmZCX4FPaZDWYTkbSCy"
    }
  },
  {
    "timestamp": "2026-02-28T06:43:03.195Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1,
        "limit": 60
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];",
          "numLines": 60,
          "startLine": 1,
          "totalLines": 1768
        }
      },
      "tool_use_id": "toolu_01YQ4UFtU9BErsbu25R2qGfE"
    }
  },
  {
    "timestamp": "2026-02-28T06:44:28.962Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "export interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}",
        "new_string": "export interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "export interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}",
        "newString": "export interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 10,
            "oldLines": 6,
            "newStart": 10,
            "newLines": 8,
            "lines": [
              " export interface ConceptSection {",
              "   heading: string;",
              "   body: string;",
              "+  orderedList?: string[];",
              "+  note?: string;",
              "   bullets?: string[];",
              "   code?: {",
              "     language: string;"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_011Kqmz5E8Y8ygmvTiWPqGcP"
    }
  },
  {
    "timestamp": "2026-02-28T06:44:52.955Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Update",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T06:45:00.462Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },",
        "new_string": "      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n      },\n      {\n        heading: \"Practical Example: Improving Component Generation\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n        orderedList: [\n          \"Open a browser and navigate to your application\",\n          \"Generate a test component\",\n          \"Analyze the visual styling and code quality\",\n          \"Update the generation prompt based on what it observes\",\n          \"Test the improved prompt with a new component\",\n        ],\n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, generate a basic component, review the styling, and update the generation prompt at @src/lib/prompts/generation.tsx to produce better components going forward.\"`,\n        },\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },",
        "newString": "      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n      },\n      {\n        heading: \"Practical Example: Improving Component Generation\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n        orderedList: [\n          \"Open a browser and navigate to your application\",\n          \"Generate a test component\",\n          \"Analyze the visual styling and code quality\",\n          \"Update the generation prompt based on what it observes\",\n          \"Test the improved prompt with a new component\",\n        ],\n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, generate a basic component, review the styling, and update the generation prompt at @src/lib/prompts/generation.tsx to produce better components going forward.\"`,\n        },\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Configuring MCP Servers\",\n        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json ‚Äî MCP server configuration\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Writing an MCP Server\",\n        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",\n        code: {\n          language: \"typescript\",\n          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });\n\n// Register a tool Claude can call\nserver.tool(\n  \"query_database\",\n  \"Run a read-only SQL query against the production DB\",\n  {\n    query: z.string().describe(\"The SQL SELECT query to run\"),\n  },\n  async ({ query }) => {\n    const result = await db.execute(query);\n    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n  }\n);\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1619,
            "oldLines": 65,
            "newStart": 1619,
            "newLines": 48,
            "lines": [
              "         },",
              "       },",
              "       {",
              "-        heading: \"Configuring MCP Servers\",",
              "-        body: \"Add MCP servers to your Claude Code settings. They can be project-specific (.claude/settings.json) or user-wide (~/.claude/settings.json). Each server has a name, command to start it, and optional arguments.\",",
              "+        heading: \"Installing the Playwright MCP Server\",",
              "+        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",",
              "         code: {",
              "+          language: \"bash\",",
              "+          content: `claude mcp add playwright npx @playwright/mcp@latest`,",
              "+        },",
              "+        note: \"This command does two things:\",",
              "+        bullets: [",
              "+          'Names the MCP server \"playwright\"',",
              "+          \"Provides the command that starts the server locally on your machine\",",
              "+        ],",
              "+      },",
              "+      {",
              "+        heading: \"Managing Permissions\",",
              "+        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",",
              "+        code: {",
              "           language: \"json\",",
              "-          content: `// .claude/settings.json ‚Äî MCP server configuration",
              "-{",
              "-  \"mcpServers\": {",
              "-    \"filesystem\": {",
              "-      \"command\": \"npx\",",
              "-      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/files\"]",
              "-    },",
              "-    \"github\": {",
              "-      \"command\": \"npx\",",
              "-      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],",
              "-      \"env\": {",
              "-        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"",
              "-      }",
              "-    },",
              "-    \"postgres\": {",
              "-      \"command\": \"npx\",",
              "-      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\", \"postgresql://localhost/mydb\"]",
              "-    }",
              "+          content: `{",
              "+  \"permissions\": {",
              "+    \"allow\": [\"mcp__playwright\"],",
              "+    \"deny\": []",
              "   }",
              " }`,",
              "         },",
              "+        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",",
              "       },",
              "       {",
              "-        heading: \"Writing an MCP Server\",",
              "-        body: \"MCP servers can be written in any language with an MCP SDK (TypeScript, Python, Go, Rust). A server defines tools (callable functions), resources (readable data), and prompts (reusable templates).\",",
              "+        heading: \"Practical Example: Improving Component Generation\",",
              "+        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",",
              "+        orderedList: [",
              "+          \"Open a browser and navigate to your application\",",
              "+          \"Generate a test component\",",
              "+          \"Analyze the visual styling and code quality\",",
              "+          \"Update the generation prompt based on what it observes\",",
              "+          \"Test the improved prompt with a new component\",",
              "+        ],",
              "         code: {",
              "-          language: \"typescript\",",
              "-          content: `import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";",
              "-import { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";",
              "-import { z } from \"zod\";",
              "-",
              "-const server = new McpServer({ name: \"my-server\", version: \"1.0.0\" });",
              "-",
              "-// Register a tool Claude can call",
              "-server.tool(",
              "-  \"query_database\",",
              "-  \"Run a read-only SQL query against the production DB\",",
              "-  {",
              "-    query: z.string().describe(\"The SQL SELECT query to run\"),",
              "-  },",
              "-  async ({ query }) => {",
              "-    const result = await db.execute(query);",
              "-    return { content: [{ type: \"text\", text: JSON.stringify(result) }] };",
              "-  }",
              "-);",
              "-",
              "-// Start the server",
              "-const transport = new StdioServerTransport();",
              "-await server.connect(transport);`,",
              "+          language: \"text\",",
              "+          content: `\"Navigate to localhost:3000, generate a basic component, review the styling, and update the generation prompt at @src/lib/prompts/generation.tsx to produce better components going forward.\"`,",
              "         },",
              "+        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",",
              "       },",
              "-      {",
              "-        heading: \"Tips\",",
              "-        body: \"Start with official MCP servers from the Model Context Protocol GitHub org ‚Äî they cover filesystem, GitHub, Postgres, Slack, and more. MCP tools appear in Claude as mcp__servername__toolname. Use project-level MCP configs for project-specific integrations and user-level for global tools like GitHub.\",",
              "-      },",
              "     ],",
              "   },",
              "   {"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01LrRa65omtHFf67YEucRETm"
    }
  },
  {
    "timestamp": "2026-02-28T06:45:10.059Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\\page.tsx",
        "old_string": "              <p className=\"text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                {section.body}\n              </p>\n\n              {section.bullets && (\n                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.bullets.map((bullet, j) => (\n                    <li key={j}>{bullet}</li>\n                  ))}\n                </ul>\n              )}\n\n              {section.code && (\n                <CodeBlock\n                  language={section.code.language}\n                  content={section.code.content}\n                />\n              )}",
        "new_string": "              <p className=\"text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                {section.body}\n              </p>\n\n              {section.orderedList && (\n                <ol className=\"mt-3 space-y-1.5 list-decimal list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.orderedList.map((item, j) => (\n                    <li key={j}>{item}</li>\n                  ))}\n                </ol>\n              )}\n\n              {section.code && (\n                <CodeBlock\n                  language={section.code.language}\n                  content={section.code.content}\n                />\n              )}\n\n              {section.note && (\n                <p className=\"mt-3 text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                  {section.note}\n                </p>\n              )}\n\n              {section.bullets && (\n                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.bullets.map((bullet, j) => (\n                    <li key={j}>{bullet}</li>\n                  ))}\n                </ul>\n              )}",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\app\\(main)\\concepts\\[slug]\\page.tsx",
        "oldString": "              <p className=\"text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                {section.body}\n              </p>\n\n              {section.bullets && (\n                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.bullets.map((bullet, j) => (\n                    <li key={j}>{bullet}</li>\n                  ))}\n                </ul>\n              )}\n\n              {section.code && (\n                <CodeBlock\n                  language={section.code.language}\n                  content={section.code.content}\n                />\n              )}",
        "newString": "              <p className=\"text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                {section.body}\n              </p>\n\n              {section.orderedList && (\n                <ol className=\"mt-3 space-y-1.5 list-decimal list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.orderedList.map((item, j) => (\n                    <li key={j}>{item}</li>\n                  ))}\n                </ol>\n              )}\n\n              {section.code && (\n                <CodeBlock\n                  language={section.code.language}\n                  content={section.code.content}\n                />\n              )}\n\n              {section.note && (\n                <p className=\"mt-3 text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                  {section.note}\n                </p>\n              )}\n\n              {section.bullets && (\n                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.bullets.map((bullet, j) => (\n                    <li key={j}>{bullet}</li>\n                  ))}\n                </ul>\n              )}",
        "originalFile": "import { notFound } from 'next/navigation';\nimport Link from 'next/link';\nimport { concepts, difficultyBadgeStyles } from '@/data/concepts';\nimport ConceptCard from '@/components/ConceptCard';\nimport CodeBlock from '@/components/CodeBlock';\nimport LikeButton from '@/components/LikeButton';\nimport CommentsSection from '@/components/CommentsSection';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Separator } from '@/components/ui/separator';\nimport { ChevronLeft, ExternalLink } from 'lucide-react';\nimport ScreenshotViewer from '@/components/ScreenshotViewer';\nimport { createClient } from '@/lib/supabase/server';\nimport { prisma } from '@/lib/prisma';\n\nexport const dynamic = 'force-dynamic';\n\ntype Params = Promise<{ slug: string }>;\n\nexport function generateStaticParams() {\n  return concepts.map((c) => ({ slug: c.slug }));\n}\n\nexport async function generateMetadata({ params }: { params: Params }) {\n  const { slug } = await params;\n  const concept = concepts.find((c) => c.slug === slug);\n  if (!concept) return {};\n  return {\n    title: `${concept.title} ‚Äî Claude Code Learning Hub`,\n    description: concept.shortDesc,\n  };\n}\n\nexport default async function ConceptPage({ params }: { params: Params }) {\n  const { slug } = await params;\n  const concept = concepts.find((c) => c.slug === slug);\n\n  if (!concept || !concept.released) notFound();\n\n  const related = concepts\n    .filter((c) => c.category === concept.category && c.slug !== concept.slug)\n    .slice(0, 3);\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  const [likesCount, userLike, rawComments] = await Promise.all([\n    prisma.conceptLike.count({ where: { conceptSlug: slug } }),\n    user\n      ? prisma.conceptLike.findUnique({\n          where: { userId_conceptSlug: { userId: user.id, conceptSlug: slug } },\n        })\n      : Promise.resolve(null),\n    prisma.conceptComment.findMany({\n      where: { conceptSlug: slug, parentId: null },\n      include: {\n        profile: { select: { name: true } },\n        likes: { select: { userId: true } },\n        replies: {\n          include: {\n            profile: { select: { name: true } },\n            likes: { select: { userId: true } },\n          },\n          orderBy: { createdAt: 'asc' },\n        },\n      },\n      orderBy: { createdAt: 'asc' },\n    }),\n  ] as const);\n\n  const comments = rawComments.map((c: any) => ({\n    id: c.id,\n    content: c.content,\n    createdAt: c.createdAt,\n    userId: c.userId,\n    profile: c.profile,\n    likeCount: c.likes.length,\n    userLiked: user ? c.likes.some((l:any) => l.userId === user.id) : false,\n    replies: c.replies.map((r:any) => ({\n      id: r.id,\n      content: r.content,\n      createdAt: r.createdAt,\n      userId: r.userId,\n      profile: r.profile,\n      likeCount: r.likes.length,\n      userLiked: user ? r.likes.some((l:any) => l.userId === user.id) : false,\n      replies: [] as never[],\n    })),\n  }));\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-[#0a0a0a] text-gray-900 dark:text-white transition-colors\">\n\n      <div className=\"mx-auto max-w-4xl px-6 py-12\">\n        {/* Concept header */}\n        <header className=\"mb-12\">\n          <div className=\"flex items-start gap-5 mb-6\">\n            <span className=\"text-6xl leading-none\" aria-hidden=\"true\">\n              {concept.emoji}\n            </span>\n            <div className=\"flex-1 min-w-0 pt-1\">\n              <div className=\"flex flex-wrap items-center gap-2 mb-3\">\n                <Badge\n                  variant=\"outline\"\n                  className=\"border-amber-500/30 dark:border-amber-400/30 text-amber-600 dark:text-amber-400 bg-amber-500/10 dark:bg-amber-400/10\"\n                >\n                  {concept.category}\n                </Badge>\n                <Badge\n                  variant=\"outline\"\n                  className={difficultyBadgeStyles[concept.difficulty]}\n                >\n                  {concept.difficulty}\n                </Badge>\n              </div>\n              <h1 className=\"text-3xl font-extrabold tracking-tight text-gray-900 dark:text-white mb-3\">\n                {concept.title}\n              </h1>\n              <p className=\"text-gray-500 dark:text-zinc-400 text-lg leading-relaxed\">\n                {concept.shortDesc}\n              </p>\n            </div>\n          </div>\n\n          {/* Section nav */}\n          <Separator className=\"mb-4 bg-gray-200 dark:bg-zinc-800\" />\n          <nav className=\"flex flex-wrap gap-1\" aria-label=\"Section navigation\">\n            {concept.sections.map((section, i) => (\n              <Button\n                key={i}\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"text-xs text-gray-400 dark:text-zinc-500 hover:text-amber-600 dark:hover:text-amber-400 hover:bg-amber-500/10 dark:hover:bg-amber-400/10 h-7 px-2\"\n                asChild\n              >\n                <a href={`#section-${i}`}>{section.heading}</a>\n              </Button>\n            ))}\n          </nav>\n        </header>\n\n        {/* Sections */}\n        <article className=\"space-y-12\">\n          {concept.sections.map((section, i) => (\n            <section key={i} id={`section-${i}`} className=\"scroll-mt-20\">\n              <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-4 flex items-center gap-3\">\n                <span className=\"flex h-7 w-7 items-center justify-center rounded-full bg-amber-500/10 dark:bg-amber-400/10 text-xs font-bold text-amber-600 dark:text-amber-400\">\n                  {i + 1}\n                </span>\n                {section.heading}\n              </h2>\n\n              <p className=\"text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">\n                {section.body}\n              </p>\n\n              {section.bullets && (\n                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">\n                  {section.bullets.map((bullet, j) => (\n                    <li key={j}>{bullet}</li>\n                  ))}\n                </ul>\n              )}\n\n              {section.code && (\n                <CodeBlock\n                  language={section.code.language}\n                  content={section.code.content}\n                />\n              )}\n\n              {section.screenshots && (\n                <ScreenshotViewer screenshots={section.screenshots} carousel={section.carousel} />\n              )}\n\n              {section.table && (\n                <div className=\"mt-4 overflow-x-auto\">\n                  <table className=\"w-full text-sm border border-zinc-700 rounded-lg overflow-hidden\">\n                    <thead>\n                      <tr className=\"bg-zinc-800 text-zinc-300\">\n                        {section.table.headers.map((h, j) => (\n                          <th key={j} className=\"text-left px-4 py-2 font-semibold border-b border-zinc-700\">\n                            {h}\n                          </th>\n                        ))}\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {section.table.rows.map((row, j) => (\n                        <tr key={j} className={j % 2 === 0 ? \"bg-zinc-900\" : \"bg-zinc-800/50\"}>\n                          {row.map((cell, k) => (\n                            <td key={k} className=\"px-4 py-2 text-zinc-300 border-b border-zinc-700/50 font-mono\">\n                              {cell}\n                            </td>\n                          ))}\n                        </tr>\n                      ))}\n                    </tbody>\n                  </table>\n                </div>\n              )}\n            </section>\n          ))}\n        </article>\n\n        {/* Likes */}\n        <div className=\"mt-10 pt-8 border-t border-gray-200 dark:border-zinc-800\">\n          <LikeButton\n            conceptSlug={slug}\n            initialCount={likesCount}\n            initialLiked={!!userLike}\n            userId={user?.id ?? null}\n          />\n        </div>\n\n        {/* Comments */}\n        <CommentsSection\n          conceptSlug={slug}\n          initialComments={comments}\n          userId={user?.id ?? null}\n        />\n\n        {/* References */}\n        {concept.references && concept.references.length > 0 && (\n          <div className=\"mt-12 pt-8 border-t border-gray-200 dark:border-zinc-800\">\n            <h2 className=\"text-base font-semibold text-gray-700 dark:text-zinc-300 mb-3 uppercase tracking-wider text-xs\">\n              Official References\n            </h2>\n            <div className=\"flex flex-col gap-2\">\n              {concept.references.map((ref, i) => (\n                <a\n                  key={i}\n                  href={ref.url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"group flex items-center justify-between rounded-lg border border-gray-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 px-4 py-3 hover:border-amber-400/60 hover:bg-amber-500/5 dark:hover:border-amber-400/60 dark:hover:bg-amber-400/5 transition-all\"\n                >\n                  <div>\n                    <span className=\"text-sm font-medium text-gray-900 dark:text-white group-hover:text-amber-600 dark:group-hover:text-amber-400 transition-colors\">\n                      {ref.label}\n                    </span>\n                    {ref.description && (\n                      <p className=\"text-xs text-gray-500 dark:text-zinc-500 mt-0.5\">{ref.description}</p>\n                    )}\n                  </div>\n                  <ExternalLink className=\"h-3.5 w-3.5 text-gray-400 dark:text-zinc-600 group-hover:text-amber-500 dark:group-hover:text-amber-400 transition-colors shrink-0 ml-4\" />\n                </a>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Related concepts */}\n        {related.length > 0 && (\n          <aside className=\"mt-16 pt-10 border-t border-gray-200 dark:border-zinc-800\">\n            <h2 className=\"text-lg font-bold text-gray-900 dark:text-white mb-5\">\n              More in{' '}\n              <span className=\"text-amber-500 dark:text-amber-400\">{concept.category}</span>\n            </h2>\n            <div className=\"grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-3\">\n              {related.map((c) => (\n                <ConceptCard key={c.slug} concept={c} compact />\n              ))}\n            </div>\n          </aside>\n        )}\n\n        {/* Back to home */}\n        <div className=\"mt-12 pt-8 border-t border-gray-200 dark:border-zinc-800 text-center\">\n          <Button\n            variant=\"outline\"\n            className=\"rounded-full border-gray-300 dark:border-zinc-700 text-gray-500 dark:text-zinc-400 hover:border-amber-500/50 dark:hover:border-amber-400/50 hover:text-amber-600 dark:hover:text-amber-400 bg-transparent\"\n            asChild\n          >\n            <Link href=\"/\">\n              <ChevronLeft className=\"h-4 w-4\" />\n              Back to all concepts\n            </Link>\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
        "structuredPatch": [
          {
            "oldStart": 154,
            "oldLines": 12,
            "newStart": 154,
            "newLines": 12,
            "lines": [
              "                 {section.body}",
              "               </p>",
              " ",
              "-              {section.bullets && (",
              "-                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">",
              "-                  {section.bullets.map((bullet, j) => (",
              "-                    <li key={j}>{bullet}</li>",
              "+              {section.orderedList && (",
              "+                <ol className=\"mt-3 space-y-1.5 list-decimal list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">",
              "+                  {section.orderedList.map((item, j) => (",
              "+                    <li key={j}>{item}</li>",
              "                   ))}",
              "-                </ul>",
              "+                </ol>",
              "               )}",
              " ",
              "               {section.code && ("
            ]
          },
          {
            "oldStart": 169,
            "oldLines": 6,
            "newStart": 169,
            "newLines": 20,
            "lines": [
              "                 />",
              "               )}",
              " ",
              "+              {section.note && (",
              "+                <p className=\"mt-3 text-gray-600 dark:text-zinc-300 leading-relaxed text-[15px]\">",
              "+                  {section.note}",
              "+                </p>",
              "+              )}",
              "+",
              "+              {section.bullets && (",
              "+                <ul className=\"mt-3 space-y-1.5 list-disc list-inside text-gray-600 dark:text-zinc-300 text-[15px] leading-relaxed\">",
              "+                  {section.bullets.map((bullet, j) => (",
              "+                    <li key={j}>{bullet}</li>",
              "+                  ))}",
              "+                </ul>",
              "+              )}",
              "+",
              "               {section.screenshots && (",
              "                 <ScreenshotViewer screenshots={section.screenshots} carousel={section.carousel} />",
              "               )}"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01QH6aoNJ37DLtCCYnRWELqB"
    }
  },
  {
    "timestamp": "2026-02-28T06:45:13.778Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_navigate",
      "tool_input": {
        "url": "http://localhost:3000/concepts/mcp"
      },
      "tool_response": [
        {
          "type": "text",
          "text": "### Ran Playwright code\n```js\nawait page.goto('http://localhost:3000/concepts/mcp');\n```\n### Page\n- Page URL: http://localhost:3000/login\n- Page Title: Claude Code Learning Hub\n### Snapshot\n```yaml\n- generic [active] [ref=e1]:\n  - generic [ref=e5]:\n    - generic [ref=e6]:\n      - generic [ref=e8]: CC\n      - generic [ref=e9]:\n        - heading \"Claude Code Learning Hub\" [level=1] [ref=e10]\n        - paragraph [ref=e11]: Welcome back ‚Äî sign in to continue\n    - button \"Continue with Google\" [ref=e13]:\n      - img [ref=e14]\n      - text: Continue with Google\n    - generic [ref=e21]: or continue with email\n    - generic [ref=e23]:\n      - generic [ref=e24]:\n        - generic [ref=e25]: Email address\n        - textbox \"Email address\" [ref=e26]:\n          - /placeholder: you@example.com\n      - generic [ref=e27]:\n        - generic [ref=e28]: Password\n        - textbox \"Password\" [ref=e29]:\n          - /placeholder: ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\n      - button \"Sign in\" [ref=e30]\n    - paragraph [ref=e31]:\n      - text: Don't have an account?\n      - link \"Create one\" [ref=e32] [cursor=pointer]:\n        - /url: /signup\n  - region \"Notifications alt+T\"\n  - button \"Open Next.js Dev Tools\" [ref=e38] [cursor=pointer]:\n    - img [ref=e39]\n  - alert [ref=e42]\n```\n### Events\n- [INFO] %cDownload the React DevTools for a better ...atic/chunks/node_modules_next_dist_f3530cac._.js:2297\n- [LOG] [HMR] connected @ http://localhost:3000/_nex...atic/chunks/node_modules_next_dist_f3530cac._.js:2297"
        }
      ],
      "tool_use_id": "toolu_0113SAWF88i3vC7mPvU2qtRH"
    }
  },
  {
    "timestamp": "2026-02-28T06:45:17.555Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_fill_form",
      "tool_input": {
        "fields": [
          {
            "name": "Email address",
            "type": "textbox",
            "ref": "e26",
            "value": "johndoe@gmail.com"
          },
          {
            "name": "Password",
            "type": "textbox",
            "ref": "e29",
            "value": "Test@123"
          }
        ]
      },
      "tool_response": [
        {
          "type": "text",
          "text": "### Ran Playwright code\n```js\nawait page.getByRole('textbox', { name: 'Email address' }).fill('johndoe@gmail.com');\nawait page.getByRole('textbox', { name: 'Password' }).fill('Test@123');\n```\n### Page\n- Page URL: http://localhost:3000/login\n- Page Title: Claude Code Learning Hub\n### Events\n- [LOG] [Fast Refresh] rebuilding @ http://localhost...atic/chunks/node_modules_next_dist_f3530cac._.js:2297\n- [LOG] [Fast Refresh] done in 121ms @ http://localh...atic/chunks/node_modules_next_dist_f3530cac._.js:2297"
        }
      ],
      "tool_use_id": "toolu_01RMrxan2nZG8SHA6bMTdC1F"
    }
  },
  {
    "timestamp": "2026-02-28T06:45:27.951Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_snapshot",
      "tool_input": {},
      "tool_response": [
        {
          "type": "text",
          "text": "### Page\n- Page URL: about:blank\n### Snapshot\n```yaml\n\n```"
        }
      ],
      "tool_use_id": "toolu_015hbKfM5fCbGnyEEGPa76SP"
    }
  },
  {
    "timestamp": "2026-02-28T06:45:32.017Z",
    "payload": {
      "session_id": "f0880b63-3e32-4b94-bad3-9efad06d7b7b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\f0880b63-3e32-4b94-bad3-9efad06d7b7b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "mcp__playwright__browser_navigate",
      "tool_input": {
        "url": "http://localhost:3000/login"
      },
      "tool_response": [
        {
          "type": "text",
          "text": "### Ran Playwright code\n```js\nawait page.goto('http://localhost:3000/login');\n```\n### Page\n- Page URL: http://localhost:3000/login\n- Page Title: Claude Code Learning Hub\n### Snapshot\n```yaml\n- generic [active] [ref=e1]:\n  - generic [ref=e5]:\n    - generic [ref=e6]:\n      - generic [ref=e8]: CC\n      - generic [ref=e9]:\n        - heading \"Claude Code Learning Hub\" [level=1] [ref=e10]\n        - paragraph [ref=e11]: Welcome back ‚Äî sign in to continue\n    - button \"Continue with Google\" [ref=e13]:\n      - img [ref=e14]\n      - text: Continue with Google\n    - generic [ref=e21]: or continue with email\n    - generic [ref=e23]:\n      - generic [ref=e24]:\n        - generic [ref=e25]: Email address\n        - textbox \"Email address\" [ref=e26]:\n          - /placeholder: you@example.com\n      - generic [ref=e27]:\n        - generic [ref=e28]: Password\n        - textbox \"Password\" [ref=e29]:\n          - /placeholder: ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\n      - button \"Sign in\" [ref=e30]\n    - paragraph [ref=e31]:\n      - text: Don't have an account?\n      - link \"Create one\" [ref=e32] [cursor=pointer]:\n        - /url: /signup\n  - region \"Notifications alt+T\"\n  - button \"Open Next.js Dev Tools\" [ref=e38] [cursor=pointer]:\n    - img [ref=e39]\n  - alert [ref=e42]\n```\n### Events\n- [INFO] %cDownload the React DevTools for a better ...atic/chunks/node_modules_next_dist_f3530cac._.js:2297\n- [LOG] [HMR] connected @ http://localhost:3000/_nex...atic/chunks/node_modules_next_dist_f3530cac._.js:2297"
        }
      ],
      "tool_use_id": "toolu_016HamqvRHuscqGF9E6xmAn8"
    }
  },
  {
    "timestamp": "2026-02-28T07:11:09.560Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "can u add one more concetps which is plugins before worktree and tell about plugin there"
    }
  },
  {
    "timestamp": "2026-02-28T07:11:15.139Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Grep",
      "tool_input": {
        "pattern": "slug: \"worktrees\"",
        "path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "output_mode": "content",
        "-n": true
      },
      "tool_response": {
        "mode": "content",
        "numFiles": 0,
        "filenames": [],
        "content": "1674:    slug: \"worktrees\",",
        "numLines": 1
      },
      "tool_use_id": "toolu_01J6679wV6iNzWT132SMbdoi"
    }
  },
  {
    "timestamp": "2026-02-28T07:11:17.608Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1668,
        "limit": 10
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",",
          "numLines": 10,
          "startLine": 1668,
          "totalLines": 1760
        }
      },
      "tool_use_id": "toolu_01UjDm5nwh8veGa1hJb3koeK"
    }
  },
  {
    "timestamp": "2026-02-28T07:11:50.004Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Update",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T07:12:18.480Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",",
        "new_string": "  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",",
        "newString": "  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n         screenshots: [\n          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n        ],\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n       \n         screenshots: [\n          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1671,
            "oldLines": 6,
            "newStart": 1671,
            "newLines": 137,
            "lines": [
              "     ],",
              "   },",
              "   {",
              "+    slug: \"plugins\",",
              "+    title: \"Plugins\",",
              "+    emoji: \"üîå\",",
              "+    category: \"Integration\",",
              "+    difficulty: \"Intermediate\",",
              "+    released: true,",
              "+    shortDesc:",
              "+      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",",
              "+    sections: [",
              "+      {",
              "+        heading: \"Overview\",",
              "+        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",",
              "+      },",
              "+      {",
              "+        heading: \"How Plugins Work\",",
              "+        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",",
              "+        code: {",
              "+          language: \"text\",",
              "+          content: `Plugin",
              "+  ‚îÇ",
              "+  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)",
              "+  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)",
              "+  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)",
              "+  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates",
              "+",
              "+Claude Code reads ~/.claude/settings.json + .claude/settings.json",
              "+  ‚Üí loads registered plugins at startup",
              "+  ‚Üí exposes their tools / commands in the session`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Adding a Plugin via MCP\",",
              "+        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",",
              "+        code: {",
              "+          language: \"bash\",",
              "+          content: `# Add an MCP-based plugin from npm",
              "+claude mcp add <name> npx <package>",
              "+",
              "+# Examples:",
              "+claude mcp add github npx @modelcontextprotocol/server-github",
              "+claude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path",
              "+claude mcp add playwright npx @playwright/mcp@latest",
              "+",
              "+# List installed plugins / MCP servers",
              "+claude mcp list",
              "+",
              "+# Remove a plugin",
              "+claude mcp remove <name>`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Registering Plugins in settings.json\",",
              "+        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",",
              "+        code: {",
              "+          language: \"json\",",
              "+          content: `// .claude/settings.json",
              "+{",
              "+  \"mcpServers\": {",
              "+    \"github\": {",
              "+      \"command\": \"npx\",",
              "+      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],",
              "+      \"env\": {",
              "+        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"",
              "+      }",
              "+    },",
              "+    \"filesystem\": {",
              "+      \"command\": \"npx\",",
              "+      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]",
              "+    }",
              "+  }",
              "+}`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Skills as Local Plugins\",",
              "+        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",",
              "+        code: {",
              "+          language: \"text\",",
              "+          content: `# File: .claude/skills/review-pr.md",
              "+# Becomes: /review-pr command",
              "+",
              "+# File: .claude/skills/deploy.md",
              "+# Becomes: /deploy command",
              "+",
              "+.claude/",
              "+‚îî‚îÄ‚îÄ skills/",
              "+    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr",
              "+    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy",
              "+    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Plugin Permissions\",",
              "+        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",",
              "+        code: {",
              "+          language: \"json\",",
              "+          content: `// .claude/settings.local.json",
              "+{",
              "+  \"permissions\": {",
              "+    \"allow\": [",
              "+      \"mcp__github__*\",",
              "+      \"mcp__playwright__*\",",
              "+      \"mcp__filesystem__read_file\",",
              "+      \"mcp__filesystem__list_directory\"",
              "+    ],",
              "+    \"deny\": [",
              "+      \"mcp__filesystem__write_file\"",
              "+    ]",
              "+  }",
              "+}`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Tips\",",
              "+        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",",
              "+      },",
              "+    ],",
              "+    references: [",
              "+      {",
              "+        label: \"MCP Servers Registry\",",
              "+        url: \"https://github.com/modelcontextprotocol/servers\",",
              "+        description: \"Official list of community MCP servers you can use as plugins.\",",
              "+      },",
              "+      {",
              "+        label: \"Claude Code Skills Docs\",",
              "+        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",",
              "+        description: \"How to create and use skills as slash commands.\",",
              "+      },",
              "+    ],",
              "+  },",
              "+  {",
              "     slug: \"worktrees\",",
              "     title: \"Worktrees\",",
              "     emoji: \"üå≥\","
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01QjqiMBkYgYyvc2LeXGFW9z"
    }
  },
  {
    "timestamp": "2026-02-28T07:12:27.287Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Bash",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T07:12:33.111Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "cd \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\" && npx tsc --noEmit 2>&1 | head -20",
        "description": "Type-check after adding plugins concept"
      },
      "tool_response": {
        "stdout": "",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": false
      },
      "tool_use_id": "toolu_01JjwPMMjVADN1wefFQxMqbL"
    }
  },
  {
    "timestamp": "2026-02-28T07:16:51.963Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "Notification",
      "message": "Claude needs your permission to use Bash",
      "notification_type": "permission_prompt"
    }
  },
  {
    "timestamp": "2026-02-28T07:17:59.360Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Bash",
      "tool_input": {
        "command": "mkdir -p \"C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\public\\screenshots\\plugins\"",
        "description": "Create screenshots folder for plugins concept"
      },
      "tool_response": {
        "stdout": "",
        "stderr": "",
        "interrupted": false,
        "isImage": false,
        "noOutputExpected": true
      },
      "tool_use_id": "toolu_012asw1YjuEobvywL2fFqE6j"
    }
  },
  {
    "timestamp": "2026-02-28T07:18:04.089Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Added a \"Plugins\" concept (`slug: \"plugins\"`, category: Integration, difficulty: Intermediate) before Worktrees with 7 sections:\n\n| Section | What it covers |\n|---|---|\n| Overview | What plugins are and what they can contribute |\n| How Plugins Work | Diagram of plugin types (MCP, skills, hooks, prompts) |\n| Adding a Plugin via MCP | `claude mcp add/list/remove` commands |\n| Registering in settings.json | Team-shared plugin config in version control |\n| Skills as Local Plugins | `.claude/skills/` files as lightweight slash-command plugins |\n| Plugin Permissions | `mcp__server__tool` allow/deny pattern |\n| Tips | Best practices for shared vs personal plugins |"
    }
  },
  {
    "timestamp": "2026-02-28T07:18:05.449Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "ac79493a78c491f6e",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42\\subagents\\agent-ac79493a78c491f6e.jsonl",
      "agent_type": "",
      "last_assistant_message": "add a screenshot to the plugins concept"
    }
  },
  {
    "timestamp": "2026-02-28T07:20:43.634Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "claude --plugin-dir ./my-first-plugin"
    }
  },
  {
    "timestamp": "2026-02-28T07:20:59.859Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "`claude --plugin-dir` is not a valid Claude Code CLI flag. That flag doesn't exist in Claude Code.\n\nThe actual ways to load plugins/MCP servers are:\n\n```bash\n# Register an MCP server (saved to your settings)\nclaude mcp add <name> npx <package>\n\n# Or declare directly in .claude/settings.json (team-shared)\n# Or drop a .md file in .claude/skills/ for slash commands\n```\n\nIf you have a local plugin directory you want to load, the approach depends on what it contains:\n\n- **MCP server** ‚Üí `claude mcp add my-plugin node ./my-first-plugin/index.js`\n- **Skills** ‚Üí copy the `.md` files into `.claude/skills/`\n- **npm package** ‚Üí `claude mcp add my-plugin npx ./my-first-plugin`\n\nWere you trying to do one of these, or did you see `--plugin-dir` referenced somewhere specific? That would help me point you in the right direction."
    }
  },
  {
    "timestamp": "2026-02-28T07:21:01.719Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "af3be0d83ecd6437f",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42\\subagents\\agent-af3be0d83ecd6437f.jsonl",
      "agent_type": "",
      "last_assistant_message": "add a screenshot to the plugins concept"
    }
  },
  {
    "timestamp": "2026-02-28T07:21:33.415Z",
    "payload": {
      "session_id": "fffdd592-2f2b-4366-a1ba-c4c25772ea42",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\fffdd592-2f2b-4366-a1ba-c4c25772ea42.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionEnd",
      "reason": "prompt_input_exit"
    }
  },
  {
    "timestamp": "2026-02-28T07:21:40.822Z",
    "payload": {
      "session_id": "ba0523cf-0961-4fba-9450-448a5472929b",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ba0523cf-0961-4fba-9450-448a5472929b.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionStart",
      "source": "startup",
      "model": "claude-sonnet-4-6"
    }
  },
  {
    "timestamp": "2026-02-28T07:22:17.066Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "hook_event_name": "SessionStart",
      "source": "startup",
      "model": "claude-sonnet-4-6"
    }
  },
  {
    "timestamp": "2026-02-28T07:25:51.349Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "can u change the emoji for plugin because mcp has same, also change the released to false with coming soon date has march 3"
    }
  },
  {
    "timestamp": "2026-02-28T07:25:57.207Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Grep",
      "tool_input": {
        "pattern": "plugin|mcp|emoji|released|coming",
        "path": "src/data/concepts.ts",
        "output_mode": "content",
        "-n": true,
        "-i": true
      },
      "tool_response": {
        "mode": "content",
        "numFiles": 0,
        "filenames": [],
        "content": "40:  emoji: string;\r\n45:  released?: boolean;\r\n46:  releaseDate?: string;\r\n68:    emoji: \"üöÄ\",\r\n71:    released: true,\r\n131:    emoji: \"üìÑ\",\r\n134:    released: true,\r\n197:    emoji: \"‚å®Ô∏è\",\r\n198:    released: true,\r\n332:    emoji: \"‚ö°\",\r\n335:    released: true,\r\n450:    emoji: \"üîê\",\r\n453:    released: true,\r\n546:    emoji: \"‚öôÔ∏è\",\r\n549:    released: true,\r\n593:  \"mcpServers\": {\r\n686:    emoji: \"üìã\",\r\n689:    released: true,\r\n809:    emoji: \"üõ†Ô∏è\",\r\n812:    released: true,\r\n862:mcp__*        ‚Äî Tools from connected MCP servers`,\r\n878:    emoji: \"üß†\",\r\n881:    released: true,\r\n942:    emoji: \"üóÇÔ∏è\",\r\n945:    released: true,\r\n1003:- User prefers concise responses, no emojis\r\n1057:    emoji: \"üîÑ\",\r\n1060:    released: true,\r\n1140:        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\r\n1147:    emoji: \"‚ö°\",\r\n1150:    released: true,\r\n1244:    emoji: \"ü§ñ\",\r\n1247:    released: true,\r\n1329:    emoji: \"ü™ù\",\r\n1332:    released: true,\r\n1509:    emoji: \"üéØ\",\r\n1512:    released: true,\r\n1582:    slug: \"mcp\",\r\n1583:    title: \"MCP (Model Context Protocol)\",\r\n1584:    emoji: \"üîå\",\r\n1587:    released: true,\r\n1589:      \"Connect Claude to external tools, databases, and services via MCP servers.\",\r\n1593:        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\r\n1596:        heading: \"MCP Architecture\",\r\n1597:        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\r\n1600:          content: `MCP Architecture:\r\n1604:‚îÇ  (MCP Client)                           ‚îÇ\r\n1606:‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\r\n1610:    ‚îÇ          MCP Servers          ‚îÇ\r\n1622:        heading: \"Installing the Playwright MCP Server\",\r\n1626:          content: `claude mcp add playwright npx @playwright/mcp@latest`,\r\n1629:          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\r\n1630:          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\r\n1634:          'Names the MCP server \"playwright\"',\r\n1640:        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\r\n1641:        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\r\n1647:    \"allow\": [\"mcp__playwright\"],\r\n1654:          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\r\n1658:        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\r\n1659:        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\r\n1666:          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\r\n1667:          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\r\n1674:    slug: \"plugins\",\r\n1675:    title: \"Plugins\",\r\n1676:    emoji: \"üîå\",\r\n1679:    released: true,\r\n1681:      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\r\n1685:        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\r\n1688:        heading: \"How Plugins Work\",\r\n1689:        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\r\n1692:          content: `Plugin\r\n1694:  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\r\n1700:  ‚Üí loads registered plugins at startup\r\n1705:        heading: \"Adding a Plugin via MCP\",\r\n1706:        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\r\n1709:          content: `# Add an MCP-based plugin from npm\r\n1710:claude mcp add <name> npx <package>\r\n1713:claude mcp add github npx @modelcontextprotocol/server-github\r\n1714:claude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\r\n1715:claude mcp add playwright npx @playwright/mcp@latest\r\n1717:# List installed plugins / MCP servers\r\n1718:claude mcp list\r\n1720:# Remove a plugin\r\n1721:claude mcp remove <name>`,\r\n1725:        heading: \"Registering Plugins in settings.json\",\r\n1726:        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\r\n1731:  \"mcpServers\": {\r\n1748:        heading: \"Skills as Local Plugins\",\r\n1749:        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\r\n1766:        heading: \"Plugin Permissions\",\r\n1767:        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\r\n1774:      \"mcp__github__*\",\r\n1775:      \"mcp__playwright__*\",\r\n1776:      \"mcp__filesystem__read_file\",\r\n1777:      \"mcp__filesystem__list_directory\"\r\n1780:      \"mcp__filesystem__write_file\"\r\n1788:        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\r\n1793:        label: \"MCP Servers Registry\",\r\n1795:        description: \"Official list of community MCP servers you can use as plugins.\",\r\n1807:    emoji: \"üå≥\",\r\n1810:    released: true,",
        "numLines": 101
      },
      "tool_use_id": "toolu_01Ws66rgAhiYRwvtTUEiS5Ef"
    }
  },
  {
    "timestamp": "2026-02-28T07:26:08.353Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1674,
        "limit": 10
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {",
          "numLines": 10,
          "startLine": 1674,
          "totalLines": 1891
        }
      },
      "tool_use_id": "toolu_01KwbsEuXrbGhCqbbiPBFD83"
    }
  },
  {
    "timestamp": "2026-02-28T07:26:16.622Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,",
        "new_string": "    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"March 3\",",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,",
        "newString": "    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"March 3\",",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n         screenshots: [\n          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n        ],\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n       \n         screenshots: [\n          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n    ],\n  },\n  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1673,
            "oldLines": 10,
            "newStart": 1673,
            "newLines": 11,
            "lines": [
              "   {",
              "     slug: \"plugins\",",
              "     title: \"Plugins\",",
              "-    emoji: \"üîå\",",
              "+    emoji: \"üß©\",",
              "     category: \"Integration\",",
              "     difficulty: \"Intermediate\",",
              "-    released: true,",
              "+    released: false,",
              "+    releaseDate: \"March 3\",",
              "     shortDesc:",
              "       \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",",
              "     sections: ["
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01XbxG52PzpGP2sbTsYoGT2y"
    }
  },
  {
    "timestamp": "2026-02-28T07:26:19.147Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Done. Changes to the plugins concept (`concepts.ts:1674`):\n- Emoji: `üîå` ‚Üí `üß©`\n- `released: true` ‚Üí `released: false`\n- Added `releaseDate: \"March 3\"`"
    }
  },
  {
    "timestamp": "2026-02-28T07:26:20.731Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "ab362a49a3dea3106",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd\\subagents\\agent-ab362a49a3dea3106.jsonl",
      "agent_type": "",
      "last_assistant_message": "now do the same for git worktrees"
    }
  },
  {
    "timestamp": "2026-02-28T07:28:16.296Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "one more concepts for agent teams "
    }
  },
  {
    "timestamp": "2026-02-28T07:28:19.581Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1800,
        "limit": 80
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 3\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there",
          "numLines": 80,
          "startLine": 1800,
          "totalLines": 1893
        }
      },
      "tool_use_id": "toolu_016o4qvhaJAKDGbQv68qiGRw"
    }
  },
  {
    "timestamp": "2026-02-28T07:28:22.080Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1880,
        "limit": 60
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n];\n",
          "numLines": 14,
          "startLine": 1880,
          "totalLines": 1893
        }
      },
      "tool_use_id": "toolu_01FjDrLPm8x728wHeK94Ekuo"
    }
  },
  {
    "timestamp": "2026-02-28T07:28:27.654Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Grep",
      "tool_input": {
        "pattern": "slug: \"subagents\"",
        "path": "src/data/concepts.ts",
        "output_mode": "content",
        "-n": true
      },
      "tool_response": {
        "mode": "content",
        "numFiles": 0,
        "filenames": [],
        "content": "1242:    slug: \"subagents\",",
        "numLines": 1
      },
      "tool_use_id": "toolu_01BQkETnHeqcfWu5bfnRbWan"
    }
  },
  {
    "timestamp": "2026-02-28T07:28:29.955Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1242,
        "limit": 90
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",",
          "numLines": 90,
          "startLine": 1242,
          "totalLines": 1893
        }
      },
      "tool_use_id": "toolu_018KvHoutbdv2NM42gekbr6c"
    }
  },
  {
    "timestamp": "2026-02-28T07:29:16.137Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n];",
        "new_string": "      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"agent-teams\",\n    title: \"Agent Teams\",\n    emoji: \"üë•\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 3\",\n    shortDesc:\n      \"Orchestrate multiple specialized agents working together to tackle complex, multi-step workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Agent teams are coordinated groups of specialized agents that collaborate to complete complex tasks. An orchestrator agent breaks work into subtasks and delegates to specialist agents ‚Äî each focused on a specific domain. Results flow back to the orchestrator, which synthesizes them and drives the workflow forward.\",\n      },\n      {\n        heading: \"Team Architecture\",\n        body: \"A typical agent team has an orchestrator at the top that plans and coordinates, plus a set of specialist agents below it. Each specialist has scoped tools, a focused system prompt, and returns results to the orchestrator.\",\n        code: {\n          language: \"text\",\n          content: `Agent Team Architecture:\n\nOrchestrator Agent\n‚îú‚îÄ‚îÄ Plans the overall workflow\n‚îú‚îÄ‚îÄ Delegates to specialists\n‚îî‚îÄ‚îÄ Synthesizes results\n\n    ‚îú‚îÄ‚îÄ Explorer Agent      ‚Üí reads files, searches code\n    ‚îú‚îÄ‚îÄ Planner Agent       ‚Üí designs architecture\n    ‚îú‚îÄ‚îÄ Coder Agent         ‚Üí writes and edits code\n    ‚îú‚îÄ‚îÄ Tester Agent        ‚Üí runs tests, validates output\n    ‚îî‚îÄ‚îÄ Reviewer Agent      ‚Üí audits code quality`,\n        },\n      },\n      {\n        heading: \"Orchestrator Pattern\",\n        body: \"The orchestrator is a general-purpose agent with a system prompt that instructs it to break tasks into subtasks and delegate. It uses the Task tool to spin up specialist subagents with isolated context windows and scoped tool access.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/agents/orchestrator.md\n---\ndescription: Coordinates multi-agent workflows for complex tasks\ntools: Task, Read, Write, Bash\n---\n\nYou are an orchestrator. When given a complex task:\n1. Break it into independent subtasks\n2. Identify the right specialist agent for each subtask\n3. Launch specialists via Task tool (in parallel where possible)\n4. Collect results and synthesize them\n5. Continue until the task is complete\n\nAlways run independent subtasks in parallel using Task(run_in_background=True).`,\n        },\n      },\n      {\n        heading: \"Parallel vs Sequential Execution\",\n        body: \"Agent teams shine when subtasks can run in parallel. Independent tasks (e.g., exploring different parts of a codebase, running different test suites) should always run simultaneously. Dependent tasks must run sequentially ‚Äî the orchestrator waits for upstream results before launching downstream agents.\",\n        code: {\n          language: \"text\",\n          content: `# Parallel team execution:\nOrchestrator spawns simultaneously:\n  [Agent A] bg: Analyze frontend components\n  [Agent B] bg: Analyze API routes\n  [Agent C] bg: Analyze database schema\n\n[All three run at the same time]\n[Orchestrator collects all three results]\n[Synthesizes into a full architecture summary]\n\n# Sequential team execution:\n  [Agent 1] Plan the refactor   ‚Üí wait for plan\n  [Agent 2] Implement the plan  ‚Üí wait for impl\n  [Agent 3] Test the impl       ‚Üí wait for tests\n  [Orchestrator] Merge if tests pass`,\n        },\n      },\n      {\n        heading: \"Scoping Agent Permissions\",\n        body: \"Each agent in the team should have the minimum tools needed for its role. Explorer agents need read tools only. Coder agents need write tools. Tester agents need bash. This limits blast radius if an agent makes a mistake.\",\n        code: {\n          language: \"markdown\",\n          content: `# Explorer agent ‚Äî read-only\n---\ntools: Glob, Grep, Read\n---\n\n# Coder agent ‚Äî writes code\n---\ntools: Read, Write, Edit, Glob, Grep\n---\n\n# Tester agent ‚Äî runs commands\n---\ntools: Bash, Read\n---\n\n# Reviewer agent ‚Äî read + bash (linting)\n---\ntools: Read, Glob, Grep, Bash\n---`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep orchestrator prompts high-level ‚Äî they should plan and delegate, not implement. Give each specialist a tight, focused system prompt. Use background agents for independent work and collect results asynchronously. Agent teams scale well for large tasks but add coordination overhead for simple ones ‚Äî use subagents directly for straightforward work.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n];",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n];",
        "newString": "      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"agent-teams\",\n    title: \"Agent Teams\",\n    emoji: \"üë•\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 3\",\n    shortDesc:\n      \"Orchestrate multiple specialized agents working together to tackle complex, multi-step workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Agent teams are coordinated groups of specialized agents that collaborate to complete complex tasks. An orchestrator agent breaks work into subtasks and delegates to specialist agents ‚Äî each focused on a specific domain. Results flow back to the orchestrator, which synthesizes them and drives the workflow forward.\",\n      },\n      {\n        heading: \"Team Architecture\",\n        body: \"A typical agent team has an orchestrator at the top that plans and coordinates, plus a set of specialist agents below it. Each specialist has scoped tools, a focused system prompt, and returns results to the orchestrator.\",\n        code: {\n          language: \"text\",\n          content: `Agent Team Architecture:\n\nOrchestrator Agent\n‚îú‚îÄ‚îÄ Plans the overall workflow\n‚îú‚îÄ‚îÄ Delegates to specialists\n‚îî‚îÄ‚îÄ Synthesizes results\n\n    ‚îú‚îÄ‚îÄ Explorer Agent      ‚Üí reads files, searches code\n    ‚îú‚îÄ‚îÄ Planner Agent       ‚Üí designs architecture\n    ‚îú‚îÄ‚îÄ Coder Agent         ‚Üí writes and edits code\n    ‚îú‚îÄ‚îÄ Tester Agent        ‚Üí runs tests, validates output\n    ‚îî‚îÄ‚îÄ Reviewer Agent      ‚Üí audits code quality`,\n        },\n      },\n      {\n        heading: \"Orchestrator Pattern\",\n        body: \"The orchestrator is a general-purpose agent with a system prompt that instructs it to break tasks into subtasks and delegate. It uses the Task tool to spin up specialist subagents with isolated context windows and scoped tool access.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/agents/orchestrator.md\n---\ndescription: Coordinates multi-agent workflows for complex tasks\ntools: Task, Read, Write, Bash\n---\n\nYou are an orchestrator. When given a complex task:\n1. Break it into independent subtasks\n2. Identify the right specialist agent for each subtask\n3. Launch specialists via Task tool (in parallel where possible)\n4. Collect results and synthesize them\n5. Continue until the task is complete\n\nAlways run independent subtasks in parallel using Task(run_in_background=True).`,\n        },\n      },\n      {\n        heading: \"Parallel vs Sequential Execution\",\n        body: \"Agent teams shine when subtasks can run in parallel. Independent tasks (e.g., exploring different parts of a codebase, running different test suites) should always run simultaneously. Dependent tasks must run sequentially ‚Äî the orchestrator waits for upstream results before launching downstream agents.\",\n        code: {\n          language: \"text\",\n          content: `# Parallel team execution:\nOrchestrator spawns simultaneously:\n  [Agent A] bg: Analyze frontend components\n  [Agent B] bg: Analyze API routes\n  [Agent C] bg: Analyze database schema\n\n[All three run at the same time]\n[Orchestrator collects all three results]\n[Synthesizes into a full architecture summary]\n\n# Sequential team execution:\n  [Agent 1] Plan the refactor   ‚Üí wait for plan\n  [Agent 2] Implement the plan  ‚Üí wait for impl\n  [Agent 3] Test the impl       ‚Üí wait for tests\n  [Orchestrator] Merge if tests pass`,\n        },\n      },\n      {\n        heading: \"Scoping Agent Permissions\",\n        body: \"Each agent in the team should have the minimum tools needed for its role. Explorer agents need read tools only. Coder agents need write tools. Tester agents need bash. This limits blast radius if an agent makes a mistake.\",\n        code: {\n          language: \"markdown\",\n          content: `# Explorer agent ‚Äî read-only\n---\ntools: Glob, Grep, Read\n---\n\n# Coder agent ‚Äî writes code\n---\ntools: Read, Write, Edit, Glob, Grep\n---\n\n# Tester agent ‚Äî runs commands\n---\ntools: Bash, Read\n---\n\n# Reviewer agent ‚Äî read + bash (linting)\n---\ntools: Read, Glob, Grep, Bash\n---`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep orchestrator prompts high-level ‚Äî they should plan and delegate, not implement. Give each specialist a tight, focused system prompt. Use background agents for independent work and collect results asynchronously. Agent teams scale well for large tasks but add coordination overhead for simple ones ‚Äî use subagents directly for straightforward work.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n];",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n         screenshots: [\n          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n        ],\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n       \n         screenshots: [\n          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n    ],\n  },\n  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"March 3\",\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 3\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1889,
            "oldLines": 4,
            "newStart": 1889,
            "newLines": 125,
            "lines": [
              "       },",
              "     ],",
              "   },",
              "+  {",
              "+    slug: \"agent-teams\",",
              "+    title: \"Agent Teams\",",
              "+    emoji: \"üë•\",",
              "+    category: \"Automation\",",
              "+    difficulty: \"Advanced\",",
              "+    released: false,",
              "+    releaseDate: \"March 3\",",
              "+    shortDesc:",
              "+      \"Orchestrate multiple specialized agents working together to tackle complex, multi-step workflows.\",",
              "+    sections: [",
              "+      {",
              "+        heading: \"Overview\",",
              "+        body: \"Agent teams are coordinated groups of specialized agents that collaborate to complete complex tasks. An orchestrator agent breaks work into subtasks and delegates to specialist agents ‚Äî each focused on a specific domain. Results flow back to the orchestrator, which synthesizes them and drives the workflow forward.\",",
              "+      },",
              "+      {",
              "+        heading: \"Team Architecture\",",
              "+        body: \"A typical agent team has an orchestrator at the top that plans and coordinates, plus a set of specialist agents below it. Each specialist has scoped tools, a focused system prompt, and returns results to the orchestrator.\",",
              "+        code: {",
              "+          language: \"text\",",
              "+          content: `Agent Team Architecture:",
              "+",
              "+Orchestrator Agent",
              "+‚îú‚îÄ‚îÄ Plans the overall workflow",
              "+‚îú‚îÄ‚îÄ Delegates to specialists",
              "+‚îî‚îÄ‚îÄ Synthesizes results",
              "+",
              "+    ‚îú‚îÄ‚îÄ Explorer Agent      ‚Üí reads files, searches code",
              "+    ‚îú‚îÄ‚îÄ Planner Agent       ‚Üí designs architecture",
              "+    ‚îú‚îÄ‚îÄ Coder Agent         ‚Üí writes and edits code",
              "+    ‚îú‚îÄ‚îÄ Tester Agent        ‚Üí runs tests, validates output",
              "+    ‚îî‚îÄ‚îÄ Reviewer Agent      ‚Üí audits code quality`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Orchestrator Pattern\",",
              "+        body: \"The orchestrator is a general-purpose agent with a system prompt that instructs it to break tasks into subtasks and delegate. It uses the Task tool to spin up specialist subagents with isolated context windows and scoped tool access.\",",
              "+        code: {",
              "+          language: \"markdown\",",
              "+          content: `# .claude/agents/orchestrator.md",
              "+---",
              "+description: Coordinates multi-agent workflows for complex tasks",
              "+tools: Task, Read, Write, Bash",
              "+---",
              "+",
              "+You are an orchestrator. When given a complex task:",
              "+1. Break it into independent subtasks",
              "+2. Identify the right specialist agent for each subtask",
              "+3. Launch specialists via Task tool (in parallel where possible)",
              "+4. Collect results and synthesize them",
              "+5. Continue until the task is complete",
              "+",
              "+Always run independent subtasks in parallel using Task(run_in_background=True).`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Parallel vs Sequential Execution\",",
              "+        body: \"Agent teams shine when subtasks can run in parallel. Independent tasks (e.g., exploring different parts of a codebase, running different test suites) should always run simultaneously. Dependent tasks must run sequentially ‚Äî the orchestrator waits for upstream results before launching downstream agents.\",",
              "+        code: {",
              "+          language: \"text\",",
              "+          content: `# Parallel team execution:",
              "+Orchestrator spawns simultaneously:",
              "+  [Agent A] bg: Analyze frontend components",
              "+  [Agent B] bg: Analyze API routes",
              "+  [Agent C] bg: Analyze database schema",
              "+",
              "+[All three run at the same time]",
              "+[Orchestrator collects all three results]",
              "+[Synthesizes into a full architecture summary]",
              "+",
              "+# Sequential team execution:",
              "+  [Agent 1] Plan the refactor   ‚Üí wait for plan",
              "+  [Agent 2] Implement the plan  ‚Üí wait for impl",
              "+  [Agent 3] Test the impl       ‚Üí wait for tests",
              "+  [Orchestrator] Merge if tests pass`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Scoping Agent Permissions\",",
              "+        body: \"Each agent in the team should have the minimum tools needed for its role. Explorer agents need read tools only. Coder agents need write tools. Tester agents need bash. This limits blast radius if an agent makes a mistake.\",",
              "+        code: {",
              "+          language: \"markdown\",",
              "+          content: `# Explorer agent ‚Äî read-only",
              "+---",
              "+tools: Glob, Grep, Read",
              "+---",
              "+",
              "+# Coder agent ‚Äî writes code",
              "+---",
              "+tools: Read, Write, Edit, Glob, Grep",
              "+---",
              "+",
              "+# Tester agent ‚Äî runs commands",
              "+---",
              "+tools: Bash, Read",
              "+---",
              "+",
              "+# Reviewer agent ‚Äî read + bash (linting)",
              "+---",
              "+tools: Read, Glob, Grep, Bash",
              "+---`,",
              "+        },",
              "+      },",
              "+      {",
              "+        heading: \"Tips\",",
              "+        body: \"Keep orchestrator prompts high-level ‚Äî they should plan and delegate, not implement. Give each specialist a tight, focused system prompt. Use background agents for independent work and collect results asynchronously. Agent teams scale well for large tasks but add coordination overhead for simple ones ‚Äî use subagents directly for straightforward work.\",",
              "+      },",
              "+    ],",
              "+    references: [",
              "+      {",
              "+        label: \"SubAgents Concept\",",
              "+        url: \"/concepts/subagents\",",
              "+        description: \"How individual subagents work before composing them into teams.\",",
              "+      },",
              "+      {",
              "+        label: \"Claude Code Sub-Agents Docs\",",
              "+        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",",
              "+        description: \"Official docs on Claude Code subagents and orchestration.\",",
              "+      },",
              "+    ],",
              "+  },",
              " ];"
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01JErLiPmXUpdBS1iQetEEaq"
    }
  },
  {
    "timestamp": "2026-02-28T07:29:20.697Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Added the \"Agent Teams\" concept at `concepts.ts:1893`. Here's what's included:\n\n- **Emoji:** `üë•`\n- **Category:** Automation | **Difficulty:** Advanced\n- **Released:** false, coming March 3\n- **5 sections:**\n  1. Overview ‚Äî what agent teams are\n  2. Team Architecture ‚Äî orchestrator + specialist hierarchy diagram\n  3. Orchestrator Pattern ‚Äî sample `.claude/agents/orchestrator.md`\n  4. Parallel vs Sequential ‚Äî when to run agents in parallel vs chain them\n  5. Scoping Agent Permissions ‚Äî minimal tool access per agent role\n- **References:** links to the SubAgents concept page and official Anthropic docs"
    }
  },
  {
    "timestamp": "2026-02-28T07:29:22.113Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "aa9e406443968ef2f",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd\\subagents\\agent-aa9e406443968ef2f.jsonl",
      "agent_type": "",
      "last_assistant_message": "also do the same for worktrees"
    }
  },
  {
    "timestamp": "2026-02-28T07:32:41.640Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "UserPromptSubmit",
      "prompt": "can u add reference for mcp concept \"references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\""
    }
  },
  {
    "timestamp": "2026-02-28T07:32:46.765Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Grep",
      "tool_input": {
        "pattern": "slug: \"mcp\"",
        "path": "src/data/concepts.ts",
        "output_mode": "content",
        "-n": true
      },
      "tool_response": {
        "mode": "content",
        "numFiles": 0,
        "filenames": [],
        "content": "1582:    slug: \"mcp\",",
        "numLines": 1
      },
      "tool_use_id": "toolu_01XMGmwGC3pSKyh8XE9yfHtU"
    }
  },
  {
    "timestamp": "2026-02-28T07:32:49.237Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Read",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "offset": 1660,
        "limit": 20
      },
      "tool_response": {
        "type": "text",
        "file": {
          "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
          "content": "       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n      \n    ],\n  },\n  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",",
          "numLines": 20,
          "startLine": 1660,
          "totalLines": 2015
        }
      },
      "tool_use_id": "toolu_01TYdyCMSFxKivcqVGBKbx2C"
    }
  },
  {
    "timestamp": "2026-02-28T07:32:55.166Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "PostToolUse",
      "tool_name": "Edit",
      "tool_input": {
        "file_path": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "old_string": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n         screenshots: [\n          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n        ],\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n       \n         screenshots: [\n          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n      \n    ],\n  },\n  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"March 2\",\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 4\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"agent-teams\",\n    title: \"Agent Teams\",\n    emoji: \"üë•\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 5\",\n    shortDesc:\n      \"Orchestrate multiple specialized agents working together to tackle complex, multi-step workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Agent teams are coordinated groups of specialized agents that collaborate to complete complex tasks. An orchestrator agent breaks work into subtasks and delegates to specialist agents ‚Äî each focused on a specific domain. Results flow back to the orchestrator, which synthesizes them and drives the workflow forward.\",\n      },\n      {\n        heading: \"Team Architecture\",\n        body: \"A typical agent team has an orchestrator at the top that plans and coordinates, plus a set of specialist agents below it. Each specialist has scoped tools, a focused system prompt, and returns results to the orchestrator.\",\n        code: {\n          language: \"text\",\n          content: `Agent Team Architecture:\n\nOrchestrator Agent\n‚îú‚îÄ‚îÄ Plans the overall workflow\n‚îú‚îÄ‚îÄ Delegates to specialists\n‚îî‚îÄ‚îÄ Synthesizes results\n\n    ‚îú‚îÄ‚îÄ Explorer Agent      ‚Üí reads files, searches code\n    ‚îú‚îÄ‚îÄ Planner Agent       ‚Üí designs architecture\n    ‚îú‚îÄ‚îÄ Coder Agent         ‚Üí writes and edits code\n    ‚îú‚îÄ‚îÄ Tester Agent        ‚Üí runs tests, validates output\n    ‚îî‚îÄ‚îÄ Reviewer Agent      ‚Üí audits code quality`,\n        },\n      },\n      {\n        heading: \"Orchestrator Pattern\",\n        body: \"The orchestrator is a general-purpose agent with a system prompt that instructs it to break tasks into subtasks and delegate. It uses the Task tool to spin up specialist subagents with isolated context windows and scoped tool access.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/agents/orchestrator.md\n---\ndescription: Coordinates multi-agent workflows for complex tasks\ntools: Task, Read, Write, Bash\n---\n\nYou are an orchestrator. When given a complex task:\n1. Break it into independent subtasks\n2. Identify the right specialist agent for each subtask\n3. Launch specialists via Task tool (in parallel where possible)\n4. Collect results and synthesize them\n5. Continue until the task is complete\n\nAlways run independent subtasks in parallel using Task(run_in_background=True).`,\n        },\n      },\n      {\n        heading: \"Parallel vs Sequential Execution\",\n        body: \"Agent teams shine when subtasks can run in parallel. Independent tasks (e.g., exploring different parts of a codebase, running different test suites) should always run simultaneously. Dependent tasks must run sequentially ‚Äî the orchestrator waits for upstream results before launching downstream agents.\",\n        code: {\n          language: \"text\",\n          content: `# Parallel team execution:\nOrchestrator spawns simultaneously:\n  [Agent A] bg: Analyze frontend components\n  [Agent B] bg: Analyze API routes\n  [Agent C] bg: Analyze database schema\n\n[All three run at the same time]\n[Orchestrator collects all three results]\n[Synthesizes into a full architecture summary]\n\n# Sequential team execution:\n  [Agent 1] Plan the refactor   ‚Üí wait for plan\n  [Agent 2] Implement the plan  ‚Üí wait for impl\n  [Agent 3] Test the impl       ‚Üí wait for tests\n  [Orchestrator] Merge if tests pass`,\n        },\n      },\n      {\n        heading: \"Scoping Agent Permissions\",\n        body: \"Each agent in the team should have the minimum tools needed for its role. Explorer agents need read tools only. Coder agents need write tools. Tester agents need bash. This limits blast radius if an agent makes a mistake.\",\n        code: {\n          language: \"markdown\",\n          content: `# Explorer agent ‚Äî read-only\n---\ntools: Glob, Grep, Read\n---\n\n# Coder agent ‚Äî writes code\n---\ntools: Read, Write, Edit, Glob, Grep\n---\n\n# Tester agent ‚Äî runs commands\n---\ntools: Bash, Read\n---\n\n# Reviewer agent ‚Äî read + bash (linting)\n---\ntools: Read, Glob, Grep, Bash\n---`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep orchestrator prompts high-level ‚Äî they should plan and delegate, not implement. Give each specialist a tight, focused system prompt. Use background agents for independent work and collect results asynchronously. Agent teams scale well for large tasks but add coordination overhead for simple ones ‚Äî use subagents directly for straightforward work.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n];",
        "new_string": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n         screenshots: [\n          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n        ],\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n       \n         screenshots: [\n          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"March 2\",\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 4\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"agent-teams\",\n    title: \"Agent Teams\",\n    emoji: \"üë•\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 5\",\n    shortDesc:\n      \"Orchestrate multiple specialized agents working together to tackle complex, multi-step workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Agent teams are coordinated groups of specialized agents that collaborate to complete complex tasks. An orchestrator agent breaks work into subtasks and delegates to specialist agents ‚Äî each focused on a specific domain. Results flow back to the orchestrator, which synthesizes them and drives the workflow forward.\",\n      },\n      {\n        heading: \"Team Architecture\",\n        body: \"A typical agent team has an orchestrator at the top that plans and coordinates, plus a set of specialist agents below it. Each specialist has scoped tools, a focused system prompt, and returns results to the orchestrator.\",\n        code: {\n          language: \"text\",\n          content: `Agent Team Architecture:\n\nOrchestrator Agent\n‚îú‚îÄ‚îÄ Plans the overall workflow\n‚îú‚îÄ‚îÄ Delegates to specialists\n‚îî‚îÄ‚îÄ Synthesizes results\n\n    ‚îú‚îÄ‚îÄ Explorer Agent      ‚Üí reads files, searches code\n    ‚îú‚îÄ‚îÄ Planner Agent       ‚Üí designs architecture\n    ‚îú‚îÄ‚îÄ Coder Agent         ‚Üí writes and edits code\n    ‚îú‚îÄ‚îÄ Tester Agent        ‚Üí runs tests, validates output\n    ‚îî‚îÄ‚îÄ Reviewer Agent      ‚Üí audits code quality`,\n        },\n      },\n      {\n        heading: \"Orchestrator Pattern\",\n        body: \"The orchestrator is a general-purpose agent with a system prompt that instructs it to break tasks into subtasks and delegate. It uses the Task tool to spin up specialist subagents with isolated context windows and scoped tool access.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/agents/orchestrator.md\n---\ndescription: Coordinates multi-agent workflows for complex tasks\ntools: Task, Read, Write, Bash\n---\n\nYou are an orchestrator. When given a complex task:\n1. Break it into independent subtasks\n2. Identify the right specialist agent for each subtask\n3. Launch specialists via Task tool (in parallel where possible)\n4. Collect results and synthesize them\n5. Continue until the task is complete\n\nAlways run independent subtasks in parallel using Task(run_in_background=True).`,\n        },\n      },\n      {\n        heading: \"Parallel vs Sequential Execution\",\n        body: \"Agent teams shine when subtasks can run in parallel. Independent tasks (e.g., exploring different parts of a codebase, running different test suites) should always run simultaneously. Dependent tasks must run sequentially ‚Äî the orchestrator waits for upstream results before launching downstream agents.\",\n        code: {\n          language: \"text\",\n          content: `# Parallel team execution:\nOrchestrator spawns simultaneously:\n  [Agent A] bg: Analyze frontend components\n  [Agent B] bg: Analyze API routes\n  [Agent C] bg: Analyze database schema\n\n[All three run at the same time]\n[Orchestrator collects all three results]\n[Synthesizes into a full architecture summary]\n\n# Sequential team execution:\n  [Agent 1] Plan the refactor   ‚Üí wait for plan\n  [Agent 2] Implement the plan  ‚Üí wait for impl\n  [Agent 3] Test the impl       ‚Üí wait for tests\n  [Orchestrator] Merge if tests pass`,\n        },\n      },\n      {\n        heading: \"Scoping Agent Permissions\",\n        body: \"Each agent in the team should have the minimum tools needed for its role. Explorer agents need read tools only. Coder agents need write tools. Tester agents need bash. This limits blast radius if an agent makes a mistake.\",\n        code: {\n          language: \"markdown\",\n          content: `# Explorer agent ‚Äî read-only\n---\ntools: Glob, Grep, Read\n---\n\n# Coder agent ‚Äî writes code\n---\ntools: Read, Write, Edit, Glob, Grep\n---\n\n# Tester agent ‚Äî runs commands\n---\ntools: Bash, Read\n---\n\n# Reviewer agent ‚Äî read + bash (linting)\n---\ntools: Read, Glob, Grep, Bash\n---`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep orchestrator prompts high-level ‚Äî they should plan and delegate, not implement. Give each specialist a tight, focused system prompt. Use background agents for independent work and collect results asynchronously. Agent teams scale well for large tasks but add coordination overhead for simple ones ‚Äî use subagents directly for straightforward work.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n];",
        "replace_all": false
      },
      "tool_response": {
        "filePath": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app\\src\\data\\concepts.ts",
        "oldString": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n         screenshots: [\n          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n        ],\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n       \n         screenshots: [\n          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n      \n    ],\n  },\n  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"March 2\",\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 4\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"agent-teams\",\n    title: \"Agent Teams\",\n    emoji: \"üë•\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 5\",\n    shortDesc:\n      \"Orchestrate multiple specialized agents working together to tackle complex, multi-step workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Agent teams are coordinated groups of specialized agents that collaborate to complete complex tasks. An orchestrator agent breaks work into subtasks and delegates to specialist agents ‚Äî each focused on a specific domain. Results flow back to the orchestrator, which synthesizes them and drives the workflow forward.\",\n      },\n      {\n        heading: \"Team Architecture\",\n        body: \"A typical agent team has an orchestrator at the top that plans and coordinates, plus a set of specialist agents below it. Each specialist has scoped tools, a focused system prompt, and returns results to the orchestrator.\",\n        code: {\n          language: \"text\",\n          content: `Agent Team Architecture:\n\nOrchestrator Agent\n‚îú‚îÄ‚îÄ Plans the overall workflow\n‚îú‚îÄ‚îÄ Delegates to specialists\n‚îî‚îÄ‚îÄ Synthesizes results\n\n    ‚îú‚îÄ‚îÄ Explorer Agent      ‚Üí reads files, searches code\n    ‚îú‚îÄ‚îÄ Planner Agent       ‚Üí designs architecture\n    ‚îú‚îÄ‚îÄ Coder Agent         ‚Üí writes and edits code\n    ‚îú‚îÄ‚îÄ Tester Agent        ‚Üí runs tests, validates output\n    ‚îî‚îÄ‚îÄ Reviewer Agent      ‚Üí audits code quality`,\n        },\n      },\n      {\n        heading: \"Orchestrator Pattern\",\n        body: \"The orchestrator is a general-purpose agent with a system prompt that instructs it to break tasks into subtasks and delegate. It uses the Task tool to spin up specialist subagents with isolated context windows and scoped tool access.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/agents/orchestrator.md\n---\ndescription: Coordinates multi-agent workflows for complex tasks\ntools: Task, Read, Write, Bash\n---\n\nYou are an orchestrator. When given a complex task:\n1. Break it into independent subtasks\n2. Identify the right specialist agent for each subtask\n3. Launch specialists via Task tool (in parallel where possible)\n4. Collect results and synthesize them\n5. Continue until the task is complete\n\nAlways run independent subtasks in parallel using Task(run_in_background=True).`,\n        },\n      },\n      {\n        heading: \"Parallel vs Sequential Execution\",\n        body: \"Agent teams shine when subtasks can run in parallel. Independent tasks (e.g., exploring different parts of a codebase, running different test suites) should always run simultaneously. Dependent tasks must run sequentially ‚Äî the orchestrator waits for upstream results before launching downstream agents.\",\n        code: {\n          language: \"text\",\n          content: `# Parallel team execution:\nOrchestrator spawns simultaneously:\n  [Agent A] bg: Analyze frontend components\n  [Agent B] bg: Analyze API routes\n  [Agent C] bg: Analyze database schema\n\n[All three run at the same time]\n[Orchestrator collects all three results]\n[Synthesizes into a full architecture summary]\n\n# Sequential team execution:\n  [Agent 1] Plan the refactor   ‚Üí wait for plan\n  [Agent 2] Implement the plan  ‚Üí wait for impl\n  [Agent 3] Test the impl       ‚Üí wait for tests\n  [Orchestrator] Merge if tests pass`,\n        },\n      },\n      {\n        heading: \"Scoping Agent Permissions\",\n        body: \"Each agent in the team should have the minimum tools needed for its role. Explorer agents need read tools only. Coder agents need write tools. Tester agents need bash. This limits blast radius if an agent makes a mistake.\",\n        code: {\n          language: \"markdown\",\n          content: `# Explorer agent ‚Äî read-only\n---\ntools: Glob, Grep, Read\n---\n\n# Coder agent ‚Äî writes code\n---\ntools: Read, Write, Edit, Glob, Grep\n---\n\n# Tester agent ‚Äî runs commands\n---\ntools: Bash, Read\n---\n\n# Reviewer agent ‚Äî read + bash (linting)\n---\ntools: Read, Glob, Grep, Bash\n---`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep orchestrator prompts high-level ‚Äî they should plan and delegate, not implement. Give each specialist a tight, focused system prompt. Use background agents for independent work and collect results asynchronously. Agent teams scale well for large tasks but add coordination overhead for simple ones ‚Äî use subagents directly for straightforward work.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n];",
        "newString": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n         screenshots: [\n          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n        ],\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n       \n         screenshots: [\n          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"March 2\",\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 4\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"agent-teams\",\n    title: \"Agent Teams\",\n    emoji: \"üë•\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 5\",\n    shortDesc:\n      \"Orchestrate multiple specialized agents working together to tackle complex, multi-step workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Agent teams are coordinated groups of specialized agents that collaborate to complete complex tasks. An orchestrator agent breaks work into subtasks and delegates to specialist agents ‚Äî each focused on a specific domain. Results flow back to the orchestrator, which synthesizes them and drives the workflow forward.\",\n      },\n      {\n        heading: \"Team Architecture\",\n        body: \"A typical agent team has an orchestrator at the top that plans and coordinates, plus a set of specialist agents below it. Each specialist has scoped tools, a focused system prompt, and returns results to the orchestrator.\",\n        code: {\n          language: \"text\",\n          content: `Agent Team Architecture:\n\nOrchestrator Agent\n‚îú‚îÄ‚îÄ Plans the overall workflow\n‚îú‚îÄ‚îÄ Delegates to specialists\n‚îî‚îÄ‚îÄ Synthesizes results\n\n    ‚îú‚îÄ‚îÄ Explorer Agent      ‚Üí reads files, searches code\n    ‚îú‚îÄ‚îÄ Planner Agent       ‚Üí designs architecture\n    ‚îú‚îÄ‚îÄ Coder Agent         ‚Üí writes and edits code\n    ‚îú‚îÄ‚îÄ Tester Agent        ‚Üí runs tests, validates output\n    ‚îî‚îÄ‚îÄ Reviewer Agent      ‚Üí audits code quality`,\n        },\n      },\n      {\n        heading: \"Orchestrator Pattern\",\n        body: \"The orchestrator is a general-purpose agent with a system prompt that instructs it to break tasks into subtasks and delegate. It uses the Task tool to spin up specialist subagents with isolated context windows and scoped tool access.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/agents/orchestrator.md\n---\ndescription: Coordinates multi-agent workflows for complex tasks\ntools: Task, Read, Write, Bash\n---\n\nYou are an orchestrator. When given a complex task:\n1. Break it into independent subtasks\n2. Identify the right specialist agent for each subtask\n3. Launch specialists via Task tool (in parallel where possible)\n4. Collect results and synthesize them\n5. Continue until the task is complete\n\nAlways run independent subtasks in parallel using Task(run_in_background=True).`,\n        },\n      },\n      {\n        heading: \"Parallel vs Sequential Execution\",\n        body: \"Agent teams shine when subtasks can run in parallel. Independent tasks (e.g., exploring different parts of a codebase, running different test suites) should always run simultaneously. Dependent tasks must run sequentially ‚Äî the orchestrator waits for upstream results before launching downstream agents.\",\n        code: {\n          language: \"text\",\n          content: `# Parallel team execution:\nOrchestrator spawns simultaneously:\n  [Agent A] bg: Analyze frontend components\n  [Agent B] bg: Analyze API routes\n  [Agent C] bg: Analyze database schema\n\n[All three run at the same time]\n[Orchestrator collects all three results]\n[Synthesizes into a full architecture summary]\n\n# Sequential team execution:\n  [Agent 1] Plan the refactor   ‚Üí wait for plan\n  [Agent 2] Implement the plan  ‚Üí wait for impl\n  [Agent 3] Test the impl       ‚Üí wait for tests\n  [Orchestrator] Merge if tests pass`,\n        },\n      },\n      {\n        heading: \"Scoping Agent Permissions\",\n        body: \"Each agent in the team should have the minimum tools needed for its role. Explorer agents need read tools only. Coder agents need write tools. Tester agents need bash. This limits blast radius if an agent makes a mistake.\",\n        code: {\n          language: \"markdown\",\n          content: `# Explorer agent ‚Äî read-only\n---\ntools: Glob, Grep, Read\n---\n\n# Coder agent ‚Äî writes code\n---\ntools: Read, Write, Edit, Glob, Grep\n---\n\n# Tester agent ‚Äî runs commands\n---\ntools: Bash, Read\n---\n\n# Reviewer agent ‚Äî read + bash (linting)\n---\ntools: Read, Glob, Grep, Bash\n---`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep orchestrator prompts high-level ‚Äî they should plan and delegate, not implement. Give each specialist a tight, focused system prompt. Use background agents for independent work and collect results asynchronously. Agent teams scale well for large tasks but add coordination overhead for simple ones ‚Äî use subagents directly for straightforward work.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n];",
        "originalFile": "export type ConceptCategory =\n  | \"Core CLI\"\n  | \"Intelligence\"\n  | \"Memory\"\n  | \"Automation\"\n  | \"Integration\";\n\nexport type Difficulty = \"Beginner\" | \"Intermediate\" | \"Advanced\";\n\nexport interface ConceptSection {\n  heading: string;\n  body: string;\n  orderedList?: string[];\n  note?: string;\n  bullets?: string[];\n  code?: {\n    language: string;\n    content: string;\n  };\n  screenshots?: {\n    src: string;\n    alt: string;\n  }[];\n  carousel?: boolean;\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n}\n\nexport interface ConceptReference {\n  label: string;\n  url: string;\n  description?: string;\n}\n\nexport interface Concept {\n  slug: string;\n  title: string;\n  emoji: string;\n  category: ConceptCategory;\n  difficulty: Difficulty;\n  shortDesc: string;\n  sections: ConceptSection[];\n  released?: boolean;\n  releaseDate?: string;\n  references?: ConceptReference[];\n}\n\nexport const difficultyBadgeStyles: Record<Difficulty, string> = {\n  Beginner:     'border-green-500/40 text-green-400 bg-green-500/10',\n  Intermediate: 'border-yellow-500/40 text-yellow-400 bg-yellow-500/10',\n  Advanced:     'border-red-500/40 text-red-400 bg-red-500/10',\n};\n\nexport const ALL_CATEGORIES: ConceptCategory[] = [\n  \"Core CLI\",\n  \"Intelligence\",\n  \"Memory\",\n  \"Automation\",\n  \"Integration\",\n];\n\nexport const concepts: Concept[] = [\n  {\n    slug: \"getting-started\",\n    title: \"Getting Started\",\n    emoji: \"üöÄ\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Install Claude Code and run your first AI-powered coding session.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code is Anthropic's official CLI that brings Claude directly into your terminal. It can read files, run commands, edit code, and navigate your entire codebase ‚Äî all through natural language. You interact with it conversationally, and it takes actions on your behalf with your permission.\",\n        \n      },\n      {\n        heading: \"Installation\",\n        body: \"Claude Code is distributed as an npm package. You need Node.js 18+ and an Anthropic API key. After installing globally, authenticate once and you're ready to use it in any project.\",\n        code: {\n          language: \"bash\",\n          content: `# Install globally\nnpm install -g @anthropic-ai/claude-code\n\n# Verify installation\nclaude --version\n\n# Start your first session in a project directory\ncd my-project\nclaude`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/Installation.png\", alt: \"Terminal showing npm install of @anthropic-ai/claude-code and claude --version outputting 2.1.62\" },\n        ],\n      },\n      {\n        heading: \"How It Works\",\n        body: \"When you launch Claude Code, it reads your project context, understands the codebase, and engages in a back-and-forth conversation. You can ask it to explain code, fix bugs, add features, run tests, or even search the web. Claude Code uses a set of tools (file read/write, bash execution, search) to carry out your requests autonomously.\",\n      },\n      {\n        heading: \"Your First Session\",\n        body: \"Start Claude Code in your project, then try natural language instructions. Claude will read relevant files, understand the context, and take action. You approve or deny each tool call as it runs.\",\n        code: {\n          language: \"bash\",\n          content: `# Open your project\ncd my-app\nclaude\n\n# Then type in the interactive session:\n> Explain what this project does\n> Fix the TypeScript error in src/auth.ts\n> Add a dark mode toggle to the header component\n> Run the tests and fix any failures`,\n        },\n        screenshots: [\n          { src: \"/screenshots/getting-started/FirstSession.png\", alt: \"Claude Code interactive session showing natural language instructions and tool call approvals\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: 'Be specific and conversational. Claude Code works best when you describe what you want, not how to do it. Start with \"What does this file do?\" to orient Claude before making changes. Use /help inside a session to see all available slash commands.',\n      },\n    ],\n  },\n  {\n    slug: \"claude-md\",\n    title: \"CLAUDE.md\",\n    emoji: \"üìÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Give Claude persistent project-level instructions via a markdown file.\",\n    sections: [\n      {\n        heading: \"The /init Command\",\n        body: \"When starting a new project, run /init. Claude scans the codebase, creates a summary, and writes it to CLAUDE.md. This file is then included in every subsequent request. When Claude asks permission: hit Enter to approve each write, or press Shift+Tab to let Claude write files freely.\",\n        code: {\n          language: \"bash\",\n          content: `# In a new project terminal:\n> /init\n\nClaude: I'll analyze your codebase to understand its structure\n        and create a comprehensive CLAUDE.md file.\n        Let me start by exploring the repository...\n\n# Claude then:\n# 1. Scans your codebase\n# 2. Creates a summary\n# 3. Writes it to CLAUDE.md  ‚Üê included in every future request\n\n# When prompted to write the file:\n# Press Enter        ‚Üí approve this write\n# Press Shift+Tab    ‚Üí allow Claude to write files freely this session`,\n        },\n      },\n      {\n        heading: \"CLAUDE.md File Locations\",\n        body: \"Claude recognizes three distinct CLAUDE.md files in three common locations. Each serves a different scope ‚Äî project-shared, personal, or global across all projects. Below images shows the file locations and their scopes, where the first one is GLOBAL CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects, and the second one shows CLAUDE.md and CLAUDE.local.md file.\",\n        code: {\n          language: \"text\",\n          content: `CLAUDE.md\n  ‚Ä¢ Generated by /init\n  ‚Ä¢ Committed to source control\n  ‚Ä¢ Shared with all engineers on the team\n\nCLAUDE.local.md (manually created)\n  ‚Ä¢ NOT committed to source control\n  ‚Ä¢ Contains personal instructions and customizations\n  ‚Ä¢ Invisible to other engineers\n\n~/.claude/CLAUDE.md\n  ‚Ä¢ Applies to ALL projects on your machine\n  ‚Ä¢ Contains instructions you want Claude to follow everywhere\n  ‚Ä¢ Your personal global defaults`,\n        },\n\n        \n        screenshots: [\n          { src: \"/screenshots/claude-md/Global Claude.png\", alt: \"Global CLAUDE.md file at ~/.claude/CLAUDE.md applying instructions across all projects\" },\n          { src: \"/screenshots/claude-md/Claude.png\", alt: \"CLAUDE.md file locations showing project, local, and global scopes\" },\n        ],\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Use /init at the start of every new project ‚Äî don't write CLAUDE.md by hand. Put personal preferences in CLAUDE.local.md so teammates aren't affected. Use ~/.claude/CLAUDE.md for habits that apply everywhere (tone, comment style, language preferences).\",\n      },\n    ],\n  },\n  {\n    slug: \"cli-commands\",\n    title: \"CLI Commands\",\n    emoji: \"‚å®Ô∏è\",\n    released: true,\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    shortDesc: \"Master the full set of CLI flags, modes, and slash commands.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a rich CLI interface with flags for non-interactive mode, piping, model selection, and more. Inside a session, slash commands give you quick access to special behaviors like plan mode, memory management, and session clearing.\",\n      },\n      {\n        heading: \"Launch Flags\",\n        body: \"Use flags to control how Claude Code starts and behaves. The most important are -p for one-shot (non-interactive) mode, --model to select a Claude model, and --dangerously-skip-permissions for automated environments.\",\n        code: {\n          language: \"bash\",\n          content: `# Start interactive session\nclaude\n\n# One-shot: print a question, get an answer, exit\nclaude -p \"What does this codebase do?\"\n\n# Pipe input to Claude\ncat error.log | claude -p \"Explain this error\"\n\n# Select a specific model\nclaude --model claude-opus-4-6\n\n# Resume the most recent session\nclaude --resume\n\n# Continue with a specific session ID\nclaude --resume <session-id>\n\n# Read-only mode (no file writes or bash execution)\nclaude --read-only`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/LaunchFlag.png\",\n            alt: \"CLI launch flags in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Slash Commands (In-Session)\",\n        body: \"During an interactive session, slash commands let you trigger special behaviors without leaving the conversation. These are typed directly in the Claude Code prompt.\",\n        code: {\n          language: \"text\",\n          content: `/help          ‚Äî Show all available slash commands\n/plan          ‚Äî Enter plan mode for structured task planning\n/compact       ‚Äî Compress conversation context to free up space\n/clear         ‚Äî Clear conversation history and start fresh\n/model         ‚Äî Switch to a different Claude model mid-session\n/memory        ‚Äî View and manage persistent memory files\n/review        ‚Äî Review recent changes made by Claude\n/undo          ‚Äî Undo the last file change\n/tasks         ‚Äî Show the current task list\n/fast          ‚Äî Toggle fast mode (optimized for speed)\n/vim           ‚Äî Toggle vim keybindings`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/Slash.png\",\n            alt: \"Slash commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Custom Commands\",\n        body: \"Custom commands let you create your own slash commands by placing markdown files in .claude/commands/. The filename becomes the command name ‚Äî so audit.md creates /audit. Use the $ARGUMENTS placeholder to accept dynamic input when invoking the command.\",\n        code: {\n          language: \"text\",\n          content: `# Folder structure\n.claude/\n  commands/\n    audit.md        ‚Üí /audit\n    write_tests.md  ‚Üí /write_tests\n\n# Example: audit.md\nRun npm audit to find vulnerable packages, then run npm audit fix to apply updates, then run tests to verify nothing broke.\n\n# Example: write_tests.md (with arguments)\nWrite comprehensive tests for: $ARGUMENTS\n\nTesting conventions:\n* Use Vitest with React Testing Library\n* Place test files in a __tests__ directory\n* Name test files as [filename].test.ts(x)\n\n# Invoke with arguments\n/write_tests the use-auth.ts file in the hooks directory`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/cli-commands/CustomCommand.png\",\n            alt: \"Custom commands in action\",\n          },\n        ],\n      },\n      {\n        heading: \"Output & Scripting\",\n        body: \"Claude Code can be embedded in shell scripts and CI pipelines using the -p flag with output formatting options. This enables automated code review, documentation generation, and more.\",\n        code: {\n          language: \"bash\",\n          content: `# Output as JSON for scripting\nclaude -p \"List all API endpoints\" --output-format json\n\n# Stream output as it arrives\nclaude -p \"Explain this function\" --output-format stream-json\n\n# Use in a git hook\necho \"Review this diff for security issues:\" | git diff | claude -p`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use claude -p for automation and scripting without interactive overhead. Use /compact frequently on long sessions to prevent context limits from slowing Claude down. The --resume flag is great for continuing work across terminal restarts.\",\n      },\n    ],\n    references: [\n      {\n        label: \"CLI Reference\",\n        url: \"https://code.claude.com/docs/en/cli-reference\",\n        description: \"Complete reference for all CLI commands and flags.\",\n      },\n      {\n        label: \"Slash Reference\",\n        url: \"https://code.claude.com/docs/en/interactive-mode#built-in-commands\",\n        description: \"Complete reference for all Slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"keyboard-shortcuts\",\n    title: \"Keyboard Shortcuts\",\n    emoji: \"‚ö°\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Navigate and control Claude Code sessions with keyboard shortcuts.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code has a set of keyboard shortcuts that let you control the conversation flow, submit multi-line inputs, interrupt Claude mid-action, and manage the session efficiently ‚Äî all without leaving the keyboard.\",\n      },\n      {\n        heading: \"Essential Shortcuts\",\n        body: \"These are the shortcuts you will use in every session. Shift+Enter is especially important for writing multi-line prompts without accidentally submitting early.\",\n        code: {\n          language: \"text\",\n          content: `Enter          ‚Äî Submit your message to Claude\nShift+Enter    ‚Äî Insert a newline (multi-line input)\nCtrl+C         ‚Äî Interrupt Claude while it is running a tool\nCtrl+D         ‚Äî Exit the session gracefully (sends EOF)\nCtrl+L         ‚Äî Clear the terminal screen (keeps context)\nUp/Down Arrow  ‚Äî Navigate through your message history`,\n        },\n      },\n      {\n        heading: \"Interruption & Control\",\n        body: \"Ctrl+C is your best friend for stopping Claude if it is doing something unexpected. After interruption, Claude reports what it was doing and waits for your next instruction. You can then redirect or undo.\",\n        code: {\n          language: \"text\",\n          content: `# Scenario: Claude is running a long build\n> Build the project and run all tests\n[Claude starts running: npm run build...]\n\n# Press Ctrl+C to interrupt\n^C\nClaude: Interrupted. I was running: npm run build\n        The build had started but not completed.\n        What would you like to do?\n\n> Just run the unit tests, skip the build`,\n        },\n      },\n      {\n        heading: \"Multi-line Input\",\n        body: \"Use Shift+Enter to write complex, multi-line prompts. This is useful for providing detailed context, pasting code snippets, or writing structured instructions with multiple requirements.\",\n        code: {\n          language: \"text\",\n          content: `> Please make the following changes:    [Shift+Enter]\n  1. Add input validation to the login form  [Shift+Enter]\n  2. Show error messages below each field    [Shift+Enter]\n  3. Disable the submit button while loading [Enter to submit]`,\n        },\n      },\n      {\n        heading: \"Vim Mode\",\n        body: \"If you are a Vim user, you can enable vim keybindings in the Claude Code input with /vim. This lets you use normal/insert/visual modes for editing your prompt before submitting.\",\n        code: {\n          language: \"text\",\n          content: `# Enable vim mode inside a session\n/vim\n\n# Now the input supports:\n# Esc      ‚Äî switch to normal mode\n# i        ‚Äî enter insert mode\n# v        ‚Äî visual mode for selection\n# :q       ‚Äî quit (closes session)\n# Standard vim motion keys: hjkl, w, b, 0, $, gg, G`,\n        },\n      },\n      {\n        heading: \"Rewinding Conversations\",\n        body: \"During long conversations, you might accumulate context that becomes irrelevant or distracting. For instance, if Claude encounters an error and spends time debugging it, that back-and-forth discussion might not be useful for the next task.\\n\\nYou can rewind the conversation by pressing Escape twice. This shows you all the messages you've sent, allowing you to jump back to an earlier point and continue from there. This technique helps you:\",\n        bullets: [\n          \"Maintain valuable context (like Claude's understanding of your codebase)\",\n          \"Remove distracting or irrelevant conversation history\",\n          \"Keep Claude focused on the current task\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Press Escape twice to enter rewind mode\nEsc Esc\n\n# Claude shows your message history:\n[1] > /init\n[2] > Add authentication to the app\n[3] > Fix the TypeScript error   ‚Üê back-and-forth debugging noise\n[4] > Now add the login form\n\n# Select an earlier message to continue from that point\n# Claude picks up as if the noisy messages never happened`,\n        },\n      },\n      {\n        heading: \"Interrupting Claude with Escape\",\n        body: \"Sometimes Claude starts heading in the wrong direction or tries to tackle too much at once. You can press the Escape key to stop Claude mid-response, allowing you to redirect the conversation.\\n\\nThis is particularly useful when you want Claude to focus on one specific task instead of trying to handle multiple things simultaneously. For example, if you ask Claude to write tests for multiple functions and it starts creating a comprehensive plan for all of them, you can interrupt and ask it to focus on just one function at a time.\",\n        code: {\n          language: \"text\",\n          content: `# Claude starts going too broad:\n> Write tests for all the utility functions\n[Claude: I'll create a comprehensive test suite covering...]\n\n# Press Escape to interrupt\nEsc\nClaude: Interrupted.\n\n# Redirect to something narrower:\n> Just write tests for the formatDate function first`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Learn Ctrl+C muscle memory early ‚Äî it's safer to interrupt and redirect than to let Claude continue in a wrong direction. Use the Up arrow to quickly re-send a slightly modified version of your last prompt. Use Esc+Esc (rewind) when a debugging tangent has polluted your context ‚Äî it's faster than starting a fresh session.\",\n      },\n    ],\n  },\n  {\n    slug: \"permission-modes\",\n    title: \"Permission Modes\",\n    emoji: \"üîê\",\n    category: \"Core CLI\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Control what Claude can do automatically vs. what requires your approval.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code operates with a permission system that controls which tools it can use without explicit user approval. This balances autonomy (getting work done fast) with safety (you stay in control). Understanding permission modes is key to using Claude Code confidently.\",\n      },\n      {\n        heading: \"Default Mode\",\n        body: \"In default mode, Claude Code prompts you before executing any tool call that could have side effects: writing files, running commands, making network requests. Read operations (file reads, searches) are allowed automatically. This is the safest mode for everyday use.\",\n        code: {\n          language: \"text\",\n          content: `# Default behavior: Claude asks before writing\n> Add a README to this project\n\nClaude: I will create README.md with project documentation.\n        Allow: Write README.md? [y/n/always/never]\n        > y   ‚Üê you approve this one action\n\n# Read operations happen automatically\nClaude: [reads package.json, src/index.ts, ...] (no prompt)`,\n        },\n      },\n      {\n        heading: \"Auto-Approve Mode\",\n        body: 'You can tell Claude to auto-approve specific tools or all tools using the \"always\" option when prompted, or by configuring it in settings. This speeds up sessions when you trust Claude to work autonomously.',\n        code: {\n          language: \"text\",\n          content: `# When prompted, choose \"always\" to auto-approve a tool type\nAllow: Write src/utils.ts? [y/n/always/never]\n> always    ‚Üê all future Write tool calls auto-approved this session\n\n# Or start with auto-permissions flag (for trusted automation)\nclaude --dangerously-skip-permissions\n\n# Or configure in settings.json\n{\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Write(src/*)\", \"Read\"]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Read-Only Mode\",\n        body: \"Read-only mode restricts Claude to only reading files and searching the codebase ‚Äî no writes, no bash execution. This is perfect for code review, exploration, and answering questions without risk of changes.\",\n        code: {\n          language: \"bash\",\n          content: `# Start in read-only mode\nclaude --read-only\n\n# Now Claude can only:\n# - Read files\n# - Search with Grep/Glob\n# - Fetch web content\n# But CANNOT:\n# - Write or edit files\n# - Run bash commands\n# - Execute any destructive action`,\n        },\n      },\n      {\n        heading: \"Permission Rules\",\n        body: 'Fine-grained permission rules let you allow or deny specific tool patterns. Rules follow a \"Tool(pattern)\" format and support glob-style matching.',\n        code: {\n          language: \"json\",\n          content: `// settings.json ‚Äî fine-grained permission rules\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",        // allow all npm run scripts\n      \"Bash(git status)\",        // allow git status only\n      \"Write(src/**)\",           // allow writes inside src/\n      \"Read\"                     // allow all reads\n    ],\n    \"deny\": [\n      \"Bash(rm *)\",              // deny all rm commands\n      \"Bash(git push *)\"         // deny git push\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with default mode to build trust, then selectively enable auto-approve for tools you're comfortable with. Use read-only mode when exploring unfamiliar codebases. Never use --dangerously-skip-permissions in production environments.\",\n      },\n    ],\n  },\n  {\n    slug: \"settings\",\n    title: \"Settings & Configuration\",\n    emoji: \"‚öôÔ∏è\",\n    category: \"Core CLI\",\n    difficulty: \"Beginner\",\n    released: true,\n    shortDesc:\n      \"Configure Claude Code globally or per-project, and keep secrets out of version control.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code uses three layered settings.json files. `~/.claude/settings.json` is a global config that applies to every project on your machine. `.claude/settings.json` is the shared project config committed to git. `.claude/settings.local.json` is a machine-specific override that stays git-ignored. Together they let teams share a baseline while each developer keeps personal tweaks.\",\n      },\n      {\n        heading: \"Settings File Locations\",\n        body: \"Settings cascade from global ‚Üí project ‚Üí local. The file closest to you wins on any conflicting key. Nothing is lost from lower layers ‚Äî only conflicting keys get overwritten. The `.claude/` directory also holds skills, worktrees, and memory.\",\n        code: {\n          language: \"text\",\n          content: `Layer 1 ‚Äî Global (applies to every project on your machine)\n  ~/.claude/settings.json\n\n    Layer 2 ‚Äî Project shared (committed, applies to all teammates)\n      .claude/settings.json\n\n        Layer 3 ‚Äî Your local overrides (git-ignored, your machine only)\n          .claude/settings.local.json   ‚Üê wins on conflict\n\n# The .claude/ directory structure:\n.claude/\n‚îú‚îÄ‚îÄ settings.json        ‚Üê project settings (commit this)\n‚îú‚îÄ‚îÄ settings.local.json  ‚Üê personal overrides (git-ignored)\n‚îú‚îÄ‚îÄ skills/              ‚Üê project-specific skills\n‚îî‚îÄ‚îÄ worktrees/           ‚Üê temporary worktree checkouts`,\n        },\n      },\n      {\n        heading: \"settings.json ‚Äî Shared Project Config\",\n        body: \"Lives at `.claude/settings.json` inside your project. Commit this file to share consistent tool permissions, hooks, and environment defaults with everyone on the team. Ideal for rules that should apply to all contributors: which tools Claude can auto-approve, custom slash-command hooks, or model preferences.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json  (committed to git)\n{\n  \"model\": \"claude-sonnet-4-6\",\n\n  \"permissions\": {\n    \"allow\": [\"Bash(npm run *)\", \"Read\", \"Write\", \"Edit\"],\n    \"deny\": [\"Bash(rm -rf *)\", \"Bash(git push --force *)\"]\n  },\n\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\" }\n    }\n  },\n\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"npm run lint --silent\" }]\n      }\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"settings.local.json ‚Äî Personal Overrides\",\n        body: \"Lives at `.claude/settings.local.json` and is git-ignored by default. Use it for anything you don't want to share: personal API keys, machine-specific paths, or a wider auto-approve list that suits your own workflow. You only need to specify what you're overriding ‚Äî it merges on top of the project config.\",\n        screenshots: [\n          {\n            src: \"/screenshots/Setting.png\",\n            alt: \"Claude Code settings.local.json personal overrides\",\n          },\n        ],\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json  (git-ignored)\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm run *)\",\n      \"Bash(git *)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\",\n      \"Bash(npx prisma *)\"\n    ]\n  },\n  \"env\": {\n    \"MY_PERSONAL_API_KEY\": \"sk-...\"\n  }\n}`,\n        },\n      },\n      {\n        heading: \"What Belongs Where\",\n        body: \"If every team member needs it, put it in `settings.json`. If it's personal, machine-specific, or contains a secret, put it in `settings.local.json`. Never commit API keys or personal access tokens.\",\n        code: {\n          language: \"text\",\n          content: `settings.json (commit)         settings.local.json (don't commit)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nShared auto-approve rules      Personal wider permissions\nProject lint/format hooks      Personal API keys or tokens\nModel preferences for CI       Machine-specific binary paths\nCustom slash-command hooks     Dev-only env var overrides`,\n        },\n      },\n      {\n        heading: \"Environment Variables\",\n        body: \"Some Claude Code behavior is also configurable via environment variables ‚Äî useful for CI/CD environments where you can't easily write settings files.\",\n        code: {\n          language: \"bash\",\n          content: `# Core environment variables:\nANTHROPIC_API_KEY=sk-ant-...        # Required: your API key\nCLAUDE_MODEL=claude-opus-4-6        # Override default model\nCLAUDE_MAX_TOKENS=8192              # Override max response tokens\nANTHROPIC_BASE_URL=https://...      # Custom API endpoint (proxies)\n\n# Non-interactive / CI usage:\nexport ANTHROPIC_API_KEY=\"$SECRET_KEY\"\nclaude -p \"Review this code for security issues\" < code.ts`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Add `.claude/settings.local.json` to your global `.gitignore` so it can never be accidentally committed. Commit `.claude/settings.json` so the whole team shares project-level configuration. Keep API keys in environment variables, not settings files. Review your team's `settings.json` in code review just like any other config file ‚Äî it controls what Claude can do automatically.\",\n      },\n    ],\n    references: [\n      {\n        label: \"Claude Code Settings Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/settings\",\n        description: \"Official reference for all available settings fields.\",\n      },\n    ],\n  },\n  {\n    slug: \"plan-vs-think-mode\",\n    title: \"Plan Mode vs Think Mode\",\n    emoji: \"üìã\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Make Claude plan before acting ‚Äî get architectural clarity upfront.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plan mode tells Claude to think through a task and write a structured plan before touching any code. This prevents wasted effort, surfaces ambiguities early, and gives you a chance to redirect before Claude dives into implementation. It's the difference between a junior dev who starts coding immediately and a senior dev who designs first.\",\n      },\n      {\n        heading: \"Entering Plan Mode\",\n        body: \"Use /plan inside a session to enter plan mode, or explicitly ask Claude to plan before acting. Claude will then write a plan (typically to a tasks/todo.md file) and present it for your approval before proceeding.\",\n        code: {\n          language: \"text\",\n          content: `# Enter plan mode with slash command\n> /plan\n\n# Or ask explicitly\n> Before writing any code, plan how you would add authentication to this app.\n  Think through the architecture, list the files you would change, and identify\n  any dependencies we might need.\n\n# Claude responds with a structured plan:\nClaude: Here is my plan for adding authentication:\n\n## Approach\nUse NextAuth.js with JWT sessions...\n\n## Files to Create\n- src/lib/auth.ts         (auth configuration)\n- src/app/api/auth/[...nextauth]/route.ts\n\n## Files to Modify\n- src/app/layout.tsx      (wrap with SessionProvider)\n- src/middleware.ts       (protect routes)\n\n## Steps\n1. Install next-auth\n2. Configure providers...\n\nShall I proceed with this plan?`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"In plan mode, Claude uses the ExitPlanMode tool to signal it is ready for approval after writing the plan. You can ask questions, request changes to the plan, or approve it. Only after approval does Claude start making file changes. The plan is typically saved to tasks/todo.md so it persists.\",\n      },\n      {\n        heading: \"When to Use Plan Mode\",\n        body: \"Use plan mode for any task with 3+ steps, architectural decisions, or when the approach could go multiple ways. Skip it for simple one-line fixes or obvious bug patches.\",\n        code: {\n          language: \"text\",\n          content: `# Use plan mode for:\n> Plan how to add dark mode support across the entire app\n> Plan a database schema refactor for the user table\n> Plan the migration from REST to GraphQL\n\n# Skip plan mode for:\n> Fix the typo in README.md\n> Add a console.log to debug this function\n> Change the button color to blue`,\n        },\n      },\n      {\n        heading: \"Enabling Planning Mode\",\n        body: \"For more complex tasks that require extensive research across your codebase, you can enable Planning Mode. This feature makes Claude do thorough exploration of your project before implementing changes.\\n\\nEnable Planning Mode by pressing Shift + Tab twice (or once if you're already auto-accepting edits). In this mode, Claude will:\\n\\n‚Ä¢ Read more files in your project\\n‚Ä¢ Create a detailed implementation plan\\n‚Ä¢ Show you exactly what it intends to do\\n‚Ä¢ Wait for your approval before proceeding\\n\\nThis gives you the opportunity to review the plan and redirect Claude if it missed something important or didn't consider a particular scenario.\",\n        code: {\n          language: \"text\",\n          content: `# Activate planning mode:\nShift + Tab  (press twice from default mode)\nShift + Tab  (press once if auto-accepting edits)\n\n# Claude enters plan mode and will:\n# 1. Explore your codebase thoroughly\n# 2. Write a structured plan to tasks/todo.md\n# 3. Present the plan for your review\n# 4. Wait for approval before writing any code\n\n> Refactor the authentication system to use JWT\n[Claude reads 12 files, identifies 4 affected components...]\n[Claude writes plan ‚Äî awaiting your approval]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/plan-vs-think-mode/Plan.png\", alt: \"Plan mode in action\" },\n        ],\n      },\n      {\n        heading: \"Thinking Modes\",\n        body: \"Claude offers different levels of reasoning through \\\"thinking\\\" modes. These allow Claude to spend more time reasoning about complex problems before providing solutions. Each mode gives Claude progressively more tokens to work with, allowing for deeper analysis of challenging problems.\",\n        bullets: [\n          \"\\\"Think\\\" - Basic reasoning\",\n          \"\\\"Think more\\\" - Extended reasoning\",\n          \"\\\"Think a lot\\\" - Comprehensive reasoning\",\n          \"\\\"Think longer\\\" - Extended time reasoning\",\n          \"\\\"Ultrathink\\\" - Maximum reasoning capability\",\n        ],\n        code: {\n          language: \"text\",\n          content: `# Use thinking modes by including them in your prompt:\n\n> Think about the best architecture for this feature\n> Think more about potential edge cases in this logic\n> Think a lot about how to refactor this without breaking tests\n> Ultrathink about the security implications of this approach\n\n# When to use each:\n# \"Think\"      ‚Üí Simple decisions, quick tradeoff analysis\n# \"Think more\" ‚Üí Design decisions, debugging hard bugs\n# \"Think a lot\" ‚Üí Architecture changes, complex refactors\n# \"Ultrathink\"  ‚Üí Security reviews, critical system design`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Ask Claude to include file counts, estimated complexity, and potential risks in its plans. If a plan looks too complex, ask it to find a simpler approach. A good plan prevents 80% of rework ‚Äî invest time here. Use Ultrathink sparingly ‚Äî it consumes significantly more tokens but is worth it for high-stakes decisions.\",\n      },\n    ],\n  },\n  {\n    slug: \"tool-use\",\n    title: \"Tool Use\",\n    emoji: \"üõ†Ô∏è\",\n    category: \"Intelligence\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc: \"Understand the tools Claude uses to interact with your system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude Code's power comes from its tools ‚Äî specialized capabilities that let it interact with your filesystem, terminal, browser, and more. When you give Claude an instruction, it selects and uses tools to accomplish the task. Understanding these tools helps you predict what Claude will do and how to guide it effectively.\",\n      },\n      {\n        heading: \"File System Tools\",\n        body: \"The most frequently used tools are for reading and writing files. Claude uses Read to understand code, Glob to find files by pattern, Grep to search content, Write to create new files, and Edit to make targeted changes.\",\n        code: {\n          language: \"text\",\n          content: `Read          ‚Äî Read a file (shows line numbers, respects limits)\nWrite         ‚Äî Create or overwrite a file entirely\nEdit          ‚Äî Make exact string replacements in a file\nGlob          ‚Äî Find files matching a pattern (e.g., \"**/*.ts\")\nGrep          ‚Äî Search file contents with regex\n\n# Example tool calls Claude makes internally:\nRead: src/components/Button.tsx\nGlob: src/**/*.test.ts\nGrep: pattern=\"useState\", path=\"src/\", type=\"ts\"\nEdit: old=\"const x = 1\" new=\"const x = 2\" in Button.tsx`,\n        },\n      },\n      {\n        heading: \"Execution Tools\",\n        body: \"The Bash tool lets Claude run shell commands: install packages, run tests, start servers, execute scripts. This is the most powerful (and potentially risky) tool, which is why it always requires permission by default.\",\n        code: {\n          language: \"bash\",\n          content: `# Claude uses Bash tool for:\nnpm install         # Install dependencies\nnpm run test        # Run tests\ngit status          # Check git state\ngit add . && git commit -m \"...\"  # Commit changes\nls src/components/  # List files\ncurl https://...    # Fetch URLs`,\n        },\n      },\n      {\n        heading: \"Intelligence Tools\",\n        body: \"Claude has meta-tools for managing its own workflow: Task (spawn subagents), TodoWrite/TodoRead (task lists), WebSearch and WebFetch (internet access), and specialized tools like NotebookEdit for Jupyter notebooks.\",\n        code: {\n          language: \"text\",\n          content: `Task          ‚Äî Spawn a subagent for a specialized sub-task\nWebSearch     ‚Äî Search the web for current information\nWebFetch      ‚Äî Fetch and read a specific URL\nTodoWrite     ‚Äî Write structured task checklists\nTodoRead      ‚Äî Read the current task list\nNotebookEdit  ‚Äî Edit Jupyter notebook cells\nmcp__*        ‚Äî Tools from connected MCP servers`,\n        },\n      },\n      {\n        heading: \"How Claude Selects Tools\",\n        body: 'Claude picks tools based on what the task requires. For \"read this file\", it uses Read. For \"find all files with this pattern\", it uses Glob. For \"run the tests\", it uses Bash. Claude prefers dedicated tools over Bash when available, as dedicated tools provide better user experience and auditability.',\n      },\n      {\n        heading: \"Tips\",\n        body: 'You can guide tool selection by being specific: \"search for the function definition\" (Grep) vs \"list files in the components folder\" (Glob/Bash). Watch the tool calls Claude makes to understand how it reasons about your codebase.',\n      },\n    ],\n  },\n  {\n    slug: \"extended-thinking\",\n    title: \"Extended Thinking\",\n    emoji: \"üß†\",\n    category: \"Intelligence\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Enable deep reasoning for complex architectural and algorithmic problems.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: 'Extended Thinking is a Claude capability that allocates additional \"thinking tokens\" ‚Äî internal reasoning steps that Claude works through before giving its final answer. This dramatically improves performance on hard problems: algorithm design, complex debugging, architectural trade-offs, and mathematical reasoning. The thinking is visible to you as a scratchpad.',\n      },\n      {\n        heading: \"When It Activates\",\n        body: \"Extended thinking activates automatically when Claude determines a problem is complex enough to warrant it, or when you explicitly ask Claude to think deeply. It is most valuable for problems where the naive answer might be wrong or where multiple approaches need careful evaluation.\",\n        code: {\n          language: \"text\",\n          content: `# These prompts tend to trigger extended thinking:\n> Think carefully about the best architecture for this feature\n> I need you to deeply analyze the security implications here\n> What is the most efficient algorithm for this problem?\n> Think step by step through all the edge cases\n\n# Or explicitly enable via API:\n{\n  \"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000   // up to 16,000 tokens of thinking\n  }\n}`,\n        },\n      },\n      {\n        heading: \"How It Works\",\n        body: \"During extended thinking, Claude produces a <thinking> block where it reasons freely ‚Äî exploring wrong paths, backtracking, reconsidering. This scratchpad is separate from the final answer. The final response reflects the conclusions of that reasoning process. You can see the thinking in Claude Code's output.\",\n      },\n      {\n        heading: \"Use Cases\",\n        body: \"Extended thinking shines for: debugging complex race conditions, designing a system from scratch, refactoring large codebases, writing complex SQL/regex, and understanding unfamiliar code patterns. It is less useful for simple CRUD operations or trivial edits.\",\n        code: {\n          language: \"text\",\n          content: `# Good use cases:\n> Think through how to refactor this 500-line function\n  into maintainable pieces without breaking behavior\n\n> Analyze why this async function has a race condition\n  and design the fix carefully\n\n> I need a regex that matches ISO dates but not invalid\n  dates like Feb 30. Think through all the cases.\n\n# Not worth extended thinking:\n> Add a semicolon to line 42\n> Rename this variable to camelCase`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: 'Ask Claude to \"think carefully\" or \"think step by step\" to encourage deeper reasoning without necessarily hitting full extended thinking mode. For API usage, set a generous budget_tokens (8000+) for truly hard problems. Extended thinking uses more tokens and is slower ‚Äî use it deliberately.',\n      },\n    ],\n  },\n  {\n    slug: \"auto-memory\",\n    title: \"Auto Memory\",\n    emoji: \"üóÇÔ∏è\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Persist knowledge across sessions with Claude's auto memory system.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Auto Memory gives Claude Code a persistent memory directory where it can save and retrieve information across sessions. Unlike conversation context (which resets each session), memory files persist indefinitely. Claude uses them to remember user preferences, architectural decisions, debugging insights, and patterns learned from corrections.\",\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryWork.png\", alt: \"How auto memory works\" },\n        ],\n      },\n      {\n        heading: \"How Are Memories Stored?\",\n        body: \"There are three ways memories get written:\",\n        bullets: [\n          \"Automatically during the session by Claude\",\n          'Manually via /memory (similar to CLAUDE.md) or by directly editing the file',\n          'When triggered by the user ‚Äî \"remember that ___\"',\n        ],\n        code: {\n          language: \"text\",\n          content: `> Remember that we like files in this project named this way.\n‚óè Recalled 1 memory, wrote 1 memory`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryRemember.png\", alt: \"Claude remembering a user instruction\" },\n        ],\n      },\n      {\n        heading: \"Memory Directory\",\n        body: \"Claude Code creates a memory directory per project under your home directory. The main file is MEMORY.md, which is always loaded into context ‚Äî but only the first 200 lines are read; anything beyond that is truncated. Additional topic-specific files can be created and linked from MEMORY.md for detailed notes.\",\n        code: {\n          language: \"text\",\n          content: `# Memory directory location:\n~/.claude/projects/<project-path>/memory/\n\n# Files in memory:\nMEMORY.md           ‚Üê always loaded (keep under 200 lines)\ndebugging.md        ‚Üê linked from MEMORY.md for details\npatterns.md         ‚Üê code patterns and conventions\narchitecture.md     ‚Üê key architectural decisions`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/MemoryLocation.png\", alt: \"Memory directory location\" },\n        ],\n      },\n      {\n        heading: \"What Gets Saved\",\n        body: \"Claude saves stable patterns confirmed across multiple interactions, user preferences, key file paths, solutions to recurring problems, and lessons from corrections. It avoids saving session-specific or speculative information.\",\n        code: {\n          language: \"markdown\",\n          content: `# Example MEMORY.md content\n\n## Project: claude-learning-app\nNext.js 16, React 19, Tailwind CSS 4 (not Tailwind 3).\nsearchParams is a Promise in Next.js 15+ ‚Äî always await it.\n\n## User Preferences\n- User prefers concise responses, no emojis\n- Always run lint before declaring done\n- User uses bun, not npm for package management\n\n## Key File Paths\n- Data: src/data/concepts.ts\n- Components: src/components/\n- API routes: src/app/api/\n\n## Recurring Patterns\n- Use \"use client\" directive for interactive components\n- CategoryFilter uses URL search params, not useState`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/AutoMemory.png\", alt: \"Auto memory in action\" },\n        ],\n      },\n      {\n        heading: \"Managing Memory\",\n        body: \"Use /memory inside a session to view and manage memory files. You can ask Claude to remember or forget specific things. Memory is organized semantically by topic, not chronologically.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a Claude Code session:\n> /memory                     ‚Üê view current memory\n> Remember to always use bun instead of npm\n> Forget the note about the old database schema\n> Update the architecture memory with the new API structure`,\n        },\n        screenshots: [\n          { src: \"/screenshots/auto-memory/Memory.png\", alt: \"Managing memory in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Disabling Auto Memory\",\n        body: \"Auto memory is enabled by default. You can disable it globally for all projects or for a single project by setting autoMemoryEnabled to false in the respective settings file.\",\n        code: {\n          language: \"json\",\n          content: `// Disable for all projects ‚Äî ~/.claude/settings.json\n{ \"autoMemoryEnabled\": false }\n\n// Disable for a single project ‚Äî .claude/settings.json\n{ \"autoMemoryEnabled\": false }`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep MEMORY.md under 200 lines ‚Äî content beyond that gets truncated. Link to detailed topic files for long-form notes. Ask Claude to review its memory at the start of complex sessions to ensure it's working from accurate context.\",\n      }\n      \n    ],\n  },\n  {\n    slug: \"context-management\",\n    title: \"Context Management\",\n    emoji: \"üîÑ\",\n    category: \"Memory\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Manage Claude's context window to maintain performance on long sessions.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Claude has a finite context window ‚Äî the total amount of text (conversation history, file contents, tool results) it can hold at once. As sessions grow longer, the context fills up, causing slower responses and eventual truncation. Understanding context management keeps Claude sharp throughout long coding sessions.\",\n      },\n      {\n        heading: \"Context Limits\",\n        body: \"Claude's context window is measured in tokens (roughly 4 characters per token). Claude Code automatically tracks context usage and warns you when approaching limits. Different Claude models have different context sizes.\",\n        code: {\n          language: \"text\",\n          content: `# Claude models and approximate context sizes:\nclaude-opus-4-6     ‚Äî 200,000 tokens (~150,000 words)\nclaude-sonnet-4-6   ‚Äî 200,000 tokens (~150,000 words)\nclaude-haiku-4-5    ‚Äî 200,000 tokens (~150,000 words)\n\n# Context is consumed by:\n- Conversation history (every message both ways)\n- File contents read by Claude\n- Tool call results (bash output, search results)\n- System prompts (CLAUDE.md, memory files)`,\n        },\n      },\n      {\n        heading: \"The /compact Command\",\n        body: \"/compact is your primary tool for managing context. It summarizes the conversation history into a compact form, freeing up space while preserving the key information Claude needs to continue working. Use it proactively before context runs low.\",\n        code: {\n          language: \"text\",\n          content: `# Inside a session, when context is getting full:\n> /compact\n\nClaude: Compacting conversation history...\n[Summarizes 50 messages into a brief summary]\nContext freed: ~45,000 tokens\n\n# You can also compact with a specific focus:\n> /compact Focus on the authentication work we did,\n  keep the file structure summary`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Compact.png\", alt: \"The /compact command in action\" },\n        ],\n      },\n      {\n        heading: \"The /clear Command\",\n        body: \"The /clear command wipes the entire conversation context and starts fresh. Unlike /compact which summarizes and compresses, /clear gives you a completely blank slate. Use it when the current context is too noisy, you're switching to an unrelated task, or Claude has gone off track and needs a hard reset.\",\n        code: {\n          language: \"text\",\n          content: `# Wipe the context and start fresh:\n> /clear\n\n# When to use /clear vs /compact:\n# /compact ‚Äî keep working on the same task, just compress history\n# /clear   ‚Äî done with this task entirely, starting something new\n\n> /clear\n[Conversation context cleared ‚Äî memory files still intact]`,\n        },\n        screenshots: [\n          { src: \"/screenshots/context-management/Clear.png\", alt: \"The /clear command in action\" },\n        ],\n      },\n      {\n        heading: \"Best Practices\",\n        body: \"Start new sessions for new tasks instead of extending old ones indefinitely. Use /compact before switching to a different part of the codebase. Avoid asking Claude to read very large files unnecessarily ‚Äî ask it to read specific sections instead.\",\n        code: {\n          language: \"text\",\n          content: `# Instead of reading a huge file:\n> Read src/legacy-monolith.ts       ‚Üê reads 5,000 lines\n\n# Read only what you need:\n> Read lines 100-150 of src/legacy-monolith.ts\n> Search for the UserAuthService class definition\n> What does the validateToken function do in auth.ts?`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Run /compact after completing each major task in a long session. Watch for Claude's responses becoming vaguer or less precise ‚Äî this can be a sign of context pressure. Starting fresh sessions costs context on CLAUDE.md re-loading but avoids stale conversation clutter.\",\n      },\n    ],\n  },\n  {\n    slug: \"prompt-caching\",\n    title: \"Prompt Caching\",\n    emoji: \"‚ö°\",\n    category: \"Memory\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Reduce API costs and latency by caching repeated context prefixes.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Prompt caching is an Anthropic API feature that lets you cache the beginning (prefix) of a prompt so subsequent requests reuse the cached version instead of reprocessing it. This reduces costs by up to 90% and cuts latency significantly for requests that share a common prefix ‚Äî like a large system prompt, codebase context, or document.\",\n      },\n      {\n        heading: \"How It Works\",\n        body: \"You mark cache breakpoints in your prompt using the cache_control parameter. Anthropic's infrastructure caches the KV (key-value) attention states up to that point. Subsequent requests with the same prefix up to a breakpoint hit the cache instead of recomputing from scratch.\",\n        code: {\n          language: \"python\",\n          content: `import anthropic\n\nclient = anthropic.Anthropic()\n\n# Large system prompt that stays constant across many requests\nLARGE_CODEBASE_CONTEXT = \"...\" * 10000  # 50k tokens of context\n\nresponse = client.messages.create(\n    model=\"claude-opus-4-6\",\n    max_tokens=1024,\n    system=[\n        {\n            \"type\": \"text\",\n            \"text\": LARGE_CODEBASE_CONTEXT,\n            \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê cache this prefix\n        }\n    ],\n    messages=[\n        {\"role\": \"user\", \"content\": \"What does the auth module do?\"}\n    ]\n)\n\n# Usage shows cache performance:\nprint(response.usage.cache_creation_input_tokens)  # first request\nprint(response.usage.cache_read_input_tokens)       # subsequent requests`,\n        },\n      },\n      {\n        heading: \"Cache Lifetime\",\n        body: \"Ephemeral caches last for 5 minutes by default (extendable). Each cache hit resets the timer. Caches are invalidated if the cached prefix changes at all ‚Äî even a single character difference means a cache miss. Plan your system prompts to have stable prefixes.\",\n        code: {\n          language: \"python\",\n          content: `# Good: stable prefix, variable content comes after cache point\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": \"You are an expert code reviewer. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}   # ‚Üê cache this\n    },\n    {\n        \"type\": \"text\",\n        \"text\": f\"Review this code: {user_submitted_code}\"  # ‚Üê not cached, varies\n    }\n]\n\n# Bad: variable content before the cache point (kills cache hits)\nmessages = [\n    {\n        \"type\": \"text\",\n        \"text\": f\"Today is {datetime.now()}. [Large stable instructions...]\",\n        \"cache_control\": {\"type\": \"ephemeral\"}  # ‚Üê never hits cache!\n    }\n]`,\n        },\n      },\n      {\n        heading: \"When to Use\",\n        body: \"Prompt caching is most valuable when: the same large context is used across many requests (document QA, codebase chat), you have a large stable system prompt, or you're running batch operations over the same data.\",\n        code: {\n          language: \"text\",\n          content: `# Great use cases for prompt caching:\n- Chat over a large PDF document (cache the document)\n- Codebase-aware coding assistant (cache the full codebase)\n- Repeated analysis with same rules (cache the rule set)\n- Multi-turn conversations with stable system prompts\n\n# Cost comparison (approximate):\n# Without cache:  $0.015 per 1K input tokens (Sonnet 4.6)\n# Cache creation: $0.019 per 1K tokens (25% premium)\n# Cache reads:    $0.0015 per 1K tokens (90% discount!)`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Put the most stable content earliest in your prompt ‚Äî static instructions, documents, codebases ‚Äî and dynamic content last. Use multiple cache breakpoints to cache different layers. Monitor cache_read_input_tokens in usage stats to verify caching is working.\",\n      },\n    ],\n  },\n  {\n    slug: \"subagents\",\n    title: \"SubAgents\",\n    emoji: \"ü§ñ\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Spawn specialized subagents for parallel, isolated, and focused tasks.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Subagents are specialized AI assistants designed to handle focused types of tasks. Each runs in its own isolated context window with a dedicated system prompt, scoped tool access, and independent permissions. When Claude identifies a task that matches a subagent's capabilities, it delegates to that subagent ‚Äî which executes autonomously and returns its results to the main agent.\",\n      },\n     \n      {\n        heading: \"Subagent Types in Claude Code\",\n        body: \"Claude Code has built-in specialized subagent types: general-purpose (full tools access), Explore (codebase exploration), Plan (architecture planning), claude-code-guide (Claude Code documentation), and statusline-setup. Each is optimized for its domain.\",\n        code: {\n          language: \"text\",\n          content: `# Built-in subagent types:\ngeneral-purpose  ‚Äî Full tool access, multi-step autonomous tasks\nExplore          ‚Äî Fast codebase search and analysis\nPlan             ‚Äî Software architecture and implementation planning\nclaude-code-guide ‚Äî Claude Code feature documentation Q&A\nstatusline-setup  ‚Äî Configure Claude Code status line\n\n# Example: Claude might internally spawn:\nTask(subagent_type=\"Explore\",\n     prompt=\"Find all API route handlers in src/app/api/\")\n\nTask(subagent_type=\"Plan\",\n     prompt=\"Design the authentication system architecture\")`,\n        },\n      },\n      {\n        heading: \"Creating Your Own SubAgent\",\n        body: \"Subagents are defined in Markdown files with YAML frontmatter. You can create them manually or use the /agents command.\",\n        carousel: true,\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent1.png\", alt: \"Step 1 - Navigate to .claude/agents directory\" },\n          { src: \"/screenshots/subagents/Subagent2.png\", alt: \"Step 2 - Create a new agent markdown file\" },\n          { src: \"/screenshots/subagents/Subagent3.png\", alt: \"Step 3 - Add description frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent4.png\", alt: \"Step 4 - Write the system prompt body\" },\n          { src: \"/screenshots/subagents/Subagent5.png\", alt: \"Step 5 - Set tools field in frontmatter\" },\n          { src: \"/screenshots/subagents/Subagent6.png\", alt: \"Step 6 - Save and verify agent is listed\" },\n          { src: \"/screenshots/subagents/Subagent7.png\", alt: \"Step 7 - Trigger the agent with a matching task\" },\n          { src: \"/screenshots/subagents/Subagent8.png\", alt: \"Step 8 - Agent executes autonomously\" },\n          { src: \"/screenshots/subagents/Subagent9.png\", alt: \"Step 9 - Agent returns results to main context\" },\n          { src: \"/screenshots/subagents/Subagent10.png\", alt: \"Step 10 - Review and iterate on agent behavior\" },\n          { src: \"/screenshots/subagents/Subagent11.png\", alt: \"Step 11 - Created Agent .MD file\" },\n        ],\n      },\n      {\n        heading: \"SubAgent Execution\",\n        body: \"When Claude encounters a task matching a subagent's description, it delegates via the Task tool. The subagent spins up with its own context window, executes independently, and returns results to the main agent. The main agent can continue other work while a background subagent runs, or block and wait for a foreground subagent to finish.\",\n        screenshots: [\n          { src: \"/screenshots/subagents/Subagent Execution.png\", alt: \"SubAgent execution flow ‚Äî Task tool spawning a subagent and returning results to the main agent\" },\n        ],\n      },\n      {\n        heading: \"Parallel Execution\",\n        body: \"Subagents can run in parallel ‚Äî Claude can launch multiple subagents simultaneously for independent tasks, dramatically speeding up complex workflows. Foreground agents block until complete; background agents run asynchronously.\",\n        code: {\n          language: \"text\",\n          content: `# Claude might run these subagents in parallel:\n[Subagent 1] Explore: Find all components using useState\n[Subagent 2] Explore: Find all API routes in the project\n[Subagent 3] Explore: Find all TypeScript errors\n\n# Background agent (non-blocking):\nTask(run_in_background=True,\n     prompt=\"Run all tests and report failures\")\n\n# Main agent continues other work while subagent runs...\n# Gets notified when background agent completes`,\n        },\n      },\n    \n      {\n        heading: \"Tips\",\n        body: \"Subagents have clean context (no conversation history), so provide complete context in the prompt. Use Explore subagents to protect the main context window from large search results. Run independent research tasks in parallel for speed.\",\n      },\n    ],\n  },\n  {\n    slug: \"hooks\",\n    title: \"Hooks System\",\n    emoji: \"ü™ù\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Run shell commands automatically before or after Claude's tool calls.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Hooks are shell commands that Claude Code runs automatically in response to specific events ‚Äî before a tool runs (PreToolUse), after a tool runs (PostToolUse), when the session ends, or when you submit a message. They're configured in your Claude Code settings and enable powerful automation, validation, and guardrails.\",\n      },\n      {\n        heading: \"Hooks Configuration\",\n        body: \"Hooks are defined in Claude settings files. You can add them to:\",\n        bullets: [\n          \"Global ‚Äî ~/.claude/settings.json (affects all projects)\",\n          \"Project ‚Äî .claude/settings.json (shared with team)\",\n          \"Project (not committed) ‚Äî .claude/settings.local.json (personal settings)\",\n          \"You can write hooks by hand in these files or use the /hooks command inside Claude Code.\",\n        ],\n      },\n      {\n        heading: \"PreToolUse Hooks\",\n        body: \"PreToolUse hooks run before a tool is executed. They include a matcher that specifies which tool types to target. Before the 'Read' tool is executed, this configuration runs the specified command.\",\n        bullets: [\n          \"Allow the operation to proceed normally\",\n          \"Block the tool call and send an error message back to Claude.\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring hooks\n{\n  \"hooks\": {\n    PreToolUse\": [\n      {\n        \"matcher\": \"Read|Grep\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/read_hook.js\"\n          }\n        ]\n      }\n    ],\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Prehook.png\",\n            alt: \"PreToolUse hook blocking a Read tool call on .env file\",\n          },\n        ],\n      },\n      {\n        heading: \"PostToolUse Hooks\",\n        body: \"PostToolUse hooks run after a tool has been executed. Here's an example that triggers after write, edit, or multi-edit operations. Since the tool call has already occurred, PostToolUse hooks can't block the operation.\",\n        bullets: [\n          \"Run follow-up operations (like formatting a file that was just edited)\",\n          \"Provide additional feedback to Claude about the tool use\",\n        ],\n        code: {\n          language: \"json\",\n          content: `// settings.local.json ‚Äî configuring a PostToolUse hook\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ./hooks/edit_hook.js\"\n          }\n        ]\n      }\n    ]\n  }\n}`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Posthook.png\",\n            alt: \"PostToolUse hook logging an edit operation\",\n          },\n          {\n            src: \"/screenshots/hooks/Posthook Result.png\",\n            alt: \"PostToolUse hook logging an edit operation result\",\n          },\n        ],\n      },\n      {\n        heading: \"Available Tools\",\n        body: \"The matcher field in your hook config targets Claude's built-in tools by name. Use these tool names to scope your hooks precisely ‚Äî for example, match only Write|Edit to log file changes, or Bash to audit shell commands.\",\n        table: {\n          headers: [\"Tool Name\", \"Purpose\"],\n          rows: [\n            [\"Read\", \"Read a file\"],\n            [\"Edit, MultiEdit\", \"Edit an existing file\"],\n            [\"Write\", \"Create a file and write to it\"],\n            [\"Bash\", \"Execute a command\"],\n            [\"Glob\", \"Find files/folders based upon a pattern\"],\n            [\"Grep\", \"Search for content\"],\n            [\"Task\", \"Create a sub-agent to complete a particular task\"],\n            [\"WebFetch, WebSearch\", \"Search or fetch a particular page\"],\n          ],\n        },\n      },\n      {\n        heading: \"Other Hook Types\",\n        body: \"There are more hooks beyond the PreToolUse and PostToolUse hooks discussed in this course. There are also:\",\n        bullets: [\n          \"Notification - Runs when Claude Code sends a notification, which occurs when Claude needs permission to use a tool, or after Claude Code has been idle for 60 seconds\",\n          \"Stop - Runs when Claude Code has finished responding\",\n          \"SubagentStop - Runs when a subagent (these are displayed as a \\\"Task\\\" in the UI) has finished\",\n          \"PreCompact - Runs before a compact operation occurs, either manual or automatic\",\n          \"UserPromptSubmit - Runs when the user submits a prompt, before Claude processes it\",\n          \"SessionStart - Runs when starting or resuming a session\",\n          \"SessionEnd - Runs when a session ends\",\n        ],\n      \n      },\n      {\n        heading: \"Hook Payload Structure\",\n        body: \"The stdin JSON your hook receives differs based on two things: the hook event type, and (for PreToolUse/PostToolUse) which tool was called. This is the most confusing part of hooks ‚Äî the shape of the payload is not uniform.\",\n        bullets: [\n          \"PreToolUse and PostToolUse payloads include tool_name and tool_input ‚Äî but tool_input fields vary per tool (e.g. file_path for Read/Edit, command for Bash)\",\n          \"Notification payloads include a message field describing what triggered the notification\",\n          \"Stop, SubagentStop, SessionStart, SessionEnd payloads are minimal ‚Äî mainly hook_event_name plus session metadata\",\n          \"UserPromptSubmit includes the prompt text the user just submitted\",\n          \"PreCompact includes context about the compaction being triggered\",\n          \"Always log the full payload during development (JSON.stringify(payload)) to discover the exact shape for your target hook and tool\",\n        ],\n        code: {\n          language: \"js\",\n          content: `// session_hook.js\n// Discover the payload shape for any hook ‚Äî log everything first\n\nconst fs = require(\"fs\");\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) chunks.push(chunk);\n  const payload = JSON.parse(Buffer.concat(chunks).toString());\n\n  // Read existing entries, append new one, write back\n  const logPath = \"./hooks/payloads.json\";\n  let entries = [];\n  if (fs.existsSync(logPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(logPath, \"utf8\"));\n    } catch {\n      entries = [];\n    }\n  }\n\n  entries.push({ timestamp: new Date().toISOString(), payload });\n  fs.writeFileSync(logPath, JSON.stringify(entries, null, 2));\n}\n\nmain();\n`,\n        },\n        screenshots: [\n          {\n            src: \"/screenshots/hooks/Payload.png\",\n            alt: \"Sampe payload logged by a hook\",\n          },\n        \n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Start with simple logging hooks before building complex blocking logic. Use hooks for cross-cutting concerns (formatting, linting, auditing) rather than task-specific logic. Make hooks idempotent ‚Äî they may run multiple times. Always handle hook failures gracefully with `|| true` to avoid blocking Claude unnecessarily.\",\n      },\n    ],\n  },\n  {\n    slug: \"skills\",\n    title: \"Skills System\",\n    emoji: \"üéØ\",\n    category: \"Automation\",\n    difficulty: \"Intermediate\",\n    released: true,\n    shortDesc:\n      \"Create custom slash commands that expand into full prompts for repeated workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Skills are custom slash commands you define for Claude Code. Each skill lives in its own directory with a SKILL.md file ‚Äî YAML frontmatter declares the command name and description, and the markdown body is the prompt Claude follows when the skill is invoked. Skills can be personal (~/. claude/skills/) or project-scoped (.claude/skills/), and can be triggered manually or automatically when Claude recognises a matching request.\",\n      },\n      {\n        heading: \"Step 1 ‚Äî Create the Skill Directory\",\n        body: \"Each skill lives in its own directory. Use ~/.claude/skills/ for personal skills available across all your projects, or .claude/skills/ for project-specific skills you can commit to git. The directory name becomes the slash command.\",\n        code: {\n          language: \"bash\",\n          content: `# Personal skill ‚Äî available in all your projects:\nmkdir -p ~/.claude/skills/explain-code\n\n# Project-specific skill ‚Äî commit to git so the team shares it:\nmkdir -p .claude/skills/explain-code`,\n        },\n        \n      },\n      {\n        heading: \"Step 2 ‚Äî Write SKILL.md\",\n        body: \"Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with the instructions Claude follows when invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.\",\n        code: {\n          language: \"markdown\",\n          content: `# ~/.claude/skills/explain-code/SKILL.md\n\n---\nname: explain-code\ndescription: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks \"how does this work?\"\n---\n\nWhen explaining code, always include:\n\n1. **Start with an analogy**: Compare the code to something from everyday life\n2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships\n3. **Walk through the code**: Explain step-by-step what happens\n4. **Highlight a gotcha**: What's a common mistake or misconception?\n\nKeep explanations conversational. For complex concepts, use multiple analogies.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill.png\", alt: \"Creating the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Step 3 ‚Äî Test the Skill\",\n        body: \"You can invoke a skill two ways. Let Claude pick it up automatically by asking something that matches the description, or invoke it directly with the slash command and any arguments. Either way, Claude expands the SKILL.md content into a full prompt and executes it.\",\n        code: {\n          language: \"text\",\n          content: `# Let Claude invoke it automatically (matches description):\nHow does this code work?\n\n# Or invoke it directly with the skill name:\n/explain-code src/auth/login.ts\n\n# Either way Claude should include an analogy and ASCII diagram.`,\n        },\n        screenshots: [\n          { src: \"/screenshots/skills/Skill Work.png\", alt: \"Testing the skill directory in ~/.claude/skills/\" },\n        ],\n      },\n      {\n        heading: \"Tips\",\n        body: \"Write a tight description ‚Äî it's what Claude uses to decide whether to auto-invoke the skill. Keep SKILL.md instructions specific and detailed; vague skills produce vague results. Commit project skills to git so the whole team benefits from them.\",\n      },\n    ],\n  },\n   {\n    slug: \"mcp\",\n    title: \"MCP (Model Context Protocol)\",\n    emoji: \"üîå\",\n    category: \"Integration\",\n    difficulty: \"Advanced\",\n    released: true,\n    shortDesc:\n      \"Connect Claude to external tools, databases, and services via MCP servers.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Model Context Protocol (MCP) is an open standard that lets Claude connect to external tools and data sources through local or remote servers. MCP servers expose tools, resources, and prompts that Claude can use just like built-in tools. This lets you connect Claude to databases, APIs, browsers, Jira, Slack, GitHub, and anything else you can write a server for.\",\n      },\n      {\n        heading: \"MCP Architecture\",\n        body: \"MCP follows a client-server architecture. Claude Code is the MCP client; MCP servers run locally or remotely and expose capabilities. Communication happens over stdio (local) or HTTP/SSE (remote). Claude discovers available tools from connected servers and can use them transparently.\",\n        code: {\n          language: \"text\",\n          content: `MCP Architecture:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Claude Code                ‚îÇ\n‚îÇ  (MCP Client)                           ‚îÇ\n‚îÇ  - Discovers tools from servers         ‚îÇ\n‚îÇ  - Calls mcp__server__tool_name()       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ stdio / HTTP+SSE\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ          MCP Servers          ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n    ‚îÇ  filesystem    ‚Äî file access  ‚îÇ\n    ‚îÇ  github        ‚Äî GitHub API   ‚îÇ\n    ‚îÇ  postgres      ‚Äî DB queries   ‚îÇ\n    ‚îÇ  browsertools  ‚Äî browser ctrl ‚îÇ\n    ‚îÇ  slack         ‚Äî messaging    ‚îÇ\n    ‚îÇ  your-server   ‚Äî custom tools ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,\n        },\n      },\n      {\n        heading: \"Installing the Playwright MCP Server\",\n        body: \"To add the Playwright server to Claude Code, run this command in your terminal (not inside Claude Code):\",\n        code: {\n          language: \"bash\",\n          content: `claude mcp add playwright npx @playwright/mcp@latest`,\n        },\n         screenshots: [\n          { src: \"/screenshots/mcp/Tool.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n          { src: \"/screenshots/mcp/Youtube.png\", alt: \"The Playwright MCP server installed in Claude Code\" },\n        ],\n        note: \"This command does two things:\",\n        bullets: [\n          'Names the MCP server \"playwright\"',\n          \"Provides the command that starts the server locally on your machine\",\n        ],\n      },\n      {\n        heading: \"Managing Permissions\",\n        body: \"When you first use MCP server tools, Claude will ask for permission each time. If you get tired of these permission prompts, you can pre-approve the server by editing your settings. Open the .claude/settings.local.json file and add the server to the allow array:\",\n        note: \"Note the double underscores in mcp__playwright. This allows Claude to use the Playwright tools without asking for permission every time.\",\n\n        code: {\n          language: \"json\",\n          content: `{\n  \"permissions\": {\n    \"allow\": [\"mcp__playwright\"],\n    \"deny\": []\n  }\n}`,\n        },\n       \n         screenshots: [\n          { src: \"/screenshots/mcp/Permission.png\", alt: \"The permission management UI in Claude Code\" },\n        ],\n      },\n      {\n        heading: \"Practical Example: Using the Playwright MCP Server to naviagate your app and login using dummy credentials\",\n        body: \"Here's a real-world example of how the Playwright MCP server can improve your development workflow. Instead of manually testing and tweaking prompts, you can have Claude:\",\n       \n        code: {\n          language: \"text\",\n          content: `\"Navigate to localhost:3000, click the login button, and attempt to log in with dummy credentials. If the login fails, modify the prompt to fix it and try again until it works.\"`,\n        },\n        screenshots: [\n          { src: \"/screenshots/mcp/Tool2.png\", alt: \"The Playwright MCP server in action\" },\n          { src: \"/screenshots/mcp/Tool3.png\", alt: \"The Playwright MCP server in action\" },\n        ],\n        note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",\n      },\n      \n    ],\n  },\n  {\n    slug: \"plugins\",\n    title: \"Plugins\",\n    emoji: \"üß©\",\n    category: \"Integration\",\n    difficulty: \"Intermediate\",\n    released: false,\n    releaseDate: \"March 2\",\n    shortDesc:\n      \"Extend Claude Code with community and custom plugins to add new tools, commands, and capabilities.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Plugins extend Claude Code beyond its built-in capabilities. They can add new slash commands, custom tools, MCP server integrations, and workflow automations. Plugins are distributed as npm packages, git repos, or local directories and are registered in your settings files.\",\n      },\n      {\n        heading: \"How Plugins Work\",\n        body: \"A Claude Code plugin is essentially a package that contributes one or more of: MCP servers (new tools Claude can call), skills (slash commands), hooks (lifecycle scripts), or prompt templates. When Claude Code starts, it reads your settings and loads the registered plugins.\",\n        code: {\n          language: \"text\",\n          content: `Plugin\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ MCP Servers   ‚Üí new tools Claude can call (e.g., mcp__github__*)\n  ‚îú‚îÄ‚îÄ Skills        ‚Üí new slash commands (e.g., /my-command)\n  ‚îú‚îÄ‚îÄ Hooks         ‚Üí lifecycle scripts (PostToolUse, PreToolUse, etc.)\n  ‚îî‚îÄ‚îÄ Prompts       ‚Üí reusable prompt templates\n\nClaude Code reads ~/.claude/settings.json + .claude/settings.json\n  ‚Üí loads registered plugins at startup\n  ‚Üí exposes their tools / commands in the session`,\n        },\n      },\n      {\n        heading: \"Adding a Plugin via MCP\",\n        body: \"The most common plugin format is an MCP server. Use `claude mcp add` to register one. Plugins added this way are saved to your settings automatically and available in every session.\",\n        code: {\n          language: \"bash\",\n          content: `# Add an MCP-based plugin from npm\nclaude mcp add <name> npx <package>\n\n# Examples:\nclaude mcp add github npx @modelcontextprotocol/server-github\nclaude mcp add filesystem npx @modelcontextprotocol/server-filesystem /path\nclaude mcp add playwright npx @playwright/mcp@latest\n\n# List installed plugins / MCP servers\nclaude mcp list\n\n# Remove a plugin\nclaude mcp remove <name>`,\n        },\n      },\n      {\n        heading: \"Registering Plugins in settings.json\",\n        body: \"For version-controlled, team-shared plugins, declare them directly in `.claude/settings.json`. This way every contributor gets the same plugins without running any setup commands.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\\${GITHUB_TOKEN}\"\n      }\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./src\"]\n    }\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Skills as Local Plugins\",\n        body: \"Skills are Claude Code's lightweight plugin format for slash commands. Drop a `.md` file into `.claude/skills/` and it becomes a `/skill-name` command. No install step needed ‚Äî just a markdown file with instructions.\",\n        code: {\n          language: \"text\",\n          content: `# File: .claude/skills/review-pr.md\n# Becomes: /review-pr command\n\n# File: .claude/skills/deploy.md\n# Becomes: /deploy command\n\n.claude/\n‚îî‚îÄ‚îÄ skills/\n    ‚îú‚îÄ‚îÄ review-pr.md   ‚Üí /review-pr\n    ‚îú‚îÄ‚îÄ deploy.md      ‚Üí /deploy\n    ‚îî‚îÄ‚îÄ audit.md       ‚Üí /audit`,\n        },\n      },\n      {\n        heading: \"Plugin Permissions\",\n        body: \"MCP plugin tools follow the same allow/deny permission model as built-in tools. Tool names are prefixed with `mcp__<server-name>__`. Pre-approve specific tools in your settings to avoid permission prompts on every call.\",\n        code: {\n          language: \"json\",\n          content: `// .claude/settings.local.json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__github__*\",\n      \"mcp__playwright__*\",\n      \"mcp__filesystem__read_file\",\n      \"mcp__filesystem__list_directory\"\n    ],\n    \"deny\": [\n      \"mcp__filesystem__write_file\"\n    ]\n  }\n}`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Prefer declaring shared plugins in `.claude/settings.json` (committed) so teammates don't need manual setup. Use `.claude/settings.local.json` for plugins with personal credentials. Keep plugin permissions as narrow as possible ‚Äî allow specific tool patterns rather than `mcp__server__*` wildcards where you can.\",\n      },\n    ],\n    references: [\n      {\n        label: \"MCP Servers Registry\",\n        url: \"https://github.com/modelcontextprotocol/servers\",\n        description: \"Official list of community MCP servers you can use as plugins.\",\n      },\n      {\n        label: \"Claude Code Skills Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/skills\",\n        description: \"How to create and use skills as slash commands.\",\n      },\n    ],\n  },\n  {\n    slug: \"worktrees\",\n    title: \"Worktrees\",\n    emoji: \"üå≥\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 4\",\n    shortDesc:\n      \"Isolate experimental changes in git worktrees for safe parallel development.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Git worktrees let you check out multiple branches simultaneously in separate directories. Claude Code integrates with worktrees to give subagents isolated environments for experimental changes ‚Äî they can write, edit, and test without touching your main working directory. If the experiment works, you merge; if not, you discard.\",\n      },\n      {\n        heading: \"What Are Worktrees?\",\n        body: \"A git worktree is an additional working directory linked to the same git repository. Each worktree has its own branch checked out independently. Claude Code creates worktrees in .claude/worktrees/ and automatically cleans them up.\",\n        code: {\n          language: \"bash\",\n          content: `# Git worktrees basics:\ngit worktree list                   # show all worktrees\ngit worktree add ../feature-branch feature-branch  # add worktree\ngit worktree remove ../feature-branch              # remove worktree\n\n# Claude Code creates them automatically in:\n.claude/worktrees/<name>/\n\n# Each worktree is a full checkout:\n.claude/worktrees/\n‚îú‚îÄ‚îÄ refactor-auth/      ‚Üê branch: claude/refactor-auth\n‚îÇ   ‚îî‚îÄ‚îÄ [full project copy checked out here]\n‚îî‚îÄ‚îÄ experiment-1/       ‚Üê branch: claude/experiment-1\n    ‚îî‚îÄ‚îÄ [another full project copy]`,\n        },\n      },\n      {\n        heading: \"Using Worktrees in Claude Code\",\n        body: \"Use the /worktree command inside Claude Code to create an isolated environment for the current session. The session's working directory switches to the worktree. Changes are isolated on a new branch.\",\n        code: {\n          language: \"text\",\n          content: `# Inside Claude Code session:\n> /worktree my-experiment\n\n[Claude creates a new worktree branch: claude/my-experiment]\n[Session working directory switches to .claude/worktrees/my-experiment/]\n\n> Now try refactoring the authentication module and see if all tests pass\n\n[Claude makes changes only in the worktree branch]\n[Main branch and working directory are untouched]\n\n# When done:\n> The refactoring looks good, merge it into main\n[Claude merges the worktree branch back]\n\n# Or discard:\n> Actually, let's abandon this approach\n[Worktree is removed, no changes to main branch]`,\n        },\n      },\n      {\n        heading: \"Worktree Isolation for Subagents\",\n        body: \"Subagents can be launched with worktree isolation, getting their own temporary branch. This is used for exploratory tasks where you want to evaluate changes before committing to them.\",\n        code: {\n          language: \"text\",\n          content: `# In Claude Code, subagents with worktree isolation:\nTask(\n    isolation=\"worktree\",\n    prompt=\"Try converting all class components to hooks and verify tests pass\"\n)\n\n# What happens:\n# 1. Claude creates .claude/worktrees/<random-name>/\n# 2. Subagent checks out a new branch there\n# 3. Subagent makes all changes in isolation\n# 4. If tests pass ‚Üí report success, offer to merge\n# 5. If tests fail ‚Üí report failure, discard worktree\n# 6. Main working directory untouched throughout`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Use worktrees for risky refactors, large feature work, or any experiment you might want to discard. Worktrees require more disk space (full checkout per worktree). Clean up old worktrees with git worktree prune. Worktrees are most valuable when combined with subagents for truly autonomous experimentation.\",\n      },\n    ],\n  },\n  {\n    slug: \"agent-teams\",\n    title: \"Agent Teams\",\n    emoji: \"üë•\",\n    category: \"Automation\",\n    difficulty: \"Advanced\",\n    released: false,\n    releaseDate: \"March 5\",\n    shortDesc:\n      \"Orchestrate multiple specialized agents working together to tackle complex, multi-step workflows.\",\n    sections: [\n      {\n        heading: \"Overview\",\n        body: \"Agent teams are coordinated groups of specialized agents that collaborate to complete complex tasks. An orchestrator agent breaks work into subtasks and delegates to specialist agents ‚Äî each focused on a specific domain. Results flow back to the orchestrator, which synthesizes them and drives the workflow forward.\",\n      },\n      {\n        heading: \"Team Architecture\",\n        body: \"A typical agent team has an orchestrator at the top that plans and coordinates, plus a set of specialist agents below it. Each specialist has scoped tools, a focused system prompt, and returns results to the orchestrator.\",\n        code: {\n          language: \"text\",\n          content: `Agent Team Architecture:\n\nOrchestrator Agent\n‚îú‚îÄ‚îÄ Plans the overall workflow\n‚îú‚îÄ‚îÄ Delegates to specialists\n‚îî‚îÄ‚îÄ Synthesizes results\n\n    ‚îú‚îÄ‚îÄ Explorer Agent      ‚Üí reads files, searches code\n    ‚îú‚îÄ‚îÄ Planner Agent       ‚Üí designs architecture\n    ‚îú‚îÄ‚îÄ Coder Agent         ‚Üí writes and edits code\n    ‚îú‚îÄ‚îÄ Tester Agent        ‚Üí runs tests, validates output\n    ‚îî‚îÄ‚îÄ Reviewer Agent      ‚Üí audits code quality`,\n        },\n      },\n      {\n        heading: \"Orchestrator Pattern\",\n        body: \"The orchestrator is a general-purpose agent with a system prompt that instructs it to break tasks into subtasks and delegate. It uses the Task tool to spin up specialist subagents with isolated context windows and scoped tool access.\",\n        code: {\n          language: \"markdown\",\n          content: `# .claude/agents/orchestrator.md\n---\ndescription: Coordinates multi-agent workflows for complex tasks\ntools: Task, Read, Write, Bash\n---\n\nYou are an orchestrator. When given a complex task:\n1. Break it into independent subtasks\n2. Identify the right specialist agent for each subtask\n3. Launch specialists via Task tool (in parallel where possible)\n4. Collect results and synthesize them\n5. Continue until the task is complete\n\nAlways run independent subtasks in parallel using Task(run_in_background=True).`,\n        },\n      },\n      {\n        heading: \"Parallel vs Sequential Execution\",\n        body: \"Agent teams shine when subtasks can run in parallel. Independent tasks (e.g., exploring different parts of a codebase, running different test suites) should always run simultaneously. Dependent tasks must run sequentially ‚Äî the orchestrator waits for upstream results before launching downstream agents.\",\n        code: {\n          language: \"text\",\n          content: `# Parallel team execution:\nOrchestrator spawns simultaneously:\n  [Agent A] bg: Analyze frontend components\n  [Agent B] bg: Analyze API routes\n  [Agent C] bg: Analyze database schema\n\n[All three run at the same time]\n[Orchestrator collects all three results]\n[Synthesizes into a full architecture summary]\n\n# Sequential team execution:\n  [Agent 1] Plan the refactor   ‚Üí wait for plan\n  [Agent 2] Implement the plan  ‚Üí wait for impl\n  [Agent 3] Test the impl       ‚Üí wait for tests\n  [Orchestrator] Merge if tests pass`,\n        },\n      },\n      {\n        heading: \"Scoping Agent Permissions\",\n        body: \"Each agent in the team should have the minimum tools needed for its role. Explorer agents need read tools only. Coder agents need write tools. Tester agents need bash. This limits blast radius if an agent makes a mistake.\",\n        code: {\n          language: \"markdown\",\n          content: `# Explorer agent ‚Äî read-only\n---\ntools: Glob, Grep, Read\n---\n\n# Coder agent ‚Äî writes code\n---\ntools: Read, Write, Edit, Glob, Grep\n---\n\n# Tester agent ‚Äî runs commands\n---\ntools: Bash, Read\n---\n\n# Reviewer agent ‚Äî read + bash (linting)\n---\ntools: Read, Glob, Grep, Bash\n---`,\n        },\n      },\n      {\n        heading: \"Tips\",\n        body: \"Keep orchestrator prompts high-level ‚Äî they should plan and delegate, not implement. Give each specialist a tight, focused system prompt. Use background agents for independent work and collect results asynchronously. Agent teams scale well for large tasks but add coordination overhead for simple ones ‚Äî use subagents directly for straightforward work.\",\n      },\n    ],\n    references: [\n      {\n        label: \"SubAgents Concept\",\n        url: \"/concepts/subagents\",\n        description: \"How individual subagents work before composing them into teams.\",\n      },\n      {\n        label: \"Claude Code Sub-Agents Docs\",\n        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",\n        description: \"Official docs on Claude Code subagents and orchestration.\",\n      },\n    ],\n  },\n];\n",
        "structuredPatch": [
          {
            "oldStart": 1668,
            "oldLines": 8,
            "newStart": 1668,
            "newLines": 19,
            "lines": [
              "         ],",
              "         note: \"Claude will use the browser tools to interact with your app, examine the generated output, and then modify your prompt file to encourage more original and creative designs.\",",
              "       },",
              "-      ",
              "     ],",
              "+    references: [",
              "+      {",
              "+        label: \"SubAgents Concept\",",
              "+        url: \"/concepts/subagents\",",
              "+        description: \"How individual subagents work before composing them into teams.\",",
              "+      },",
              "+      {",
              "+        label: \"Claude Code Sub-Agents Docs\",",
              "+        url: \"https://docs.anthropic.com/en/docs/claude-code/sub-agents\",",
              "+        description: \"Official docs on Claude Code subagents and orchestration.\",",
              "+      },",
              "+    ],",
              "   },",
              "   {",
              "     slug: \"plugins\","
            ]
          }
        ],
        "userModified": false,
        "replaceAll": false
      },
      "tool_use_id": "toolu_01Wq2KB9EEn5Pat7vsqjVU1M"
    }
  },
  {
    "timestamp": "2026-02-28T07:32:57.105Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "Stop",
      "stop_hook_active": false,
      "last_assistant_message": "Added the references block to the MCP concept at `concepts.ts:1672`."
    }
  },
  {
    "timestamp": "2026-02-28T07:32:58.506Z",
    "payload": {
      "session_id": "ff58eb76-ba7a-4819-bdab-2d483010e5cd",
      "transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd.jsonl",
      "cwd": "C:\\Learning\\Personal\\Anthropic Learning\\claude-learning-app",
      "permission_mode": "default",
      "hook_event_name": "SubagentStop",
      "stop_hook_active": false,
      "agent_id": "ac2992d473206fefa",
      "agent_transcript_path": "C:\\Users\\mohan\\.claude\\projects\\C--Learning-Personal-Anthropic-Learning-claude-learning-app\\ff58eb76-ba7a-4819-bdab-2d483010e5cd\\subagents\\agent-ac2992d473206fefa.jsonl",
      "agent_type": "",
      "last_assistant_message": "now show the coming soon badge on the concept cards"
    }
  }
]